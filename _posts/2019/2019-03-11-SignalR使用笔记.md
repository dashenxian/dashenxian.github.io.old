---
title: "SignalR使用笔记"
publishDate: 2019-03-11 14:26:00 +0800
date: 2019-03-11 14:14:08 +0800
categories: SignalR使用笔记
position: problem
---

---

<div id="toc"></div>

## 最近项目要求添加一个给用户发送消息的功能，就决定使用SignalR。翻到了以前学习SignalR的学习笔记，基本是官方文档的简版整理，便于快速阅览和实现。
## 1. nuget添加signalr引用：
### a. install-package Microsoft.AspNet.SignalR
### b. silverlight安装时startup中找不到IAppBuilder接口： Update-Package Owin -Reinstall
## 2. 新建hub集线器类
### ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194350112-1816133811.png)
### a. 添加调用客户端方法，调用的js方法在运行时解析，signalr将方法名称和参数值发送到客户端。如果客户端有与该名称匹配的方法，则调用该方法，并把参数值传递给该方法。如果没有找到匹配的方法，则不会报错。方法名称匹配不区分大小写。
###### ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194405720-611584963.png)
###### i. js使用驼峰命名方式：第一个字母小写，调用服务端方法时会自动转换成c#命名方式（第一个字母大写）。指定集线器名称时，应该与客户端js调用方法名称一致。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194413212-585829801.png)
######### 2) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194420717-683653724.png)
### b. 可以定义多个集线器。与在单个类中定义所有集线器功能相比，多个集线器没有性能差异。
### c. 强类型集线器
###### i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194511355-764967460.png)
### d. 客户端调用服务端方法与调用本地js方法相同，可以获取复杂类型的json格式返回值。
### e. 同步/异步方法
###### i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194517530-592576513.png)
###### ii. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194521733-1156005061.png)
###### iii. js：![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194526837-1152287185.png)
############
### f. 异步调用客户端方法时，不会等待客户端方法执行完成，会继续执行下面的代码：
###### i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194545511-1842479723.png)
### g. 重载：如果要定义方法的重载，每个重载中的参数数必须不同。如果您通过指定不同的参数类型来区分重载，则Hub类将编译，但是当客户端尝试调用其中一个重载时，SignalR服务将在运行时抛出异常。
### h. 从集线器方法调用报告进度（SignalR 2.1版本）。要实现进度报告，IProgress<T>请为客户端可以访问的集线器方法定义一个参数：
###### i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194553601-851826638.png)
### i. 调用客户端方法：
###### i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194600480-626466364.png)
###### ii. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194606295-1184127468.png)
###### iii. 不能从客户端方法中获取返回值，以下代码不起作用：
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194614825-1354544929.png)
###### iv. 字符串变量作为方法名称
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194625587-95566107.png)
### j. 获取连接的客户端：
###### i. 所有连接的客户端
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194634571-1871653403.png)
###### ii. 只有主叫客户端。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194643998-1761237497.png)
###### iii. 所有客户端，除了主叫客户端。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194651352-637900051.png)
###### iv. 由连接ID标识的特定客户端。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194658571-1082571290.png)
###### v. 所有连接的客户端，除了指定的客户端，由连接ID标识。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194705343-758132222.png)
###### vi. 指定组中的所有连接的客户端。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194711645-1019939787.png)
###### vii. 指定组中的所有连接的客户端，除了指定的客户端，由连接ID标识。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194718640-2035790128.png)
###### viii. 指定组中的所有连接的客户端，除了主叫客户端。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194726916-520792075.png)
###### ix. 由userId标识的特定用户。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194848831-58144219.png)
######### 2) 默认情况下，这是IPrincipal.Identity.Name，但是可以通过向全局主机注册IUserIdProvider的实现来更改。
###### x. 连接ID列表中的所有客户端和组。
######### 1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194734495-653344623.png)
######xi. 组列表。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194839868-1910642713.png)
######xii. 按用户连接id。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194829777-2125113986.png)
######xiii. 用户名列表（在SignalR 2.1中引入）。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194818573-266979717.png)
###k. 获取有关客户端的信息
######i. 主叫客户端的连接ID。连接ID是由SignalR分配的GUID（您不能在自己的代码中指定值）。每个连接都有一个连接ID，如果应用程序中有多个Hub，则所有Hub都使用相同的连接ID。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194902064-1607656551.png)
######ii. HTTP标头数据。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194909601-796526375.png)
######iii. 查询字符串数据。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194930117-774921140.png)
######iv. Cookies
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194936770-126933946.png)
######v. 用户信息
#########![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311194956912-1689320196.png)
######vi. 请求的HttpContext对象
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195004941-1866191022.png)
##3. 创建owin启动类
###a. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195016058-1892533030.png)
###b. 添加路由，如果要将SignalR功能添加到ASP.NET MVC应用程序，请确保在其他路由之前添加SignalR路由。
######i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195028532-1441414820.png)
######ii. 指定URL的服务器代码。默认情况下，客户端用于连接到Hub的路由URL为“/ signalr”，该URL用于自动生成的JavaScript文件。
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195037654-1060469139.png)
#########2) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195046647-1573048941.png)
######iii. 指定URL的JavaScript客户端代码（使用生成的代理）
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195052396-1770226449.png)
######iv. 指定URL的JavaScript客户端代码（不带生成的代理）
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195100805-89576615.png)
######v. 指定URL的.NET客户端代码
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195107921-1347842807.png)
###c. 如何自定义Hubs管道。SignalR使您可以将自己的代码注入Hub管道。以下示例显示了一个自定义集线器管道模块，用于记录从客户端接收的每个传入方法调用和在客户机上调用的传出方法调用：
######i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195116051-1664831630.png)
######ii. 在Startup.cs文件中将模块注册到Hub管道中运行
#########1) ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195121862-778400553.png)
##4. 添加html页面
###a. 代码：
######i. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195129390-1881749699.png)
######ii. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195135830-604342685.png)
##5. 启用日志记录，在启动之前加上$.connection.hub.logging = true;
###a. ![](https://img2018.cnblogs.com/blog/208398/201903/208398-20190311195200214-1069066636.png)
