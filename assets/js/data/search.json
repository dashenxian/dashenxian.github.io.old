[ { "title": "AutoCAD2014打开特性显示空白", "url": "/post/AutoCAD2014%E6%89%93%E5%BC%80%E7%89%B9%E6%80%A7%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD", "categories": "windows, AutoCAD, 2014", "tags": "", "date": "2022-02-17 19:14:08 +0800", "snippet": "AutoCAD2014不知道什么原因，右键点击任何对象显示特性，特性界面都不能查看到对象的属性。问题AutoCAD2014不知道什么原因，右键点击任何对象显示特性，特性界面都不能查看到对象的属性。解决重装CAD没有解决问题，修复安装也不行。可以尝试把C:\\Program Files\\Common Files\\Autodesk Shared\\axdb19chs.tlb和AcAuthEntities19chs.tlb文件复制到AutoCAD2014的安装目录下C:\\Program Files\\Autodesk\\AutoCAD 2014。经测试多段线只需axdb19chs.tlb文件就可以显示特性。如果是其他版本的CAD应该可以把axdb19chs.tlb的19换成对应的版本号（我没有尝试）。如果你没有C:\\Program Files\\Common Files\\Autodesk Shared\\axdb19chs.tlb文件，也可以到CAD安装包中找到。原因正在探索……参考资料" }, { "title": "Linux上FastReport生成PDF换行错误", "url": "/post/Linux%E4%B8%8AFastReport%E7%94%9F%E6%88%90PDF%E6%8D%A2%E8%A1%8C%E9%94%99%E8%AF%AF", "categories": "linux, .net, core, Graphics, DrawString", "tags": "", "date": "2022-01-11 19:14:08 +0800", "snippet": "在Linux上使用FastReport生成PDF出现文本内容换行无效，这是由于fastReport调用Graphics.DrawString绘制文字，而在Linux系统中Graphics.DrawString则调用mono实现的libgdiplus库，最终问题就是libgdiplus库实现有问题，这样不光FastReport有问题，凡是调用Graphics.DrawString绘制文字都会有问题。解决方法需要自己使用Pango重新编译libgdiplus库 安装依赖sudo apt-get install libgif-dev autoconf libtool automake build-essential gettext libglib2.0-dev libcairo2-dev libtiff-dev libexif-dev libpango1.0-dev 获取libgdiplus源码git clone https://github.com/mono/libgdiplus.git 编译 ./autogen.sh --with-pango --prefix=/usr make 安装或替换sudo make install或者把编译的libgdiplus.so.0.0.0文件复制到/usr/lib目录中，注意手动复制的可能需要修改文件权限chmod 644 /usr/lib/libgdiplus.so.0.0.0 如果需要拷贝到其他系统使用，libgdiplus还有依赖其他库，可以通过ldd usr/lib/libgdiplus.so.0.0.0查看对应的依赖并安装，你也可以直接安装以下两个库就可以了apt-get install -y libcairo2 libpango1.0测试代码using System.Drawing;internal class Program{ static void Main(string[] args) { var width = 50; var height = 400; var pageBitmap = new Bitmap(width, height); var pageGraphics = Graphics.FromImage(pageBitmap); // Create font and brush. var drawFont = new Font(&quot;宋体&quot;, 11); var drawBrush = new SolidBrush(Color.Black); // Set format of string. var drawString = &quot;这是一段测试文本&quot;; var drawFormat = new StringFormat(); drawFormat.FormatFlags = 0;//StringFormatFlags.NoWrap; drawFormat.Trimming = StringTrimming.Word; // Draw string to screen. pageGraphics.DrawString(drawString, drawFont, drawBrush, new Rectangle(0, 0, 50, 400), drawFormat); pageBitmap.Save(&quot;a.jpg&quot;); }}在项目文件中添加System.Drawing.Common引用 &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;System.Drawing.Common&quot; Version=&quot;5.0.3&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;参考资料 Building libgdiplus library from source" }, { "title": "判断几何图形顶点坐标集合是顺时针还是逆时针", "url": "/post/%E5%88%A4%E6%96%AD%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E9%A1%B6%E7%82%B9%E5%9D%90%E6%A0%87%E9%9B%86%E5%90%88%E6%98%AF%E9%A1%BA%E6%97%B6%E9%92%88%E8%BF%98%E6%98%AF%E9%80%86%E6%97%B6%E9%92%88", "categories": "dotnet, csharp", "tags": "", "date": "2021-10-26 19:14:08 +0800", "snippet": "有时在业务中需要给一个几何图形的顶点坐标编号，因为只有一个连续的坐标点集合，但是编号需要按照顺时针，如果直接编号可能出现逆时针编号（如果绘制图形是逆时针，那么集合的顺序也是逆时针的），这是就需要反过来编号。代码直接上代码吧void Main(){//var list = new List&amp;lt;Point&amp;gt; { new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(0, 1), new Point(0, 0) };//var list = new List&amp;lt;Point&amp;gt; {//new Point{ X= 0.0000m , Y= 0.0000m },//new Point{ X= 0.6910m , Y= -1.4898m },//new Point{ X= 1.6711m , Y= -0.4859m },//new Point{ X= 2.8993m , Y= -1.1923m },//new Point{ X= 3.5112m , Y= -0.1284m },//new Point{ X= 4.3632m , Y= 0.5923m },//new Point{ X= 5.5666m , Y= -0.3620m },//new Point{ X= 4.5989m , Y= -0.8453m },//new Point{ X= 6.5467m , Y= -0.8453m },//new Point{ X= 6.5467m , Y= 0.4560m },//new Point{ X= 4.8347m , Y= 1.2863m },//new Point{ X= 3.0978m , Y= 1.2615m },//new Point{ X= 2.4899m , Y= 0.3073m },//new Point{ X= 0.0000m , Y= 0.0000m },//}; var list = new List&amp;lt;Point&amp;gt;{ new Point{ X= 1.4665m, Y= -5.3022m}, new Point{ X= 1.8634m, Y= -2.9629m}, new Point{ X= 3.2525m, Y= -4.8858m}, new Point{ X= 4.1852m, Y= -3.1017m}, new Point{ X= 6.1499m, Y= -4.6083m}, new Point{ X= 8.0351m, Y= -3.9343m}, new Point{ X= 7.3207m, Y= -6.1546m}, new Point{ X= 4.6218m, Y= -5.5995m}, new Point{ X= 4.7919m, Y= -4.7727m}, new Point{ X= 6.1987m, Y= -5.0621m}, new Point{ X= 4.9393m, Y= -4.2515m}, new Point{ X= 4.0265m, Y= -4.7669m}, new Point{ X= 4.0265m, Y= -5.8770m}, new Point{ X= 1.4665m, Y= -5.3022m}, }; decimal sum = 0; for (int i = 0; i &amp;lt; list.Count - 1; i++) { sum += (list[i + 1].X - list[i].X) * (list[i + 1].Y + list[i].Y); } if (sum &amp;gt; 0) { Console.WriteLine(&quot;顺时针,sum=&quot;+sum); } else { Console.WriteLine(&quot;逆时针,sum=&quot;+sum); }}class Point{ public Point() { } public Point(decimal x, decimal y) { X = x; Y = y; } public decimal X { get; set; } public decimal Y { get; set; }}主要逻辑就是计算sum += (P[n+1].X-Pn.Y)*(P[n+1].X+P[N].Y));具体原理见参考资料参考资料 Determining the Winding of a Polygon Given as a Set of Ordered Points How to determine if a list of polygon points are in clockwise order?" }, { "title": "dotnet使用Oracle.DataAccess访问Oracle数据库报错", "url": "/post/dotnet%E4%BD%BF%E7%94%A8Oracle.DataAccess%E8%AE%BF%E9%97%AEOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99", "categories": "Oracle, windows, dotnet, csharp, DataAccess", "tags": "", "date": "2021-09-19 19:14:08 +0800", "snippet": "在dotnet中使用oracle客户端访问oracle数据库提示Oracle.DataAccess版本不匹配。问题在dotnet中使用oracle客户端访问oracle数据库提示Oracle.DataAccess版本不匹配。环境说明： 接手的电脑已经装过oracle客户端（Oracle.DataAccess版本是2.112.3.0） 新接手的项目使用的是Oracle.DataAccess版本是2.112.1.0然后按照网上搜的各种卸载安装，还是报错。解决 拉取项目代码，运行报错，提示Oracle.DataAccess版本不匹配，这时并不知道已经电脑已经安装Oracle.DataAccess-2.112.3.0。 直接安装2.112.1.0版本Oracle客户端（先装32位，再装64位），仍然报错 查看C:\\Windows\\assembly发现有两个版本的Oracle.DataAccess（2.112.3.0和2.112.1.0），右键卸载2.112.3.0，提示无法卸载 网络搜索卸载oracle，这其中反复卸载安装oracle客户端N次。问题依旧，卸载不掉2.112.3.0。 最终还是找到了C:\\Windows\\assembly\\Oracle.DataAccess的卸载方法,以管理员身份打开Visual Studio的开发人员命令提示符，输入gacutil /u &quot;Oracle.DataAccess,Version=2.112.3.0, Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a 卸载之后，再运行项目，提示信息不再是版本冲突，而是找不到程序集了，说明引用的仍然是2.112.3.0 在vs异常管理界面，开启全部异常，这次终于获得了一条非常重要的信息。在C:\\Windows\\assembly\\GAC_64\\Policy.2.112.Oracle.DataAccess\\2.112.3.0__89b483f429c47342\\Policy.2.112.Oracle.DataAccess.config中重定向的2.112.3.0版本Oracle.DataAccess不存在。 打开C:\\Windows\\assembly\\GAC_64\\Policy.2.112.Oracle.DataAccess\\2.112.3.0__89b483f429c47342\\Policy.2.112.Oracle.DataAccess.config，看到配置中的newVersion=”2.112.3.0”，所以不管你怎么卸载安装，最终都会指向2.112.3.0，就算2.112.3.0不存在了也只会报错。 复制Policy.2.112.Oracle.DataAccess.config，修改newVersion=”2.112.1.0”，再覆盖回去，因为这个文件无法直接编辑保存，只能先复制出来再覆盖回去。 运行项目，成功！原因C:\\Windows\\assembly\\GAC_64\\Policy.2.112.Oracle.DataAccess\\2.112.3.0__89b483f429c47342\\Policy.2.112.Oracle.DataAccess.config中配置了指向的dll版本，所以无论怎么卸载、安装都没用。oracle卸载删除注册表脚本Windows Registry Editor Version 5.00 [-HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE\\ODP.NET] [-HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\StartMenu\\Programs\\Oracle - OraClient11g_home1] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\services\\eventlog\\Application\\Oracle.VSSWriter.CD] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\OracleServices for MTS] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\Oracle.portal] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\OracleDBConsoleportal] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\services\\OracleDBConsoleorcl] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\services\\eventlog\\Application\\Oracle.VSSWriter.CD] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\OracleServices for MTS] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\Oracle.portal] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\OracleDBConsoleportal] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\services\\eventlog\\Application\\Oracle.cd] [-HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\services\\OracleDBConsoleorcl] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Oracle11] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Oracle11\\Performance] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Oracle11\\Performance\\KEY_OraDb11g_home1] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsolemain] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsolemain\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsolemain\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsoleoracl] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsoleoracl\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleDBConsoleoracl\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleJobSchedulerMAIN] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleJobSchedulerMAIN\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleJobSchedulerORACL] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleJobSchedulerORACL\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleMTSRecoveryService] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleMTSRecoveryService\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleMTSRecoveryService\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleOraDb11g_home1ClrAgent] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleOraDb11g_home1ClrAgent\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleOraDb11g_home1TNSListener] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleOraDb11g_home1TNSListener\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleOraDb11g_home1TNSListener\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleRemExecService] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleRemExecService\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleRemExecService\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceMAIN] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceMAIN\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceMAIN\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceORACL] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceORACL\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleServiceORACL\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterMAIN] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterMAIN\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterMAIN\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterORACL] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterORACL\\Security] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OracleVssWriterORACL\\Enum] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\OracleServices for MTS] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\Oracle.main] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\Oracle.oracl] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\Oracle.VSSWriter.MAIN] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\Oracle.VSSWriter.ORACL] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\OracleDBConsolemain] [-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\OracleDBConsoleoracl] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLMMC.About] [-HKEY_CLASSES_ROOT\\ORCLMMC.About\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLMMC.About.1] [-HKEY_CLASSES_ROOT\\ORCLMMC.About.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\OracleConfig.OracleConfig] [-HKEY_CLASSES_ROOT\\OracleConfig.OracleConfig\\CurVer] [-HKEY_CLASSES_ROOT\\OracleConfig.OracleConfig.1] [-HKEY_CLASSES_ROOT\\OracleConfig.OracleConfig.1\\CLSID] [-HKEY_CLASSES_ROOT\\OracleDatabase.OracleDatabase] [-HKEY_CLASSES_ROOT\\OracleDatabase.OracleDatabase\\CurVer] [-HKEY_CLASSES_ROOT\\OracleDatabase.OracleDatabase.1] [-HKEY_CLASSES_ROOT\\OracleDatabase.OracleDatabase.1\\CLSID] [-HKEY_CLASSES_ROOT\\OracleHome.OracleHome] [-HKEY_CLASSES_ROOT\\OracleHome.OracleHome\\CurVer] [-HKEY_CLASSES_ROOT\\OracleHome.OracleHome.1] [-HKEY_CLASSES_ROOT\\OracleHome.OracleHome.1\\CLSID] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraServer] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraServer\\CLSID] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraServer\\CurVer] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraServer.5] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraServer.5\\CLSID] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraSession] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraSession\\CLSID] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraSession\\CurVer] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraSession.5] [-HKEY_CLASSES_ROOT\\OracleInProcServer.XOraSession.5\\CLSID] [-HKEY_CLASSES_ROOT\\OracleProcess.OracleProcess] [-HKEY_CLASSES_ROOT\\OracleProcess.OracleProcess\\CurVer] [-HKEY_CLASSES_ROOT\\OracleProcess.OracleProcess.1] [-HKEY_CLASSES_ROOT\\OracleProcess.OracleProcess.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORADC.ORADCCtrl.1] [-HKEY_CLASSES_ROOT\\ORADC.ORADCCtrl.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORAMMCCFG11.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORAMMCPMON11.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\OraOLEDB.ErrorLookup] [-HKEY_CLASSES_ROOT\\OraOLEDB.ErrorLookup\\CLSID] [-HKEY_CLASSES_ROOT\\OraOLEDB.ErrorLookup\\CurVer] [-HKEY_CLASSES_ROOT\\OraOLEDB.ErrorLookup.1] [-HKEY_CLASSES_ROOT\\OraOLEDB.ErrorLookup.1\\CLSID] [-HKEY_CLASSES_ROOT\\OraOLEDB.Oracle] [-HKEY_CLASSES_ROOT\\OraOLEDB.Oracle\\CLSID] [-HKEY_CLASSES_ROOT\\OraOLEDB.Oracle\\CurVer] [-HKEY_CLASSES_ROOT\\OraOLEDB.Oracle.1] [-HKEY_CLASSES_ROOT\\OraOLEDB.Oracle.1\\CLSID] [-HKEY_CLASSES_ROOT\\OraPerfMon.OraPerfMon] [-HKEY_CLASSES_ROOT\\OraPerfMon.OraPerfMon\\CurVer] [-HKEY_CLASSES_ROOT\\OraPerfMon.OraPerfMon.1] [-HKEY_CLASSES_ROOT\\OraPerfMon.OraPerfMon.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLMMC.About] [-HKEY_CLASSES_ROOT\\ORCLMMC.About\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLMMC.About.1] [-HKEY_CLASSES_ROOT\\ORCLMMC.About.1\\CLSID] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData\\CurVer] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData.1] [-HKEY_CLASSES_ROOT\\ORCLSSO.ComponentData.1\\CLSID] [-HKEY_CLASSES_ROOT\\EnumOraHomes.EnumOraHomes] [-HKEY_CLASSES_ROOT\\EnumOraHomes.EnumOraHomes\\CurVer] [-HKEY_CLASSES_ROOT\\EnumOraHomes.EnumOraHomes.1] [-HKEY_CLASSES_ROOT\\EnumOraHomes.EnumOraHomes.1\\CLSID]参考资料 项目篇–win10卸载C:\\Windows\\assembly下的程序集 完全卸载Oracle方法(超详细) oracle卸载删除注册表脚本" }, { "title": "不手动重启iis更新dotnetcore网站", "url": "/post/%E4%B8%8D%E6%89%8B%E5%8A%A8%E9%87%8D%E5%90%AFiis%E6%9B%B4%E6%96%B0dotnetcore%E7%BD%91%E7%AB%99", "categories": "dotnet, core, windows, csharp, ftp, iis", "tags": "", "date": "2021-09-15 19:14:08 +0800", "snippet": "由于没有服务器权限，只有一个ftp目录权限，ftp上传网站文件后（虽然提示上传成功，但是找管理员手动重启iis后程序还是没更新，估计文件被占用应该是没上传成功的），网站程序还是以前的。步骤 先上传一个名字叫app_offline.htm的文件 再上传正式的网站程序文件 删除app_offline.htm总结：更新前在根目录下放个名字叫app_offline.htm的文件，更新完删掉。参考资料 解决ASP.NET Core部署到IIS，更新项目”另一个程序正在使用此文件，进程无法访问” App Offline file (app_offline.htm)" }, { "title": "达梦数据库常用语句范例(转)", "url": "/post/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E8%8C%83%E4%BE%8B", "categories": "dameng", "tags": "", "date": "2021-06-03 19:14:08 +0800", "snippet": "原文地址达梦数据库常用语句范例 by Crystane Dec 27,2019 创建表空间–创建初始大小为32M的表空间；create tablespace test datafile ‘/dm7/data/DAMENG/TEST1_01.DBF’ SIZE 32;–创建初始大小为50M的表空间，自动扩展，最大扩展到100M；create tablespace tbs1 datafile ‘/dm7/data/DAMENG/tbs1_02.dbf’ size 50 autoextend on maxsize 100 ;–创建初始大小为50M的表空间，自动扩展，最大扩展到100M，每次增加1M；create tablespace tbs3 datafile ‘/dm7/data/DAMENG/tbs3_02.dbf’ size 50 autoextend on next 1 maxsize 100 ; 查看表空间select * from dba_tablespaces;SYSTEM :数据字典和全局的系统数据。ROLL:存放了数据库运行过程中产生的回滚记录。UNDO_RETENTION:单位秒TEMP:临时表空间MAIN:数据库默认的表空间，创建数据对象时，如果不指定存储位置，默认存放在该表空间。HMAIN:HUGE表空间 增加表空间文件–一个表空间可以关联多个表空间文件；alter tablespace tbs2 add datafile ‘dm7/data/DAMNENG/tbs2_02.dbf’ size 50 autoextend on maxsize 100; 表空间更换存储位置或更换文件名–首先将表空间下线；alter tablespace tbs4 offline;–更改表空间存储位置或更换表空间名字；alter tablespace tbs4 rename datafile ‘/dm7/data/DAMENG/tbs4_02.dbf’ to ‘/dm7/data/tbs4_02.dbf’;–修改完成后将表空间上线；alter tablespace tbs4 online; 删除表空间drop tablespace tbs1; 创建用户–identifiled by 指定鉴定密码–limit password_life_time 指定最大生存时间（天）–failed_login_attemps 指定最大登陆失败次数–password_lock_time 指定锁定时间（分）；create user test1 identified by dameng123 limit password_life_time 60, failed_login_attemps 2, password_lock_time 5; 查看当前用户select user; 表字段注释COMMENT ON column TEST1.STU.ADDRESS IS ‘学员地址’; 查看所有用户select from dba_users;select from all_users; 创建表–CREATE TABLE SALESORDER_DETAIL EXAMPLECREATE TABLE SALES.SALESORDER_DETAIL(SALESORDERID INT NOT NULL REFERENCESSALES.SALESORDER_HEADER(SALESORDERID),SALESORDER_DETAILID INT NOT NULL,CARRIERNO VARCHAR(25) NOT NULL,PRODUCTID INT NOT NULL REFERENCES PRODUCTION.PRODUCT(PRODUCTID),ORDERQTY INT NOT NULL,LINETOTAL DEC(19,4) NOT NULL,PRIMARY KEY(SALESORDERID,SALESORDER_DETAILID)) STORAGE (ON BOOKSHOP); 插入数据–INSERT ADDRESS EXAMPLEINSERT INTO PERSON.ADDRESS(ADDRESS1,ADDRESS2,CITY,POSTALCODE) VALUES(‘洪山区 369 号金地太阳城 56-1-202’,’’,’武汉市洪山区’,’430073’); 查看表的表空间、所属者等信息；select * from dba_tables where table_name = ‘STU’;dba_tables表结构见管理员手册ORACLE兼容视图13节； 查询创建的表结构；select dbms_metadata.get_ddl(‘TABLE’,’STU’,’TEST2’);或sp_tabledef(‘TEST’,’STU’); 重命名表alter table test1.STU rename to STUDENT; 增加或删除列alter table test1.student add sfid varchar(18) ;alter table test1.student drop sfid; 表注释COMMENT ON TABLE “TEST1”.”STU” IS ‘xue yuan’; 删除表drop table test1.student; 查看用户所属的角色；select from dba_role_privs where grantee=’test’; 查询角色的权限select from dba_sys_privs where grantee=’PUBLIC’; 权限授予和收回 grant select on test.test_table to test1;grant select(city_id,city_name) on dmhr.city to test;REVOKE grant select on test.test_table to test1; 查看表的约束信息；select * from dba_constraints where table_name=’TEST3’;dba_constraints 表结构见管理员手册ORACLE兼容视图12节； 创建约束–检查约束create table test2.t8(id int check(id&amp;gt;=5));–唯一约束create table test2.T3 (id int unique);–主键约束create table test2.T5(id int primary key);–外键约束create table test2.t10(sid int primary key, pid int);create table test2.t11(id int primary key, sid int foreign key references test2.t10 (sid)); 禁用、启用约束alter table test.TEST3 disable constraint CONS134218845;alter table test.TEST3 enable constraint CONS134218845; 创建或更新、修改视图create view dmhr.employee_column_controlled asselect employee_name,salary from dmhr.employee;create view or replace dmhr.employee_column_controllas select employee_name,salary from dmhr.employee; 自增列；创建create sequence test.s1 —test为模式名start with 1 —序列的起始increment by 1 —自增多少maxvalue 5 —最大值nocache —-是否缓存nocycle; —是否循环应用：create table test.t12(id int primary key);insert into test.t12 values(test.s1.nextval);select test.s1.nextval;insert into test.t12 values(test.s1.nextval);insert into test.t12 values(test.s1.nextval);insert into test.t12 values(test.s1.nextval);select test.s1.nextval; –此语句会执行失败，序列溢出。表的数据是1,3,4,5.查询也会使用掉序列数据.修改alter sequence test.s1 maxvalue 10;查询select * from dba_sequences where sequence_name = ‘S1’;删除drop sequence test.s1; 同义词全局同义词create public synonym SY1 for dmhr.employee;SELECT * from dba_synonyms;select * from dba_synonyms where SYNONYM_NAME = ‘SY1’;drop public synonym SY1;局部同义词create synonym SY1 for dmhr.employee;SELECT * from dba_synonyms;select * from dba_synonyms where SYNONYM_NAME = ‘SY1’;drop synonym SY1; 索引select from dba_indexes;select from dba_indexes where table_name = ‘CITY’;create table test.emp as select * from dmhr.employee;create tablespace index1 datafile ‘/dm7/data/DAMENG/index01.dbf’ size 32;create index ind_emp on test.emp(employee_id) tablespace index1;select table_name,index_name from dba_indexes where table_name=’EMP’;EXPLAIN SELECT * FROM TEST.EMP WHERE EMPLOYEE_ID &amp;lt; 20;sp_create_system_packages(1);begindbms_stats.gather_table_stats(‘TEST’,’EMP’);end;alter index test.ind_emp rebuild;alter index test.ind_emp rebuild online;drop index test.ind_emp; 归档设置select * from v$database;–ARCH_MODE=N表示未开启归档，Y表示已开启归档alter database mount;alter database add archivelog ‘type=local,dest=/dm7/arch,file_size=64,space_limit=0’;alter database archivelog;alter database open; 备份和还原–全量备份backup database full backupset ‘/dm7/backup/full’;select checkpoint(0);–增量备份–with backupdir指定基目录backup database increment with backupdir ‘/dm7/backup/full’ backupset ‘/dm7/backup/incr’;–表空间还原restore tablespace tbs2 from backupset ‘/dm7/backup/full’;–逻辑备份./dexp sysdba/SYSDBA@localhost:5236 file=dexp01.dmp log=dexp01.log directory=/dm7/backup/dexp full=y–逻辑还原./dimp sysdba/SYSDBA@localhost:5236 file=/dm7/backup/dexp/dexp01.dmp log=dimp02.log directory=/dm7/backup/dexp作业管理–SYSJOBS:作业信息select from SYSJOB.SYSJOBS;–SYSJOBSCHEDULES:作业调度信息select from SYSJOB.SYSJOBSCHEDULES;–SYSJOBHISTORIES:作业历史信息select * from SYSJOB.SYSJOBHISTORIES;参考资料 https://blog.51cto.com/u_8760739/2462571" }, { "title": "中望CAD使用C++二次开发步骤", "url": "/post/%E4%B8%AD%E6%9C%9BCAD%E4%BD%BF%E7%94%A8C++%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4", "categories": "windows, c++, zwcad", "tags": "", "date": "2021-03-23 19:14:08 +0800", "snippet": "使用c++在中望CAD二次开发步骤安装SDK安装最新版本的中望CAD二次开发SDK，我这里安装的是最新的2021版，对应的vs是2017版，2019也是可以用，只是没有项目模板注意安装路径一定不能有中文，否则后面引用会出错或者需要全部手动引用安装项目模板SDK安装完成之后会自动弹出安装项目模板的窗口，如果你没有弹出可以在你上一步选择的安装目录中找到ZWCAD_2021_ZRXSDK\\Tools\\ZRXWizard\\ZRXWizardSetup.exe手动安装这里的目录就是SDK的安装目录，默认选择就是对的，如果不对请手动选择一下点击install安装创建项目vs2017如果你是vs2017，到这里就可以了，在创建项目界面选择创建cad项目了vs2019 创建动态链接库项目 修改项目文件，以便可以找到到中望CAD的库和头文件，不然就要手动引用很麻烦在你的项目目录找到项目文件xxx.vcxproj，xxx为项目名称，用记事本打开，找到如下代码的位置 &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|Win32&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|Win32&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|x64&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|x64&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt;注意Label内容，否则可能找到另一个节点。把以上4个节点换成如下代码 &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|Win32&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\zrx2021.props&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|Win32&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\zrx2021.props&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|x64&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\zrx2021.props&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt; &amp;lt;ImportGroup Label=&quot;PropertySheets&quot; Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|x64&#39;&quot;&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot; Condition=&quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot; Label=&quot;LocalAppDataPlatform&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(UserRootDir)\\zrx2021.props&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt;主要就是引入zrx2021.props配置，这个文件中保存了中望CAD的库文件和头文件位置。这个文件在我的电脑上路径是C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\MSBuild\\v4.0\\zrx2021.props，Administrator是我的用户名，请换成你自己的用户名。 引入CAD头文件打开pch.h文件，修改如下：// pch.h: 这是预编译标头文件。// 下方列出的文件仅编译一次，提高了将来生成的生成性能。// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。#ifndef PCH_H#define PCH_H// 添加要在此处预编译的标头#include &quot;framework.h&quot;//引入头文件#include &quot;accmd.h&quot;#include &quot;AcString.h&quot;#include &quot;gepnt3d.h&quot;#include &quot;geassign.h&quot;#include &quot;dbents.h&quot;#include &quot;dbmain.h&quot;#include &quot;acdocman.h&quot;#include &quot;acarray.h&quot;#include &quot;adscodes.h&quot;#endif //PCH_H 添加CAD入口文件新增一个cpp类文件，代码如下#include &quot;pch.h&quot;#include &quot;tchar.h&quot;#include &amp;lt;aced.h&amp;gt;#include &amp;lt;rxregsvc.h&amp;gt;void helloWorld(){ acutPrintf(_T(&quot;\\nHello World!&quot;));}void helloWorld2(){ acutPrintf(_T(&quot;\\nHello World2!&quot;));}void initApp(){ // register a command with the AutoCAD command mechanism acedRegCmds-&amp;gt;addCommand(_T(&quot;HELLOWORLD_COMMANDS&quot;), _T(&quot;Hello&quot;), _T(&quot;Hello&quot;), ACRX_CMD_TRANSPARENT, helloWorld); acedRegCmds-&amp;gt;addCommand(_T(&quot;HELLOWORLD_COMMANDS&quot;), _T(&quot;Hello2&quot;), _T(&quot;Hello2&quot;), ACRX_CMD_TRANSPARENT, helloWorld2);}void unloadApp(){ acedRegCmds-&amp;gt;removeGroup(_T(&quot;HELLOWORLD_COMMANDS&quot;));}extern &quot;C&quot; AcRx::AppRetCodezcrxEntryPoint(AcRx::AppMsgCode msg, void* pkt){ switch (msg) { case AcRx::kInitAppMsg: acrxDynamicLinker-&amp;gt;unlockApplication(pkt); acrxRegisterAppMDIAware(pkt); initApp(); break; case AcRx::kUnloadAppMsg: unloadApp(); break; default: break; } return AcRx::kRetOK;}#ifdef _WIN64#pragma comment(linker, &quot;/export:zcrxEntryPoint,PRIVATE&quot;)#pragma comment(linker, &quot;/export:zcrxGetApiVersion,PRIVATE&quot;)#else // WIN32#pragma comment(linker, &quot;/export:_zcrxEntryPoint,PRIVATE&quot;)#pragma comment(linker, &quot;/export:_zcrxGetApiVersion,PRIVATE&quot;)#endif编译注意编译的版本要和中望cad版本一致，也就是中望cad是32位的就要编译成32位的程序，中望cad是64位的就要编译成64位的程序，编译之后在项目目录\\Out\\bin中找到对应版本的程序在中望cad中加载参考资料 中望CAD二次开发环境配置及使用" }, { "title": "VS2019配置Qt开发", "url": "/post/VS2019%E9%85%8D%E7%BD%AEQt%E5%BC%80%E5%8F%91", "categories": "Qt, Visual, Studio, 2019, windows, C++", "tags": "", "date": "2021-03-01 19:14:08 +0800", "snippet": "用惯了宇宙第一IED，不太习惯Qt Creator，决定在VS2019上试试Qt开发。安装vs略安装qt 先下载qt，这里推荐到国内镜像下载，官网太慢了。这里给大家推荐几个国内著名的 Qt 镜像网站，主要是各个高校的：中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/北京理工大学：http://mirror.bit.edu.cn/qtproject/中国互联网络信息中心：https://mirrors.cnnic.cn/qt/选择一个自己喜欢的版本，下载对应系统的安装包安装。windows平台的安装可以参照图解Qt安装（Windows平台）补充一下，一定要选择msvc2017 64-bit，如果没有也要选择msvc2017 32-bit。这里可能没有2019的，选择2017也没关系。vs安装qt插件 打开vs2019扩展管理 搜索qt我这是已经安装过了，没有安装过到联机标签下搜索安装。如果下载不了也可以区qt官网下载。下载地址 配置Qt安装目录位置安装完成之后需要配置Qt环境才能创建Qt项目和编译 打开配置界面添加qt环境位置，我这里已经添加过，所以看到有些项目不能编辑，版本名称可以随意取，主要是系统和安装目录位置不能选错。配置好之后重启vs，再次创建项目应该就能选择Qt项目了错误处理 MSB8020 无法找到 Visual Studio 2017 的生成工具(平台工具集 =v141)...请右键项目，打开属性把生成工具改成2019 导入ui头文件提示找不到文件ui_******.h请右键项目，修改vc++包含的目录，把临时生成ui头文件的目录添加进来添加进来之后，选择ui文件，右键单击选择编译，就可以正常找到了。 找不到头文件如果提示找不到qt的头文件，则需要把qt目录也加到vc++包含的目录无法打开 源 文件 QtWidgets/QApplication 参考资料 图解Qt安装（Windows平台） VS2019搭建Qt开发环境" }, { "title": ".NET多项目统一设置条件编译", "url": "/post/.NET%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E8%AE%BE%E7%BD%AE%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91", "categories": "dotnet, csharp", "tags": "", "date": "2021-02-05 19:14:08 +0800", "snippet": "我有一个项目需要引用其他两个类似的项目，根据编译条件分别使用其中一个项目。简单情况下只需要在这个项目添加一个条件编译就行了，但是有几个项目都要这样引用，每次要改几个项目，偶尔忘了改其中一个还会报错。问题如上所述。解决这样就可以用到解决方案原因正在探索……参考资料 wpf - Custom dwm drawn window frame flickers on resizing if the window contains a HwndHost element - Stack Overflow Roslyn 使用 Directory.Build.props 管理多个项目配置 .NET/C# 项目如何优雅地设置条件编译符号？" }, { "title": "github下载指定文件或文件夹", "url": "/post/github%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9", "categories": "Visual, Studio, dotnet, csharp", "tags": "", "date": "2020-12-10 19:14:08 +0800", "snippet": "有时候需要下载GitHub上的代码，但是GitHub仓库又很大，而只需要其中一部分，尤其是那种很多项目放在一个仓库的，这时候就需要能下载指定文件夹或文件你可以把要下载的文件夹地址复制到下面网址生成下载包，然后就可以下载了http://zhoudaxiaa.gitee.io/downgit/#/home参考资料 github下载单个文件夹" }, { "title": "临时替换上下文", "url": "/post/%E4%B8%B4%E6%97%B6%E6%9B%BF%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87", "categories": "Visual, Studio, dotnet, csharp", "tags": "", "date": "2020-12-02 19:14:08 +0800", "snippet": "今天在看Abp源码的时候偶然看到一段临时修改当前上下文语言的的方式，我想是不是其他的地方也可以这样，比如在多租户系统，临时要用到超级权限不使用租户模式，怎么快速切换当前上下文，使用完又改回去。代码如下/// &amp;lt;summary&amp;gt;/// This class can be used to provide an action when/// Dipose method is called./// &amp;lt;/summary&amp;gt;public class DisposeAction : IDisposable{ private readonly Action _action; /// &amp;lt;summary&amp;gt; /// Creates a new &amp;lt;see cref=&quot;DisposeAction&quot;/&amp;gt; object. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;action&quot;&amp;gt;Action to be executed when this object is disposed.&amp;lt;/param&amp;gt; public DisposeAction([NotNull] Action action) { Check.NotNull(action, nameof(action)); _action = action; } public void Dispose() { _action(); }}public static class CultureHelper{ public static IDisposable Use([NotNull] string culture, string uiCulture = null) { Check.NotNull(culture, nameof(culture)); return Use(new CultureInfo(culture), uiCulture == null ? null : new CultureInfo(uiCulture)); } public static IDisposable Use([NotNull] CultureInfo culture, CultureInfo uiCulture = null) { Check.NotNull(culture, nameof(culture)); var currentCulture = CultureInfo.CurrentCulture; var currentUiCulture = CultureInfo.CurrentUICulture; CultureInfo.CurrentCulture = culture; CultureInfo.CurrentUICulture = uiCulture ?? culture; return new DisposeAction(() =&amp;gt; { CultureInfo.CurrentCulture = currentCulture; CultureInfo.CurrentUICulture = currentUiCulture; }); }}就可以用using(var ci=CultureHelper.Use(xxx)){ //修改了上下文的语言环境}//自动恢复语言环境，这样就避免了手动还原语言环境" }, { "title": "Visual Studio 调试技巧之即时窗口的妙用(转载)", "url": "/post/Visual-Studio-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%8D%B3%E6%97%B6%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A6%99%E7%94%A8(%E8%BD%AC%E8%BD%BD)", "categories": "Visual, Studio, dotnet, csharp", "tags": "", "date": "2020-12-02 19:14:08 +0800", "snippet": "原文链接在 Visual Studio 中有一个窗口叫 Immediate 窗口，中文版本应该叫即时窗口。默认会在你启动调试时在 VS 编辑器中弹出来。你也可以通过 Debug | Windows | Immediate 或者使用快捷键 Ctrl+Alt+I 手动把它调出来。 在 Visual Studio 中有一个窗口叫 Immediate 窗口，中文版本应该叫即时窗口。默认会在你启动调试时在 VS 编辑器中弹出来。你也可以通过 Debug Windows Immediate 或者使用快捷键 Ctrl+Alt+I 手动把它调出来。 这个窗口很实用，尤其是在调试的时候。下面总结几个即时窗口的实用技巧。 临时运行C#代码有时候你可能只想知道一句C#代码运行的结果，比如你突然想知道一个空数组调用Sum()方法会不会报错，或者想查看一下Math.PI的值。你不用傻傻地把测试代码写在项目里，设个断点，然后把项目跑起来查看。你可以在即时窗口中直接写C#代码，然后按回车即可。比如输入：Console.WriteLine(“Welcome!”)回车运行：再如，你可以直接输入 Math.PI 等表达式和调用某些方法： 也可以用 VS 的另外一个窗口 View Other Windows C# Interactive 来实现个功能。如果只是为了临时运行 C# 代码块，则C# Interactive 会更好用些。两者使用有些区别，C# Interactive 打印内容需要手动调用 Console.Write 等方法： 调试时调用任何方法假如你正在调试一个方法，你临时测试一下这个方法对于不同的参数的执行过程或运行结果。比如对于这样一段代码：class Program{ static void Main(string[] args) { var foo = new Foo(); var result = foo.Add(1, 2, 3); Console.WriteLine(result); }}public class Foo{ public int Add(params int[] nums) { if (nums?.Length &amp;lt; 1) return 0; var result = 0; foreach (var n in nums) { // …（其它代码） result += n; } return result; }}若想用不同的参数来测试foo.Add方法的运行情况，普通的做法是启动多次调试，每次调试都修改一下调用代码 foo.Add 的参数。使用即时窗口，你可以在方法调用处打个断点。然后在即时窗口编写调用代码，它会直接使用当前上下文进行调试。不需要中断 VS 调试再重新启动。另外，在即时窗口可以调用私有方法，也就是说它不受方法的访问权限限制。不过，在即时窗口编写调用私有方法的代码时是没有智能提示的。 使方法执行不影响上下文默认情况下，在即时窗口运行的代码，执行完后会对上下文产生副作用（Side Effect）。比如对于这样一段代码：class Program{ static void Main(string[] args) { var foo = new Foo(); Console.WriteLine(); }}public class Foo{ public int Num { get; private set; } public int Increase() { return ++Num; }}在即时窗口中调用foo.Increase后，Num 的变化如下：但很多时候我们只希望即使窗口只是临时运行一下调试代码，不想让它真修改上下文的状态。我们只需在表达式后面添加 , nse（no side effect 的简写）即可：加上 nse 后，执行的那句代码相当于在一个沙箱中运行，和上下文互不干扰。 访问特殊变量Visual Studio 在调试过程中有一些特殊的变量，可以在即时窗口打印它们的值。这些特殊的变量以 $ 作为前缀，通过智能提示可以看到目前有三个这样的特殊变量：$exception，当前的异常信息。有时候在调试时，你代码的 try/catch 语句没有给 catch 语句使用 Exception 参数，则可以在即使窗口使用该特殊变量打印异常信息。$returnvalue，当前语句的返回值。有时候你在代码中调用了一个方法，但你并没有用一个变量来存储这个方法的返回值，而你在调试时又想知道它的返回值。此时你可以在方法执行处添加一个断点。当运行到该断点时，按 F10，然后在即时窗口可以通过 $returnvalue 打印该方法的返回值。$user，可以用来获取当前登录操作系统的用户信息和当前运行的进程和线程信息。这个我也没用过，官方文档介绍也比较简单，也不知道这个特殊变量包含哪些成员。直接打印是这样的：结束本文分享的这几个即时窗口的技巧，在调试时很实用，在工作中我经常使用，希望它也可以帮助你提高开发效率。关于调试，VS 还有其它好用的工具或技巧，比如有一个 Watch（监视）窗口，如果调试时要频繁查看一个对象的值，使用监视窗口比即时窗口方便很多。当然，还是希望大家自己去探索更多的技巧，以做到能更高效灵活地使用 VS 这个强大的编辑器。作者：精致码农出处：http://cnblogs.com/willick联系：liam.wang@live.com本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。如有问题或建议，请多多赐教，非常感谢。" }, { "title": "Asp.net core上传文件大小限制", "url": "/post/Asp.net-core%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6", "categories": "asp.net, core, dotnet, csharp", "tags": "", "date": "2020-11-27 19:14:08 +0800", "snippet": "如果你正在使用asp.net core接收上传文件，如果上传的文件超过了30mb，那么多半会遇到上传不了的问题。你需要按以下几种方式添加配置对于在 IIS 上运行的应用程序（含IIS Express）在web.config中添加如下配置&amp;lt;system.webServer&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestFiltering&amp;gt; &amp;lt;!-- Handle requests up to 1 GB --&amp;gt; &amp;lt;requestLimits maxAllowedContentLength=&quot;1073741824&quot; /&amp;gt; &amp;lt;/requestFiltering&amp;gt; &amp;lt;/security&amp;gt;&amp;lt;/system.webServer&amp;gt;在 Kestrel 上运行的应用程序在Startup文件的ConfigureServices方法中添加services.Configure&amp;lt;KestrelServerOptions&amp;gt;(options =&amp;gt;{ options.Limits.MaxRequestBodySize = int.MaxValue; // if don&#39;t set default value is: 30 MB});如果是使用IFormFile参数接收文件以上配置就够了使用Request.Form.Files接收文件配置（未验证）services.Configure&amp;lt;FormOptions&amp;gt;(x =&amp;gt;{ x.ValueLengthLimit = int.MaxValue; x.MultipartBodyLengthLimit = int.MaxValue; // if don&#39;t set default value is: 128 MB x.MultipartHeadersLengthLimit = int.MaxValue;});参考资料 BadHttpRequestException: Request body too large. #20369" }, { "title": "HttpClient上传文件", "url": "/post/HttpClient%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6", "categories": "httpclient, dotnet, csharp", "tags": "", "date": "2020-11-21 19:14:08 +0800", "snippet": "有时候需要使用hpptclient来上传文件，以前不会，这里记录以下代码var client = _httpClientFactory.CreateClient();var filePath=&quot;c:\\\\1.txt&quot;;var fileName = Path.GetFileName(filePath);var content = new MultipartFormDataContent();content.Add(new ByteArrayContent(System.IO.File.ReadAllBytes(filePath)), &quot;file&quot;, fileName);var resultContent = await (await client.PostAsync(&quot;http://www.123.com/upfile&quot;, content)).Content.ReadAsStringAsync();_httpClientFactory是依赖注入的，需要添加依赖注册services.AddHttpClient();参考资料 C#使用HttpClient上传文件并附带其他参数" }, { "title": "Asp.net core 发布到iis的Development环境", "url": "/post/Asp.net-core-%E5%8F%91%E5%B8%83%E5%88%B0iis%E7%9A%84Development%E7%8E%AF%E5%A2%83", "categories": "dotnet, csharp, asp.net, core", "tags": "", "date": "2020-11-18 19:14:08 +0800", "snippet": "asp.net core 发布时默认都是Production，有时候我们有些配置是只有在Development模式才会启用，但是有需要发布出来，怎么办呢。改一下web.config文件就可以了代码&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;location path=&quot;.&quot; inheritInChildApplications=&quot;false&quot;&amp;gt; &amp;lt;system.webServer&amp;gt; &amp;lt;handlers&amp;gt; &amp;lt;add name=&quot;aspNetCore&quot; path=&quot;*&quot; verb=&quot;*&quot; modules=&quot;AspNetCoreModuleV2&quot; resourceType=&quot;Unspecified&quot; /&amp;gt; &amp;lt;/handlers&amp;gt;-- &amp;lt;aspNetCore processPath=&quot;dotnet&quot; arguments=&quot;.\\GD.SurveyDrawCG.ServicesHost.dll&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\\logs\\stdout&quot; hostingModel=&quot;InProcess&quot; /&amp;gt;++ &amp;lt;aspNetCore processPath=&quot;dotnet&quot; arguments=&quot;.\\ServicesHost.dll&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\\logs\\stdout&quot;&amp;gt;++ &amp;lt;environmentVariables&amp;gt;++ &amp;lt;environmentVariable name=&quot;ASPNETCORE_ENVIRONMENT&quot; value=&quot;Development&quot; /&amp;gt;++ &amp;lt;/environmentVariables&amp;gt;++ &amp;lt;/aspNetCore&amp;gt; &amp;lt;/system.webServer&amp;gt; &amp;lt;/location&amp;gt;&amp;lt;/configuration&amp;gt;如果你发布的应用（asp.net core 2.2）在IIS托管下报以下错误：An error occurred while starting the application..NET Core 4.6.27110.04 X86 v4.0.0.0 | Microsoft.AspNetCore.Hosting version 2.2.0-rtm-35687 | Microsoft Windows 10.0.19041 | Need help?那你需要在web.config中去掉InProcess-- &amp;lt;aspNetCore processPath=&quot;dotnet&quot; arguments=&quot;.\\GD.SurveyDrawCG.ServicesHost.dll&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\\logs\\stdout&quot; hostingModel=&quot;InProcess&quot; /&amp;gt;++ &amp;lt;aspNetCore processPath=&quot;dotnet&quot; arguments=&quot;.\\GD.SurveyDrawCG.ServicesHost.dll&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\\logs\\stdout&quot; /&amp;gt;" }, { "title": "类型转换", "url": "/post/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2", "categories": "dotnet, csharp", "tags": "", "date": "2020-11-16 19:14:08 +0800", "snippet": "部分类型没有不能进行隐式类型转换，在反射通过属性的SetValue方法赋值时就会报错，比如int32和float?，把int32的值赋值给float?属性就会报错。这里进行一次类型转换，这样就可以了。代码/// &amp;lt;summary&amp;gt;/// 泛型类型转换/// &amp;lt;/summary&amp;gt;/// &amp;lt;typeparam name=&quot;type&quot;&amp;gt;要转换的基础类型&amp;lt;/typeparam&amp;gt;/// &amp;lt;param name=&quot;val&quot;&amp;gt;要转换的值&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;public static object ConvertType(Type type, object val){ //泛型Nullable判断，取其中的类型 if (type.IsGenericType) { type = type.GetGenericArguments()[0]; } //string直接返回转换 if (type.Name.ToLower() == &quot;string&quot;) { return val+&quot;&quot;; } //反射获取TryParse方法 var tryParse = type.GetMethod(&quot;TryParse&quot;, BindingFlags.Public | BindingFlags.Static, Type.DefaultBinder, new Type[] { typeof(string), type.MakeByRefType() }, new ParameterModifier[] { new ParameterModifier(2) }); var parameters = new object[] { val + &quot;&quot;, Activator.CreateInstance(type) }; var success = (bool?)tryParse?.Invoke(null, parameters); //成功返回转换后的值，否则返回原值 return success == true ? parameters[1] : val;}使用表达式树生成 /// &amp;lt;summary&amp;gt; /// DataTable生成实体 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;dataTable&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static IEnumerable&amp;lt;T&amp;gt; ToList&amp;lt;T&amp;gt;(this DataTable dataTable) where T : class, new() { if (dataTable == null) throw new ArgumentNullException(nameof(dataTable)); List&amp;lt;T&amp;gt; collection = new List&amp;lt;T&amp;gt;(dataTable.Rows.Count); if (dataTable.Rows.Count == 0) { return collection; } Func&amp;lt;DataRow, T&amp;gt; func = ToExpression&amp;lt;T&amp;gt;(dataTable.Rows[0]); foreach (DataRow dr in dataTable.Rows) { collection.Add(func(dr)); } return collection; } /// &amp;lt;summary&amp;gt; /// 生成表达式 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;dataRow&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Func&amp;lt;DataRow, T&amp;gt; ToExpression&amp;lt;T&amp;gt;(DataRow dataRow) where T : class, new() { if (dataRow == null) throw new ArgumentNullException(&quot;dataRow&quot;, &quot;当前对象为null 无法转换成实体&quot;); ParameterExpression paramter = Expression.Parameter(typeof(DataRow), &quot;dr&quot;); List&amp;lt;MemberBinding&amp;gt; binds = new List&amp;lt;MemberBinding&amp;gt;(); for (int i = 0; i &amp;lt; dataRow.ItemArray.Length; i++) { String colName = dataRow.Table.Columns[i].ColumnName; PropertyInfo pInfo = typeof(T).GetProperty(colName); if (pInfo == null) continue; MethodInfo mInfo = typeof(DataRowExtensions) .GetMethod(&quot;Field&quot;, new Type[] { typeof(DataRow), typeof(String) } ) .MakeGenericMethod(pInfo.PropertyType); MethodCallExpression call = Expression.Call(mInfo, paramter, Expression.Constant(colName, typeof(String))); var block = Expression.Block(call); // if ( // pInfo.PropertyType.Name != dataRow.Table.Columns[i].DataType.Name // &amp;amp;&amp;amp; pInfo.PropertyType.GetGenericArguments()[0].Name != dataRow.Table.Columns[i].DataType.Name // ) // { // var toString = dataRow.Table.Columns[i].DataType.GetMethod(&quot;ToString&quot;, new Type[] { }); // var toStringEx = Expression.Call(call, toString); // var tp = pInfo.PropertyType.IsGenericType ? pInfo.PropertyType.GetGenericArguments()[0] : pInfo.PropertyType; // MethodInfo tryParse = tp // .GetMethod(&quot;TryParse&quot;, BindingFlags.Public | BindingFlags.Static, Type.DefaultBinder, // new Type[] { typeof(string), tp.MakeByRefType() }, // new ParameterModifier[] { new ParameterModifier(2) }); // ParameterExpression result = Expression.Parameter(typeof(DataRow), &quot;result&quot;); // var tryParseEx = Expression.Call(tryParse, toStringEx, result); // block = Expression.Block(tryParseEx); // } MemberAssignment bind = Expression.Bind(pInfo, block); binds.Add(bind); } MemberInitExpression init = Expression.MemberInit(Expression.New(typeof(T)), binds.ToArray()); return Expression.Lambda&amp;lt;Func&amp;lt;DataRow, T&amp;gt;&amp;gt;(init, paramter).Compile(); }" }, { "title": "机器学习数据", "url": "/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE", "categories": "ML.NET, CSharp", "tags": "", "date": "2020-10-28 19:14:08 +0800", "snippet": "机器学习训练数据源Kaggle数据集网址:http://www.kaggle.com/datasetsUCI机器学习库网址:https://archive.ics.uci.edu/ml/datasets.html微软数据集网址:https://msropendata.com亚马逊数据集网址:https://registry.opendata.awsAwesome公共数据集网址:https://github.com/awesomedata/awesome-public-datasets" }, { "title": "AutoCAD自定义线型实现斜坡线", "url": "/post/AutoCAD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%9C%E5%9D%A1%E7%BA%BF", "categories": "AutoCAD", "tags": "", "date": "2020-10-23 03:14:08 +0800", "snippet": "需要在CAD中实现自定义的线型来绘制斜坡线，如下：如果不实现线型，就只能复制或者偏移，很麻烦。定义线型找到CAD的线型定义文件，也可以直接创建一个文本文件，把后缀名改成.lin，复制以下内容到文本文件中：*WJGXP,未加固斜坡A,2,[TRACK1,LTYPESHP,S=0.25,R=0,X=0,Y=-0.25],2,[TRACK1,LTYPESHP,S=1,R=0,X=0,Y=-1],0.00000000001*YJGXP,已加固斜坡A,2,[10,AAA.SHX,S=0.5],2,[TRACK1,LTYPESHP,S=1,R=0,X=0,Y=-1],0.00000000001格式说明固定格式两行：第一行：*WJGXP为线型名称。导入CAD以后也是根据这个名称来选择。逗号后面“未加固斜坡”是线型的描述，可以任意编辑。第二行：描述的是线型具体怎么画。每一个描述信息用逗号分隔。A : 固定开头格式。.数字 ： 指定长度的线段”-“ : 表示抬笔，显示为空白0 : 代表小点[] : 代表一个描述信息对象，中间需要编辑内容，各种对象可以组合使用。对象种类CIRC1 : 代表小圆圈BOX : 代表小方块TRACK1 : 代表竖线轨道BAT : 代表套子ZIG : 代表Z形弯角”” : 中间的文本内容显示到线上ltypeshp.shx ： 字体STANDARD : 字型S——比例X : 水平偏移Y : 垂直偏移R : 倾斜角度U : 字的倾斜角度字体说明[10,AAA.SHX,S=0.5]10表示这个字体中文文字顺序或编号，可以找一个shx字体文件查看器查看。字体说明.dwg字体查看器.rar自己制作shx字体 按装express工具 绘制要制作成字体的图形 在express菜单面板中选择makeshape 选择shx文件保存的路径 输入默认分辨率，这里直接回车确定，选择默认的128 指定插入点。这里选择了图形树的中心，当然坐标位置也可以自己输入。 选择对象，我框选了整个图形。 完成后可以在第4步选择的文件夹下看到两个文件，tree.shx和tree.shp。把tree.shx复制到“C:\\Program Files\\Autodesk\\AutoCAD 2014\\Fonts”目录，这样CAD就可以直接找到字体，不用指定路径了。 在线型文件“C:\\Users\\Administrator\\AppData\\Roaming\\Autodesk\\AutoCAD 2014\\R19.1\\chs\\Support\\acadiso.lin”中添加一个线型引用这个字体*tree,树形A, 0, -1.6,[tree,tree.shx,s=1] 加载线型，使用参考资料 CAD中自定义.lin文件实现自定义线型" }, { "title": "使用GithubActions发布Vue网站到GithubPage", "url": "/post/%E4%BD%BF%E7%94%A8GithubActions%E5%8F%91%E5%B8%83Vue%E7%BD%91%E7%AB%99%E5%88%B0GithubPage", "categories": "Vue, GithubActions, GithubPage", "tags": "", "date": "2020-10-15 19:14:08 +0800", "snippet": "偶然看到一个介绍使用GitHubAction做的百度贴吧自动签到，然后一路顺藤摸瓜看到了阮一峰大神写的GitHub Actions 入门教程中介绍，示例中介绍了把React项目发布到GitHub Pages，我就想能不能把vue的项目发布到GitHub Pages呢(主要是不会React)。说干就干。创建vue项目这个不讲了用vue-cli一个命令就可以了。现在我已经创建了一个ts模板的项目（js项目是一样的），项目名称叫vue-github-actions-demo，结构如下。你们初始化的项目可能有些文件没有，如果是我后面添加发布流程文件我会讲到，如果是vue原生文件的差异不影响发布流程。创建配置文件从cli3开始取消了自动创建配置文件，这里需要手动创建配置文件，创建配置文件主要是因为我的githubPage主页，已经有一个网站了(https://dashenxian.github.io)，所以我只能用项目地址访问https://dashenxian.github.io/vue-github-actions-demo/，如果这里我不加这个二级目录，vue对js文件的文件引用就有问题。如果你想用你的githubPage主页访问，这一步骤可以跳过，但是需要把项目名称改成你的github用户名称。在根目录下创建vue.config.js文件，添加如下代码：//vue.config.jsmodule.exports = { // 选项... publicPath: process.env.NODE_ENV === &#39;production&#39; ? &#39;/vue-github-actions-demo/&#39; : &#39;/&#39; }创建workflow（工作流程）在根目录逐级创建.github\\workflows目录，在workflows下创建yml工作流程文件，文件名称可以随意，githubActions会执行全部的yml流程。输入以下代码：name: GitHub Actions Build and Deploy Demoon: push: branches: - masterjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions/checkout@v2.3.1 # If you&#39;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built. run: | #注意我这里是使用的yarn管理包，如果你使用的npm，请换成npm的命令：npm install和npm run build yarn yarn build - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@3.6.2 with: ACCESS_TOKEN: $ #secrets.ACCESS_TOKEN是项目配置的密钥 BRANCH: gh-pages # The branch the action should deploy to. FOLDER: dist # The folder the action should deploy. CLEAN: true # Automatically remove deleted files from the deploy branch推送项目到GitHub把项目代码推送到github，这里可以用vs打开项目文件夹，vs的团队管理中可以直接推送到github，当然你也可以选择其他方式，比如vscode或者命令。配置项目密钥现在你的项目已经推送到github，在GitHub中定位到项目 找到Settings配置，按下图步骤添加密钥，如果你还没有密钥，按第二步生成密钥后再添加。 没有密钥按下图步骤生成密钥 配置GitHubPage仍然在项目的Settings配置页面，找到GitHub Pages选项（在页面靠近最底部），按下图配置。完成现在你修改代码并推送到项目仓库，点击项目的Actions应该就能看到自动生成正在运行了。等到运行完成通过，在GitHubPage就能看到熟悉的vue启动页面。参考资料 GitHub Actions 入门教程 配置参考 Deploy to GitHub Pages" }, { "title": "tsconfig.json配置说明(转载)", "url": "/post/tsconfig.json%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E", "categories": "tsconfig, js, vue", "tags": "", "date": "2020-10-15 19:14:08 +0800", "snippet": "tsconfig.json配置说明 原文tsconfig.json 所包含的属性并不多，只有 7 个，ms 官方也给出了它的定义文件。但看起来并不怎么舒服，这里就翻译整理一下。（若有误，还请指出） files: 数组类型，用于表示由 ts 管理的文件的具体文件路径 exclude: 数组类型，用于表示 ts 排除的文件（2.0 以上支持 Glob） include: 数组类型，用于表示 ts 管理的文件（2.0 以上） compileOnSave: 布尔类型，用于 IDE 保存时是否生成编译后的文件 extends: 字符串类型，用于继承 ts 配置，2.1 版本后支持 compilerOptions: 对象类型，设置编译的选项，不设置则使用默认配置，配置项比较多，后面再列 typeAcquisition: 对象类型，设置自动引入库类型定义文件(.d.ts)相关，该对象下面有 3 个子属性分别是： enable: 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false include: 数组类型，允许自动引入的库名，如：[“jquery”, “lodash”] exculde: 数组类型，排除的库名如不设定 files 和 include，ts 默认是 exclude 以外的所有的以 .ts 和 .tsx 结尾的文件。如果，同时设置 files 的优先级最高，exclude 次之，include 最低。 上面都是文件相关的，编译相关的都是靠 compilerOptions 设置的，接着就来看一看。|属性名|值类型|默认值|描述||——|—–|—–|—-||allowJs|boolean|false|编译时，允许有 js 文件||allowSyntheticDefaultImports|boolean|module === “system”|允许引入没有默认导出的模块||allowUnreachableCode|boolean|false|允许覆盖不到的代码||allowUnusedLabels|boolean|false|允许未使用的标签||alwaysStrict|boolean|false|严格模式，为每个文件添加 “use strict”||baseUrl|string| |与 path 一同定义模块查找的路径，详细参考这里||charset|string|”utf8”|输入文件的编码类型||checkJs|boolean|false|验证 js 文件，与 allowJs 一同使用||declaration|boolean|false|生成 .d.ts 定义文件||declarationDir|string| |生成定义文件的存放文件夹（2.0 以上）||diagnostics|boolean|false|是否显示诊断信息||downlevelIteration|boolean|false|当 target 为 ES5 或 ES3 时，提供对 for..of，解构等的支持||emitBOM|boolean|false|在输出文件头添加 utf-8 (BOM)字节标记||emitDecoratorMetadata|boolean|false|详见 issue||experimentalDecorators|boolean|false|允许注解语法||forceConsistentCasingInFileNames|boolean|false|不允许不同变量来代表同一文件||importHelpers|boolean|false|引入帮助（2.1 以上）||inlineSourceMap|boolean|false|将 source map 一同生成到输出文件中||inlineSources|boolean|false|将 ts 源码生成到 source map 中，需要同时设置 inlineSourceMap 或 sourceMap||isolatedModules|boolean|false|将每个文件作为单独的模块||jsx|string|”preserve”|jsx 的编译方式||jsxFactory|string|”React.createElement”|定义 jsx 工厂方法，React.createElement 还是 h（2.1 以上）||lib|string[]| |引入库定义文件，可以是[“es5”, “es6”, “es2015”, “es7”, “es2016”, “es2017”, “esnext”, “dom”, “dom.iterable”, “webworker”, “scripthost”, “es2015.core”, “es2015.collection”, “es2015.generator”, “es2015.iterable”, “es2015.promise”, “es2015.proxy”, “es2015.reflect”, “es2015.symbol”, “es2015.symbol.wellknown”, “es2016.array.include”, “es2017.object”, “es2017.sharedmemory”, “esnext.asynciterable”]（2.0 以上）||listEmittedFiles|boolean|false|显示输入文件名||listFiles|boolean|false|显示编译输出文件名||locale|string|随系统|错误信息的语言||mapRoot|string| |定义 source map 的存放位置||maxNodeModuleJsDepth|number|0|检查引入 js 模块的深度，需同 allowJs 一同使用||module|string| |指定模块生成方式，[“commonjs”, “amd”, “umd”, “system”, “es6”, “es2015”, “esnext”, “none”]||moduleResolution|string| |指定模块解析方式，[“classic” : “node”]||newLine|string|随系统|行位换行符，”crlf” (windows) 或 “lf” (unix)||noEmit|boolean|false|不显示输出||noEmitHelpers|boolean|false|不在输出文件中生成帮助||noEmitOnError|boolean|false|出错后，不输出文件||noFallthroughCasesInSwitch|boolean|false|switch 语句中，每个 case 都要有 break||noImplicitAny|boolean|false|不允许隐式any，如果true，函数的形参必须带类型，如果叫不出class名的js对象，那就得any，比如（d:any）=&amp;gt;{}，如果false，函数的样子更像js （d）=&amp;gt;{}&amp;lt;/div&amp;gt;||noImplicitReturns|boolean|false|函数所有路径都必须有显示 return||noImplicitThis|boolean|false|不允许 this 为隐式 any||noImplicitUseStrict|boolean|false|输出中不添加 “use strict”||noLib|boolean|false|不引入默认库文件||noResolve|boolean|false|不编译三斜杠或模块引入的文件||noUnusedLocals|boolean|false|未使用的本地变量将报错（2.0 以上）||noUnusedParameters|boolean|false|未使用的参数将报错（2.0 以上）||outDir|string| |定义输出文件的文件夹||outFile|string| |合并输出到一个文件||paths|object| |与 baseUrl 一同定义模块查找的路径，详细参考这里||preserveConstEnums|boolean|false|不去除枚举声明||pretty|boolean|false|美化错误信息||reactNamespace|string|”React”|废弃。改用jsxFactory||removeComments|boolean|false|去除注释||rootDir|string|当前目录|定义输入文件根目录||rootDirs|string []| |定义输入文件根目录||skipDefaultLibCheck|boolean|false|废弃。改用 skipLibCheck||skipLibCheck|boolean|false|对库定义文件跳过类型检查（2.0 以上）||sourceMap|boolean|false|生成对应的 map 文件||sourceRoot|string| |调试时源码位置||strict|boolean|false|同时开启 alwaysStrict, noImplicitAny, noImplicitThis 和 strictNullChecks (2.3 以上)||strictNullChecks|boolean|false|null 检查（2.0 以上）||stripInternal|boolean|false|不输出 JSDoc 注解||suppressExcessPropertyErrors|boolean|false|不提示对象外属性错误||suppressImplicitAnyIndexErrors|boolean|false|不提示对象索引隐式 any 的错误||target|string|”es3”|输出代码 ES 版本，可以是 [“es3”, “es5”, “es2015”, “es2016”, “es2017”, “esnext”]||traceResolution|boolean|false|跟踪模块查找信息||typeRoots|string []| |定义文件的文件夹位置（2.0 以上）||types|string []| |设置引入的定义文件（2.0 以上）||watch|boolean|false|监听文件变更|一般情况下，tsconfig.json 文件只需配置 compilerOptions 部分。{ &quot;compilerOptions&quot;: { &quot;allowSyntheticDefaultImports&quot;: true, // 允许引入没有默认导出的模块 &quot;module&quot;: &quot;es2015&quot;, &quot;removeComments&quot;: true, &quot;preserveConstEnums&quot;: true, &quot;sourceMap&quot;: true, &quot;strict&quot;: true, &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [ &quot;dom&quot;, &quot;es5&quot;, &quot;es2015&quot; ] }}其中，allowSyntheticDefaultImports 是使用 vue 必须的，而设置 module 则是让模块交由 webpack 处理，从而可以使用 webpack2 的摇树。另外，加上allowJs，这样就可以一点点将现有的 js 代码转换为 ts 代码了。如果，你在 webpack 中设置过 resolve -&amp;gt; alias，那么，在 ts config 中也需要通过 baseUrl + path 的方式来定义模块查找的方式。&amp;lt;a name=&quot;tslint&quot;&amp;gt;&amp;lt;/a&amp;gt;" }, { "title": "Oracle使用Cast转换小数为字符串开头0消失", "url": "/post/Oracle%E4%BD%BF%E7%94%A8Cast%E8%BD%AC%E6%8D%A2%E5%B0%8F%E6%95%B0%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A4%B40%E6%B6%88%E5%A4%B1", "categories": "Oracle, CSharp", "tags": "", "date": "2020-10-14 19:14:08 +0800", "snippet": "在oracle中需要把小数转换成字符串返回，这时如果你的数字只有小数部分有值如：0.5，使用cast或者to_char转换都会变成”.5”，这是不符合中国人习惯的。在oracle中需要把小数转换成字符串返回，这时如果你的数字只有小数部分有值如：0.5，使用cast转换会变成”.5”，这是不符合中国人习惯的。SELECT CAST(0.5 as Varchar(20)) from dual;这时如果你到网上搜索，不管你怎么搜都只会得到下面这样让你格式化字符串的答案：SELECT to_char(0.5,&#39;fm9999990.9999&#39;) from dual;但是这样仍然有问题，就是你的数刚好是整数，没有小数点，这是会给你加上小数点。SELECT to_char(1,&#39;fm9999990.9999&#39;) from dual;结果变成了这样：1.一直冥思苦想都没找到办法解决。经过多方查证（在群里问了下），我的方向选错了，我一直想找一个原生的转换，完全忽略了可以针对这种情况单独处理一下，比如末尾有小数点时直接移除。select RTRIM(to_char(0.5,&#39;fm9999999990.9999&#39;),&#39;.&#39;),RTRIM(to_char(1,&#39;fm9999999990.9999&#39;),&#39;.&#39;),RTRIM(to_char(1.5,&#39;fm9999999990.9999&#39;),&#39;.&#39;)from dual答案很简单，换一种思考方式就可以简单解决问题。差点我就准备改程序把string类型改成float。一天的工作量一下就变成了一小时，又可以划水7小时了。参考资料 解决Oracle出现以0开头的小数，开头的0消失的问题" }, { "title": "AutoCAD自定义填充", "url": "/post/AutoCAD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A1%AB%E5%85%85", "categories": "AutoCAD", "tags": "", "date": "2020-09-27 19:14:08 +0800", "snippet": "在CAD中实现自定义的填充定义填充 下载填充制作工具：yqmkpat2.1 解压到目录 在CAD中加载工具输入AP命令，选择YQMKPAT.VLX文件，加载，加载成功后关闭 输入MP定义填充图案，可制作按实际大小1:1比例的图案填充(命令mp1) 选择填充图案 选择填充时的基点 输入横向间距 输入纵向间距因为填充是按横纵向阵列来的，所有有些不是矩形的填充需要自己定义好不规则形状，比如我这个填充：因为这不是矩形中间还有个填充，所有我选择了斜线上两个作为填充，基点为第一个圆形中心，间距20 使用填充参考资料 YQMKPAT (制作AutoCAD Hatch填充图案的工具) 帮助说明" }, { "title": "将本地web服务映射到外网", "url": "/post/%E5%B0%86%E6%9C%AC%E5%9C%B0web%E6%9C%8D%E5%8A%A1%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91", "categories": "asp.net, core, dotnet, csharp", "tags": "", "date": "2020-09-11 19:14:08 +0800", "snippet": "在web开发过程中，有时候我们需要把服务部署到外网，比如：微信开发回调就支持部署在外网的web网站。但是我们的机器基本都是内网环境，这时就需要一个隧道映射，你可以花6元钱选择花生壳。但是我没钱所以只能想其他办法。开始之前，您必须安装以下软件：node8.9版本及以上(https://nodejs.org/en/download/).进入正题 使用以下命令安装ngrok:npm install -g ngrok 等待安装完成，在终端中运行以下命令。该命令为您生成一个可供外部访问的URL。ngrok http 8080 --8080是你本地的端口，如http://localhost:8080在这一步你可能会遇到“无法加载文件 **.ps1，因为在此系统中禁止执行脚本。有关详细信息…”错误，这时需要开启脚本执行权限。以管理员模式启动cmd，执行以下命令：set-ExecutionPolicy RemoteSigned更改执行策略为“是”。参考资料 PowerShell因为在此系统中禁止执行脚本的解决方法" }, { "title": "实现Sqlite自动复制数据库文件备份数据库", "url": "/post/%E5%AE%9E%E7%8E%B0Sqlite%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93", "categories": "windowsService, dotnet, csharp", "tags": "", "date": "2020-09-03 19:14:08 +0800", "snippet": "实现Sqlite自动复制数据库文件备份数据库注意数据库如果开启了WAL模式，这时数据文件会存在两个与数据库同名且以shm和wal结尾的临时文件，这是可能存在数据还没有写入正式数据库文件，需要手动把数据写入，写入方式执行sql：PRAGMA wal_checkpoint参考资料 SQLite中的PRAGMA语句攻略" }, { "title": "计算不规则几何图形的面积", "url": "/post/%E8%AE%A1%E7%AE%97%E4%B8%8D%E8%A7%84%E5%88%99%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF", "categories": "dotnet, csharp", "tags": "", "date": "2020-09-02 19:14:08 +0800", "snippet": "利用向量叉乘计算不规则几何图形的面积和形心面积公式：形心公式：代码void Main(){ var points = new List&amp;lt;Point&amp;gt;{ new Point{ X=-112.3138,Y= 93.6871 }, new Point{ X=-138.5816,Y= 51.6801 }, new Point{ X= -73.5186,Y= 18.9627 }, new Point{ X=-115.1425,Y= 57.7386 }, new Point{ X=-112.3138,Y= 93.6871 }, }; var area = GetArea(points); Console.WriteLine(area); var xin = GetXin(points); Console.WriteLine($&quot;x:{xin.X},y:{xin.Y}&quot;);}Point GetXin(List&amp;lt;Point&amp;gt; points){ double x = 0; double y = 0; var area = GetArea(points); for (int i = 0; i &amp;lt; points.Count - 1; i++) { x += (points[i].X + points[i + 1].X) * (points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y); y += (points[i].Y + points[i + 1].Y) * (points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y); } x = x / (6 * area); y = y / (6 * area); return new Point() { X = x, Y = y };}double GetArea(List&amp;lt;Point&amp;gt; points){ double area = 0; for (int i = 0; i &amp;lt; points.Count - 1; i++) { area += points[i].X * points[i + 1].Y - points[i + 1].X * points[i].Y; } area = area / 2; return area;}struct Point{ public double X { get; set; } public double Y { get; set; }}参考资料 形心 计算几何——多边形面积" }, { "title": "计算点是否在多边形内部", "url": "/post/%E8%AE%A1%E7%AE%97%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8", "categories": "efcore, asp.net, dotnet, csharp", "tags": "", "date": "2020-08-28 19:14:08 +0800", "snippet": "使用PNPoly算法计算指定点是否在多边形内部代码void Main(){ var points = new List&amp;lt;Point&amp;gt;{ new Point{ X = 819.8061, Y = 615.9394 }, new Point{ X = 652.1153 ,Y = 469.6320 }, new Point{ X = 894.0853 ,Y = 554.0401 }, new Point{ X = 1042.6436, Y = 396.4782 }, new Point{ X = 981.8698 ,Y = 615.9394 }, new Point{ X = 819.8061 ,Y = 615.9394 }, }; var point = new Point { X=882.8309 ,Y=579.9252 }; var polygon = Polygon(points.Select(i =&amp;gt; i.X).ToArray(), points.Select(i =&amp;gt; i.Y).ToArray(), point.X, point.Y); Console.WriteLine(polygon); point = new Point { X=878.1040 ,Y=530.4058 }; polygon = Polygon(points.Select(i =&amp;gt; i.X).ToArray(), points.Select(i =&amp;gt; i.Y).ToArray(), point.X, point.Y); Console.WriteLine(polygon);}private static bool Polygon(double[] xs, double[] ys, double x, double y){ bool contained = false; // 点是否包含在多边形内 double xMin = xs.Min(); double xMax = xs.Max(); double yMin = ys.Min(); double yMax = ys.Max(); if (x &amp;gt; xMax || x &amp;lt; xMin || y &amp;gt; yMax || y &amp;lt; yMin) { contained = false; } // 核心算法部分 int N = xs.Length; for (int i = 0, j = N - 1; i &amp;lt; N; j = i++) { if (((ys[j] &amp;gt; y) != (ys[i] &amp;gt; y)) &amp;amp;&amp;amp; (x &amp;lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) { contained = !contained; } } return contained;}struct Point{ public double X { get; set; } public double Y { get; set; }}参考资料 算法 - PNPoly解决点到多边形的距离问题 PNPOLY - Point Inclusion in Polygon Test W. Randolph Franklin (WRF)" }, { "title": "EF Core在日志中输出sql语句", "url": "/post/EF-Core%E5%9C%A8%E6%97%A5%E5%BF%97%E4%B8%AD%E8%BE%93%E5%87%BAsql%E8%AF%AD%E5%8F%A5", "categories": "efcore, asp.net, dotnet, csharp", "tags": "", "date": "2020-08-28 19:14:08 +0800", "snippet": "在我们使用ef core的时候，有时候我们需要查看ef core生成的sql语句以便我们可以做进一步的分析处理。修改日志级别输出日志在配置文件appsettings.json中添加如下语句 &quot;Logging&quot;: { &quot;LogLevel&quot;: { &quot;Default&quot;: &quot;Information&quot;, &quot;Microsoft&quot;: &quot;Warning&quot;, &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;,++ &quot;Microsoft.EntityFrameworkCore.Database&quot;: &quot;Information&quot; } }这里相当于修改了ef core的默认输出日志级别，这样就会把sql输出，上面的配置对serilog依然有效显示sql中的参数值如果你的sql包含了参数，但是这样是不会输出参数值，参数值都是”?”，这是因为ef默认会对数据进行保护，如果需要显示参数值需要在DbContext中添加如下配置。protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder){++ optionsBuilder.EnableSensitiveDataLogging(); base.OnConfiguring(optionsBuilder);}参考资料 .NET Core实用技巧（一）如何将EF Core生成的SQL语句显示在控制台中" }, { "title": ".net core使用gb2312编码报错", "url": "/post/.net-core%E4%BD%BF%E7%94%A8gb2312%E7%BC%96%E7%A0%81%E6%8A%A5%E9%94%99", "categories": "v2rayN", "tags": "", "date": "2020-08-07 19:14:08 +0800", "snippet": "在.net core项目中使用Encoding.GetEncoding(“gb2312”).GetBytes()报错错误信息‘GB2312’ is not a supported encoding name. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.错误原因.net core为了改变.net framework臃肿的过去，采用模块化设计，把许多api进行了拆分，其中就有gb2312编码的api，现在拆分到独立的包System.Text.Encoding.CodePages中。解决办法从nuget安装System.Text.Encoding.CodePages包，并在使用前引入编码Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);参考资料.net core中使用GB2312编码的问题" }, { "title": "Windows Form定义快捷键（热键）", "url": "/post/Windows-Form%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE", "categories": "v2rayN", "tags": "", "date": "2020-07-31 19:14:08 +0800", "snippet": "在windows form编程中定义快捷键（热键），通过重写WndProc消息方法捕获快捷键按下事件注册快捷键在窗体加载方法中注册热键WinAPIHelper.RegisterHotKey(this.Handle, 100, WinAPIHelper.KeyModifiers.Ctrl , Keys.F);//WinAPIHelper.RegisterHotKey(this.Handle, 100, WinAPIHelper.KeyModifiers.Ctrl | WinAPIHelper.KeyModifiers.Alt, Keys.None); 只按下Ctrl+Alt触发键盘事件，比如你想实现按下ctrl+alt打开窗口快捷键按下时触发事件重写消息捕获方法拦截快捷键按下事件protected override void WndProc(ref Message m){ base.WndProc(ref m); Console.WriteLine(m.WParam); if (m.Msg == WinAPIHelper.WM_HOTKEY) { MessageBox.Show(m.WParam.ToString()); if (m.WParam.ToInt32()==100)//m.WParam是WinAPIHelper.RegisterHotKey第二个参数的值 { Console.WriteLine(&quot;你按下了Ctrl+Alt&quot;); } }}WindowsAPI辅助类public struct tagMSG{ public int hwnd; public uint message; public int wParam; public long lParam; public uint time; public POINT pt;}public struct POINT{ public int x; public int y;}public class WinAPIHelper{ #region 消息定义 //标准 public const int WM_CLOSE = 0x10; public const int WM_SETICON = 0x80; public const int WM_KEYDWON = 0x0100; public const int WM_HOTKEY = 0x312; public const int IMAGW_ICON = 1; public const int LR_LOADFROMFILE = 0x10; //自定义 public const int WM_OPENDT = 0x8888; public const int WM_OPENHTWJ = 0x7777; public const int WM_OPENPROJ = 0x6666; public const int WM_CLOSEPROJ = 0x5555; public const int WM_REFRESHPROJ = 0x5511; public const int WM_DELENTITY = 0x4444; public const int WM_SHOWENTTIY = 0x4443; public const int WM_GETCGT = 0x3339; public const int WM_CGTEND = 0x3338; public const int WM_STRSTR = 0x3333; public const int WM_USER = 0x0400; public const int WM_UNDO = 0x2229; public const uint GW_CHILD = 5; public const int GWL_WNDPROC = -4; public struct SELFDEFINfO { public int nInt; public string strCon; public string objName; public object obj; } #endregion #region 消息循环 [DllImport(&quot;user32&quot;, EntryPoint = &quot;DispatchMessage&quot;)] public static extern int DispatchMessage(ref tagMSG lpMsg); [DllImport(&quot;user32&quot;, EntryPoint = &quot;GetMessage&quot;)] public static extern int GetMessage( out tagMSG lpMsg, int hwnd, int wMsgFilterMin, int wMsgFilterMax ); [DllImport(&quot;user32&quot;, EntryPoint = &quot;TranslateMessage&quot;)] public static extern int TranslateMessage(ref tagMSG lpMsg); #endregion #region WinAPI定义 [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SendMessageA&quot;)] public static extern int SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam); [DllImport(&quot;User32.dll&quot;, EntryPoint = &quot;FindWindow&quot;)] public static extern IntPtr FindWindow(string lpClassName, string lpWindowName); [DllImport(&quot;User32.dll &quot;)] public static extern bool ShowWindow(IntPtr hWnd, int cmdShow); [DllImport(&quot;User32.dll &quot;, EntryPoint = &quot;SetParent&quot;)] public static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent); [DllImport(&quot;user32&quot;, EntryPoint = &quot;DispatchMessage&quot;)] public static extern int DispatchMessage(ref Message lpMsg); [DllImport(&quot;user32&quot;, EntryPoint = &quot;GetMessage&quot;)] public static extern int GetMessage( out Message lpMsg, int hwnd, int wMsgFilterMin, int wMsgFilterMax ); [DllImport(&quot;user32&quot;, EntryPoint = &quot;TranslateMessage&quot;)] public static extern int TranslateMessage(ref Message lpMsg); /// &amp;lt;summary&amp;gt; /// 设置窗口显示图标 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;hInst&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;lpsz&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;un1&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;n1&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;n2&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;un2&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [DllImport(&quot;user32&quot;, EntryPoint = &quot;LoadImage&quot;)] public static extern int LoadImageA(int hInst, string lpsz, int un1, int n1, int n2, int un2); [DllImport(&quot;User32.dll&quot;, EntryPoint = &quot;SendMessage&quot;)] public static extern int SendMessage( int hWnd, // handle to destination window int Msg, // message int wParam, // first message parameter int lParam // second message parameter ); [DllImport(&quot;User32.dll&quot;, EntryPoint = &quot;PostMessage&quot;)] public static extern int PostMessage( int hWnd, // handle to destination window int Msg, // message int wParam, // first message parameter int lParam // second message parameter ); [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto)] public static extern int PostMessage(int hwnd, int msg, int wparam, IntPtr lParam); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool PostThreadMessage(int threadId, uint msg, IntPtr wParam, IntPtr lParam); /// &amp;lt;summary&amp;gt; /// 向句柄发送消息（消息内容位对象） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;hwnd&quot;&amp;gt;句柄&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;msg&quot;&amp;gt;消息类型&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;wparam&quot;&amp;gt;参数&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;lParam&quot;&amp;gt;传递对象&amp;lt;/param&amp;gt; /// 使用实例：WinAPIHelper.SELFDEFINfO INFO = new WinAPIHelper.SELFDEFINfO(); /// INFO.nInt = 5; /// INFO.strCon = &quot;1234&quot;; /// INFO.obj = BussParaHelper._Chdata; /// WinAPIHelper.PostMessage(BussParaHelper._ProjDetailView.GetHandle(), WinAPIHelper.WM_USER, 0, INFO); /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static int PostMessage(int hwnd, int msg, int wparam, object lParam) { System.Runtime.InteropServices.GCHandle h = System.Runtime.InteropServices.GCHandle.Alloc(lParam, System.Runtime.InteropServices.GCHandleType.WeakTrackResurrection); System.IntPtr addr = System.Runtime.InteropServices.GCHandle.ToIntPtr(h); return PostMessage(hwnd, msg, wparam, addr); } /// &amp;lt;summary&amp;gt; /// 根据消息获取实体 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;msg&quot;&amp;gt;收到的消息&amp;lt;/param&amp;gt; /// 使用实例： var obj23 = (WinAPIHelper.SELFDEFINfO)WinAPIHelper.GetObjectByMsg(m); /// CHData jjj1 = obj23.obj as CHData; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static object GetObjectByMsg(Message msg) { System.Runtime.InteropServices.GCHandle handle2 = System.Runtime.InteropServices.GCHandle.FromIntPtr(msg.LParam); if (handle2 == null) return null; return handle2.Target; } [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SendMessageA&quot;)] public static extern int SendMessageA(IntPtr hwnd, int wMsg, IntPtr wParam, IntPtr lParam); /// &amp;lt;summary&amp;gt; /// 设置窗口显示文本 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;hwnd&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;lpString&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [DllImport(&quot;user32&quot;, EntryPoint = &quot;SetWindowText&quot;)] public static extern int SetWindowTextA(int hwnd, string lpString); #endregion /// &amp;lt;summary&amp;gt; /// 如果函数执行成功，返回值不为0。 /// 如果函数执行失败，返回值为0。要得到扩展错误信息，调用GetLastError。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;hWnd&quot;&amp;gt;要定义热键的窗口的句柄&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;id&quot;&amp;gt;定义热键ID（不能与其它ID重复）&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;fsModifiers&quot;&amp;gt;标识热键是否在按Alt、Ctrl、Shift、Windows等键时才会生效&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;vk&quot;&amp;gt;定义热键的内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool RegisterHotKey( IntPtr hWnd, //要定义热键的窗口的句柄 int id, //定义热键ID（不能与其它ID重复） KeyModifiers fsModifiers, //标识热键是否在按Alt、Ctrl、Shift、Windows等键时才会生效 Keys vk //定义热键的内容 ); /// &amp;lt;summary&amp;gt; /// 取消注册 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;hWnd&quot;&amp;gt;要取消热键的窗口的句柄&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;id&quot;&amp;gt;要取消热键的ID&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool UnregisterHotKey( IntPtr hWnd, //要取消热键的窗口的句柄 int id //要取消热键的ID ); //强制释放进程 [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;SetProcessWorkingSetSize&quot;)] public static extern int SetProcessWorkingSetSize(IntPtr process, int minSize, int maxSize); [DllImport(&quot;user32&quot;, EntryPoint = &quot;HideCaret&quot;)] public static extern bool HideCaret(IntPtr hWnd); [System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)] public static extern IntPtr GetWindow(IntPtr hWnd, uint uCmd); [System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)] public static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong); [System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)] public static extern int GetWindowLong(IntPtr hWnd, int nIndex); [System.Runtime.InteropServices.DllImport(&quot;User32.dll&quot;)] public static extern IntPtr CallWindowProc(IntPtr lpPrevWndFunc, IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam); [DllImport(&quot;psapi.dll&quot;)] public static extern int EmptyWorkingSet(IntPtr hwProc); /// &amp;lt;summary&amp;gt; /// 定义了辅助键的名称（将数字转变为字符以便于记忆，也可去除此枚举而直接使用数值） /// &amp;lt;/summary&amp;gt; [Flags] public enum KeyModifiers { None = 0, Alt = 1, Ctrl = 2, Shift = 4, WindowsKey = 8 }}" }, { "title": "GitHub代下载（文件加速）网站列表（转载）", "url": "/post/GitHub%E4%BB%A3%E4%B8%8B%E8%BD%BD-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%80%9F-%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8-%E8%BD%AC%E8%BD%BD", "categories": "v2rayN", "tags": "", "date": "2020-07-29 19:14:08 +0800", "snippet": "转载备份避免找不到了，原文链接GitHub代下载（文件加速）网站列表Github（ https://github.com/ ）是世界上最大的使用Git进行版本控制的软件源代码托管服务平台然而Github release的下载速度非常慢。之前我一直用IDM下载，速度还行，1-2M/s，就没怎么在意。但2020.6.15起速度仅50K/s……于是开始收集代理GitHub下载的网站，以备不时之需。当然，如果是clone的话可以镜像一个到国内Gitee，稳定且快。本列表会持续更新，欢迎收藏本页维基百科Wikipedia镜像网站列表点击此处查看Google镜像网站列表点击此处查看风险声明您使用这些代理时，存在以下风险： 切记勿进行登录等敏感操作，有账号泄露风险。其他风险 另外，本站仅收集下列站点，请您谨慎使用。GitHub代下载网站列表http://g.widyun.com/http://gg.widyun.com/http://g.widora.cn/http://github.b15.me/https://gh.api.99988866.xyz/https://shrill-pond-3e81.hunsh.workers.dev/https://www.toolnb.com/tools/githubjiasu.html（付费）https://pay.baoapi.com/down.htmlGitHub反代链接staticdn将 raw.githubusercontent.com替换为raw.staticdn.net——来自 https://cdn.con.sh/cnpmjsclone，将 github.com替换为github.com.cnpmjs.orgFastGitRelease 和源码存档的下载假设下载链接为https://github.com/A/A/releases/download/1.0/1.0.tar.gz，使用：https://download.fastgit.org将原链接替换，得到下载地址：https://download.fastgit.org/A/A/releases/download/1.0/1.0.tar.gz反代列表|站源| 反代域名|备注||—-|—-|—-||github.com|hub.fastgit.org|clone用，无缓存||raw.githubusercontent.com|raw.fastgit.org|无缓存||github.githubassets.com|assets.fastgit.org|无缓存||customer-stories-feed.github.com|customer-stories-feed.fastgit.org|缓存60 分钟|具体参见 FastGit 文档：https://doc.fastgit.org/—参考资料 GitHub代下载（文件加速）网站列表" }, { "title": "v2rayN订阅地址", "url": "/post/v2rayN%E8%AE%A2%E9%98%85%E5%9C%B0%E5%9D%80", "categories": "v2rayN", "tags": "", "date": "2020-07-29 19:14:08 +0800", "snippet": "订阅地址 https://youlianboshi.netlify.com https://muma16fx.netlify.com https://fforever.github.io/v2rayfree https://jiang.netlify.com https://www.go4net.ga/v2ray.txt https://bihai-v2ray.netlify.com https://www.tiancai.ml/baba.txt https://freev2ray.netlify.com https://www.namaho.org/service/subscribe https://cdn.jsdelivr.net/gh/fggfffgbg/https-aishangyou.tube-@master/README.md https://rss.sswow.xyz/link/pjcHSsymqDeXViPZ参考资料 V2ray客户端地址与订阅地址分享" }, { "title": "5.最长回文子串", "url": "/post/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2", "categories": "LeetCode, dotnet, csharp", "tags": "", "date": "2020-07-24 19:14:08 +0800", "snippet": "LeetCode题库-5.最长回文子串解题方法回文串解释“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。（百度百科）简单解法 通过上面的解释很容易写出一个判断回文串的逻辑,判断第一位和最后一位是否相同，第二位和倒数第二位是否相同，直到字符串的中部：public bool IsHuiWen(string s){ for (int i = 0; i &amp;lt; s.Length / 2; i++) { if (s[i] != s[s.Length - 1 - i]) { return false; } } return true;}2.对传入的字符串取所有子字符串，依次调用判断逻辑，找到最长的子字符串就行了，为了加快查找速度，我们从最长的子字符串开始，如果要判断的比现在找到的还短那就不用判断了，因为就算是回文串也不是最长的public string LongestPalindrome(string s){ var maxLength = 0; var maxString = &quot;&quot;; for (int i = 0; i &amp;lt; s.Length; i++) { if (maxLength &amp;gt; s.Length - i) { break; } for (int j = s.Length; j &amp;gt; i; j--) { if (maxLength &amp;gt; j - i) { break; } if (IsHuiWen(s.Substring(i, j - i)) &amp;amp;&amp;amp; j - i &amp;gt; maxLength) { maxLength = j - i; maxString = s.Substring(i, j - i); } } } return maxString;}无奈重写的算法上面的解法简单好理解，但是通过不了，因为下面这个字符串判断时超过了leetcode认为的最大时间。我觉得leetcode的服务器太水了，于是我去看了下推荐答案的时间：3ms。我的算法执行也才800+ms，差值不到1s还是很小的啊。但是没办法还是要改啊。&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;第一种是通过遍历子字符串，如果字符串很长（最大1000）遍历的次数还是比较多的，用排列组合可以简单算一下（我不会，反正挺多的），所以还是用最开始想到的方法（因为开始我觉得太麻烦了就没实现）。从回文串的解释中可以推出，回文串从中间开始向两边推也是相同的，回文串长度可能是奇数或偶数，这两种情况稍有差别，如：bab和baab，中值位置不一样。需要分别考虑（合并考虑我不会）。这样就可以减少子字符串的截取操作，少一次循环。这样大概在3-4ms左右，比我第一个算法性能提高200倍，还是很牛逼的。public string LongestPalindrome(string s){ var maxLength = 0; var maxStr = &quot;&quot;; for (int i = 0; i &amp;lt; s.Length; i++) { var curMaxLength = 1; while (i - curMaxLength &amp;gt;= 0 &amp;amp;&amp;amp; i + curMaxLength &amp;lt; s.Length) { if (s[i - curMaxLength] != s[i + curMaxLength]) { break; } curMaxLength++; } curMaxLength--;//curMaxLength最后一次是不符合的，所以要去掉最后一次自增 if (maxLength &amp;lt; (curMaxLength * 2 + 1)) { maxLength = (curMaxLength * 2 + 1); maxStr = s.Substring(i - curMaxLength , curMaxLength * 2 + 1); } curMaxLength = 0; while (i - curMaxLength &amp;gt;= 0 &amp;amp;&amp;amp; i + curMaxLength + 1 &amp;lt; s.Length) { if (s[i - curMaxLength] != s[i + curMaxLength + 1]) { break; } curMaxLength++; } curMaxLength--; if (maxLength &amp;lt; (curMaxLength + 1) * 2) { maxLength = (curMaxLength + 1) * 2; maxStr = s.Substring(i - curMaxLength, (curMaxLength + 1) * 2); } } return maxStr;}参考资料 github-LeetCode" }, { "title": "获取程序所有加载的程序集", "url": "/post/%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E6%89%80%E6%9C%89%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86", "categories": "dotnetcore, dotnet, csharp", "tags": "", "date": "2020-07-24 19:14:08 +0800", "snippet": "在某些时候需要用到获取当前程序加载的所有程序集，比如依赖注入时自动注册。直接上代码var entryAssembly = Assembly.GetEntryAssembly();var referencedAssemblies = entryAssembly.GetReferencedAssemblies().Select(Assembly.Load);var assemblies = new List&amp;lt;Assembly&amp;gt; { entryAssembly }.Concat(referencedAssemblies);如果你使用Scrutor就可以使用下面的方式来注册了services.Scan(scan =&amp;gt; { var entryAssembly = Assembly.GetEntryAssembly(); var referencedAssemblies = entryAssembly.GetReferencedAssemblies().Select(Assembly.Load); var assemblies = new List&amp;lt;Assembly&amp;gt; { entryAssembly }.Concat(referencedAssemblies); scan. FromAssemblies(assemblies) .AddClasses(cs=&amp;gt;cs.Where(c=&amp;gt;c.Name.EndsWith(&quot;AppService&quot;)))//这里不能直接使用.AddClasses()，因为这里的程序集包含了许多系统自带的程序集，里面的类型注册会有问题，所以你要排除那些，你可以在程序集处排除（只保留你自己的程序集），也可以在这里排除 .AsImplementedInterfaces() .WithTransientLifetime();});" }, { "title": "C#读取计算机硬件信息", "url": "/post/C-%E8%AF%BB%E5%8F%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF", "categories": "windows, dotnet, csharp", "tags": "", "date": "2020-07-23 19:14:08 +0800", "snippet": "在制作软件授权码的时候我们一般都会去获取电脑的mac地址和硬件的一些编号作为机器码，在针对机器码生成授权码，这样可以防止同一个授权码多用。获取硬件信息c#使用System.Management.ManagementObjectSearcher检索硬件信息。要使用这个类必须安装System.Management包，可以在nuget中搜索这个包安装。如果是.net framework，电脑上有这个dll，应该可以直接引用。使用下面的方式获取对于的硬件信息ManagementObjectSearcher searcher = new ManagementObjectSearcher( &quot;select * from &quot; + Key);获取cpu编号ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher(&quot;select * from Win32_Processor&quot;);ManagementObjectCollection managementObjectCollection = managementObjectSearcher.Get();List&amp;lt;string&amp;gt; list = new List&amp;lt;string&amp;gt;();foreach (ManagementBaseObject item in managementObjectCollection){ list.Add(item[&quot;processorid&quot;].ToString());}string result = string.Join(&quot;,&quot;, list.OrderBy((string m) =&amp;gt; m).ToArray());return result;获取mac地址ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher(&quot;SELECT * FROM Win32_NetworkAdapterConfiguration&quot;);ManagementObjectCollection managementObjectCollection = managementObjectSearcher.Get();List&amp;lt;string&amp;gt; list = new List&amp;lt;string&amp;gt;();foreach (ManagementObject item in managementObjectCollection){ if (item[&quot;IPEnabled&quot;].ToString() == &quot;True&quot;) { list.Add(item[&quot;MacAddress&quot;].ToString().Trim()); }}var result = string.Join(&quot;,&quot;, list.OrderBy((string m) =&amp;gt; m).ToArray());return result;获取主板序列号public string GetBIOSSerialNumber(){ try { ManagementObjectSearcher searcher = new ManagementObjectSearcher(&quot;Select * From Win32_BIOS&quot;); string sBIOSSerialNumber = &quot;&quot;; foreach (ManagementObject mo in searcher.Get()) { sBIOSSerialNumber = mo.GetPropertyValue(&quot;SerialNumber&quot;).ToString().Trim(); break; } return sBIOSSerialNumber; } catch { return &quot;&quot;; }}获取硬盘序列号public string GetHardDiskSerialNumber(){ try { ManagementObjectSearcher searcher = new ManagementObjectSearcher(&quot;SELECT * FROM Win32_PhysicalMedia&quot;); string sHardDiskSerialNumber = &quot;&quot;; foreach (ManagementObject mo in searcher.Get()) { sHardDiskSerialNumber = mo[&quot;SerialNumber&quot;].ToString().Trim(); break; } return sHardDiskSerialNumber; } catch { return &quot;&quot;; }}对应key值和属性说明如果你不知道属性名称是什么可以遍历输出找一找，搜一搜foreach (var property in managementObject.Properties){ Console.WriteLine(property.Name+&quot;:&quot;+property.Value);}常用Key// 硬件 Win32_Processor, // CPU 处理器 Win32_PhysicalMemory, // 物理内存条 Win32_Keyboard, // 键盘 Win32_PointingDevice, // 点输入设备，包括鼠标。 Win32_FloppyDrive, // 软盘驱动器 Win32_DiskDrive, // 硬盘驱动器 Win32_CDROMDrive, // 光盘驱动器 Win32_BaseBoard, // 主板 Win32_BIOS, // BIOS 芯片 Win32_ParallelPort, // 并口 Win32_SerialPort, // 串口 Win32_SerialPortConfiguration, // 串口配置 Win32_SoundDevice, // 多媒体设置，一般指声卡。 Win32_SystemSlot, // 主板插槽 (ISA &amp;amp; PCI &amp;amp; AGP) Win32_USBController, // USB 控制器 Win32_NetworkAdapter, // 网络适配器 Win32_NetworkAdapterConfiguration, // 网络适配器设置 Win32_Printer, // 打印机 Win32_PrinterConfiguration, // 打印机设置 Win32_PrintJob, // 打印机任务 Win32_TCPIPPrinterPort, // 打印机端口 Win32_POTSModem, // MODEM Win32_POTSModemToSerialPort, // MODEM 端口 Win32_DesktopMonitor, // 显示器 Win32_DisplayConfiguration, // 显卡 Win32_DisplayControllerConfiguration, // 显卡设置 Win32_VideoController, // 显卡细节。 Win32_VideoSettings, // 显卡支持的显示模式。 // 操作系统 Win32_TimeZone, // 时区 Win32_SystemDriver, // 驱动程序 Win32_DiskPartition, // 磁盘分区 Win32_LogicalDisk, // 逻辑磁盘 Win32_LogicalDiskToPartition, // 逻辑磁盘所在分区及始末位置。 Win32_LogicalMemoryConfiguration, // 逻辑内存配置 Win32_PageFile, // 系统页文件信息 Win32_PageFileSetting, // 页文件设置 Win32_BootConfiguration, // 系统启动配置 Win32_ComputerSystem, // 计算机信息简要 Win32_OperatingSystem, // 操作系统信息 Win32_StartupCommand, // 系统自动启动程序 Win32_Service, // 系统安装的服务 Win32_Group, // 系统管理组 Win32_GroupUser, // 系统组帐号 Win32_UserAccount, // 用户帐号 Win32_Process, // 系统进程 Win32_Thread, // 系统线程 Win32_Share, // 共享 Win32_NetworkClient, // 已安装的网络客户端 Win32_NetworkProtocol, // 已安装的网络协议全部KeyWin32_1394ControllerWin32_1394ControllerDeviceWin32_AccountWin32_AccountSIDWin32_ACEWin32_ActionCheckWin32_AllocatedResourceWin32_ApplicationCommandLineWin32_ApplicationServiceWin32_AssociatedBatteryWin32_AssociatedProcessorMemoryWin32_BaseBoardWin32_BaseServiceWin32_BatteryWin32_BinaryWin32_BindImageActionWin32_BIOSWin32_BootConfigurationWin32_BusWin32_CacheMemoryWin32_CDROMDriveWin32_CheckCheckWin32_CIMLogicalDeviceCIMDataFileWin32_ClassicCOMApplicationClassesWin32_ClassicCOMClassWin32_ClassicCOMClassSettingWin32_ClassicCOMClassSettingsWin32_ClassInfoActionWin32_ClientApplicationSettingWin32_CodecFileWin32_COMApplicationWin32_COMApplicationClassesWin32_COMApplicationSettingsWin32_COMClassWin32_ComClassAutoEmulatorWin32_ComClassEmulatorWin32_CommandLineAccessWin32_ComponentCategoryWin32_ComputerSystemWin32_ComputerSystemProcessorWin32_ComputerSystemProductWin32_COMSettingWin32_ConditionWin32_CreateFolderActionWin32_CurrentProbeWin32_DCOMApplicationWin32_DCOMApplicationAccessAllowedSettingWin32_DCOMApplicationLaunchAllowedSettingWin32_DCOMApplicationSettingWin32_DependentServiceWin32_DesktopWin32_DesktopMonitorWin32_DeviceBusWin32_DeviceMemoryAddressWin32_DeviceSettingsWin32_DirectoryWin32_DirectorySpecificationWin32_DiskDriveWin32_DiskDriveToDiskPartitionWin32_DiskPartitionWin32_DisplayConfigurationWin32_DisplayControllerConfigurationWin32_DMAChannelWin32_DriverVXDWin32_DuplicateFileActionWin32_EnvironmentWin32_EnvironmentSpecificationWin32_ExtensionInfoActionWin32_FanWin32_FileSpecificationWin32_FloppyControllerWin32_FloppyDriveWin32_FontInfoActionWin32_GroupWin32_GroupUserWin32_HeatPipeWin32_IDEControllerWin32_IDEControllerDeviceWin32_ImplementedCategoryWin32_InfraredDeviceWin32_IniFileSpecificationWin32_InstalledSoftwareElementWin32_IRQResourceWin32_KeyboardWin32_LaunchConditionWin32_LoadOrderGroupWin32_LoadOrderGroupServiceDependenciesWin32_LoadOrderGroupServiceMembersWin32_LogicalDiskWin32_LogicalDiskRootDirectoryWin32_LogicalDiskToPartitionWin32_LogicalFileAccessWin32_LogicalFileAuditingWin32_LogicalFileGroupWin32_LogicalFileOwnerWin32_LogicalFileSecuritySettingWin32_LogicalMemoryConfigurationWin32_LogicalProgramGroupWin32_LogicalProgramGroupDirectoryWin32_LogicalProgramGroupItemWin32_LogicalProgramGroupItemDataFileWin32_LogicalShareAccessWin32_LogicalShareAuditingWin32_LogicalShareSecuritySettingWin32_ManagedSystemElementResourceWin32_MemoryArrayWin32_MemoryArrayLocationWin32_MemoryDeviceWin32_MemoryDeviceArrayWin32_MemoryDeviceLocationWin32_MethodParameterClassWin32_MIMEInfoActionWin32_MotherboardDeviceWin32_MoveFileActionWin32_MSIResourceWin32_NetworkAdapterWin32_NetworkAdapterConfigurationWin32_NetworkAdapterSettingWin32_NetworkClientWin32_NetworkConnectionWin32_NetworkLoginProfileWin32_NetworkProtocolWin32_NTEventlogFileWin32_NTLogEventWin32_NTLogEventComputerWin32_NTLogEventLogWin32_NTLogEventUserWin32_ODBCAttributeWin32_ODBCDataSourceAttributeWin32_ODBCDataSourceSpecificationWin32_ODBCDriverAttributeWin32_ODBCDriverSoftwareElementWin32_ODBCDriverSpecificationWin32_ODBCSourceAttributeWin32_ODBCTranslatorSpecificationWin32_OnBoardDeviceWin32_OperatingSystemWin32_OperatingSystemQFEWin32_OSRecoveryConfigurationWin32_PageFileWin32_PageFileElementSettingWin32_PageFileSettingWin32_PageFileUsageWin32_ParallelPortWin32_PatchWin32_PatchFileWin32_PatchPackageWin32_PCMCIAControllerWin32_PerfWin32_PerfRawDataWin32_PerfRawData_ASP_ActiveServerPagesWin32_PerfRawData_ASPNET_114322_ASPNETAppsv114322Win32_PerfRawData_ASPNET_114322_ASPNETv114322Win32_PerfRawData_ASPNET_ASPNETWin32_PerfRawData_ASPNET_ASPNETApplicationsWin32_PerfRawData_IAS_IASAccountingClientsWin32_PerfRawData_IAS_IASAccountingServerWin32_PerfRawData_IAS_IASAuthenticationClientsWin32_PerfRawData_IAS_IASAuthenticationServerWin32_PerfRawData_InetInfo_InternetInformationServicesGlobalWin32_PerfRawData_MSDTC_DistributedTransactionCoordinatorWin32_PerfRawData_MSFTPSVC_FTPServiceWin32_PerfRawData_MSSQLSERVER_SQLServerAccessMethodsWin32_PerfRawData_MSSQLSERVER_SQLServerBackupDeviceWin32_PerfRawData_MSSQLSERVER_SQLServerBufferManagerWin32_PerfRawData_MSSQLSERVER_SQLServerBufferPartitionWin32_PerfRawData_MSSQLSERVER_SQLServerCacheManagerWin32_PerfRawData_MSSQLSERVER_SQLServerDatabasesWin32_PerfRawData_MSSQLSERVER_SQLServerGeneralStatisticsWin32_PerfRawData_MSSQLSERVER_SQLServerLatchesWin32_PerfRawData_MSSQLSERVER_SQLServerLocksWin32_PerfRawData_MSSQLSERVER_SQLServerMemoryManagerWin32_PerfRawData_MSSQLSERVER_SQLServerReplicationAgentsWin32_PerfRawData_MSSQLSERVER_SQLServerReplicationDistWin32_PerfRawData_MSSQLSERVER_SQLServerReplicationLogreaderWin32_PerfRawData_MSSQLSERVER_SQLServerReplicationMergeWin32_PerfRawData_MSSQLSERVER_SQLServerReplicationSnapshotWin32_PerfRawData_MSSQLSERVER_SQLServerSQLStatisticsWin32_PerfRawData_MSSQLSERVER_SQLServerUserSettableWin32_PerfRawData_NETFramework_NETCLRExceptionsWin32_PerfRawData_NETFramework_NETCLRInteropWin32_PerfRawData_NETFramework_NETCLRJitWin32_PerfRawData_NETFramework_NETCLRLoadingWin32_PerfRawData_NETFramework_NETCLRLocksAndThreadsWin32_PerfRawData_NETFramework_NETCLRMemoryWin32_PerfRawData_NETFramework_NETCLRRemotingWin32_PerfRawData_NETFramework_NETCLRSecurityWin32_PerfRawData_Outlook_OutlookWin32_PerfRawData_PerfDisk_PhysicalDiskWin32_PerfRawData_PerfNet_BrowserWin32_PerfRawData_PerfNet_RedirectorWin32_PerfRawData_PerfNet_ServerWin32_PerfRawData_PerfNet_ServerWorkQueuesWin32_PerfRawData_PerfOS_CacheWin32_PerfRawData_PerfOS_MemoryWin32_PerfRawData_PerfOS_ObjectsWin32_PerfRawData_PerfOS_PagingFileWin32_PerfRawData_PerfOS_ProcessorWin32_PerfRawData_PerfOS_SystemWin32_PerfRawData_PerfProc_FullImage_CostlyWin32_PerfRawData_PerfProc_Image_CostlyWin32_PerfRawData_PerfProc_JobObjectWin32_PerfRawData_PerfProc_JobObjectDetailsWin32_PerfRawData_PerfProc_ProcessWin32_PerfRawData_PerfProc_ProcessAddressSpace_CostlyWin32_PerfRawData_PerfProc_ThreadWin32_PerfRawData_PerfProc_ThreadDetails_CostlyWin32_PerfRawData_RemoteAccess_RASPortWin32_PerfRawData_RemoteAccess_RASTotalWin32_PerfRawData_RSVP_ACSPerRSVPServiceWin32_PerfRawData_Spooler_PrintQueueWin32_PerfRawData_TapiSrv_TelephonyWin32_PerfRawData_Tcpip_ICMPWin32_PerfRawData_Tcpip_IPWin32_PerfRawData_Tcpip_NBTConnectionWin32_PerfRawData_Tcpip_NetworkInterfaceWin32_PerfRawData_Tcpip_TCPWin32_PerfRawData_Tcpip_UDPWin32_PerfRawData_W3SVC_WebServiceWin32_PhysicalMemoryWin32_PhysicalMemoryArrayWin32_PhysicalMemoryLocationWin32_PNPAllocatedResourceWin32_PnPDeviceWin32_PnPEntityWin32_PointingDeviceWin32_PortableBatteryWin32_PortConnectorWin32_PortResourceWin32_POTSModemWin32_POTSModemToSerialPortWin32_PowerManagementEventWin32_PrinterWin32_PrinterConfigurationWin32_PrinterControllerWin32_PrinterDriverDllWin32_PrinterSettingWin32_PrinterShareWin32_PrintJobWin32_PrivilegesStatusWin32_ProcessWin32_ProcessorWin32_ProcessStartupWin32_ProductWin32_ProductCheckWin32_ProductResourceWin32_ProductSoftwareFeaturesWin32_ProgIDSpecificationWin32_ProgramGroupWin32_ProgramGroupContentsWin32_ProgramGroupOrItemWin32_PropertyWin32_ProtocolBindingWin32_PublishComponentActionWin32_QuickFixEngineeringWin32_RefrigerationWin32_RegistryWin32_RegistryActionWin32_RemoveFileActionWin32_RemoveIniActionWin32_ReserveCostWin32_ScheduledJobWin32_SCSIControllerWin32_SCSIControllerDeviceWin32_SecurityDescriptorWin32_SecuritySettingWin32_SecuritySettingAccessWin32_SecuritySettingAuditingWin32_SecuritySettingGroupWin32_SecuritySettingOfLogicalFileWin32_SecuritySettingOfLogicalShareWin32_SecuritySettingOfObjectWin32_SecuritySettingOwnerWin32_SelfRegModuleActionWin32_SerialPortWin32_SerialPortConfigurationWin32_SerialPortSettingWin32_ServiceWin32_ServiceControlWin32_ServiceSpecificationWin32_ServiceSpecificationServiceWin32_SettingCheckWin32_ShareWin32_ShareToDirectoryWin32_ShortcutActionWin32_ShortcutFileWin32_ShortcutSAPWin32_SIDWin32_SMBIOSMemoryWin32_SoftwareElementWin32_SoftwareElementActionWin32_SoftwareElementCheckWin32_SoftwareElementConditionWin32_SoftwareElementResourceWin32_SoftwareFeatureWin32_SoftwareFeatureActionWin32_SoftwareFeatureCheckWin32_SoftwareFeatureParentWin32_SoftwareFeatureSoftwareElementsWin32_SoundDeviceWin32_StartupCommandWin32_SubDirectoryWin32_SystemAccountWin32_SystemBIOSWin32_SystemBootConfigurationWin32_SystemDesktopWin32_SystemDevicesWin32_SystemDriverWin32_SystemDriverPNPEntityWin32_SystemEnclosureWin32_SystemLoadOrderGroupsWin32_SystemLogicalMemoryConfigurationWin32_SystemMemoryResourceWin32_SystemNetworkConnectionsWin32_SystemOperatingSystemWin32_SystemPartitionsWin32_SystemProcessesWin32_SystemProgramGroupsWin32_SystemResourcesWin32_SystemServicesWin32_SystemSettingWin32_SystemSlotWin32_SystemSystemDriverWin32_SystemTimeZoneWin32_SystemUsersWin32_TapeDriveWin32_TemperatureProbeWin32_ThreadWin32_TimeZoneWin32_TrusteeWin32_TypeLibraryActionWin32_UninterruptiblePowerSupplyWin32_USBControllerWin32_USBControllerDeviceWin32_UserAccountWin32_UserDesktopWin32_VideoConfigurationWin32_VideoControllerWin32_VideoSettingsWin32_VoltageProbeWin32_WMIElementSettingWin32_WMISetting参考资料 WPF 读取硬件序列号 【C#】C#获得计算机硬件信息和操作系统信息，ManagementObjectSearcher ManagementObjectSearcher Class" }, { "title": "21.合并两个有序链表", "url": "/post/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8", "categories": "LeetCode, dotnet, csharp", "tags": "", "date": "2020-07-21 19:14:08 +0800", "snippet": "LeetCode题库-21.合并两个有序链表解题方法一般方法遍历两个链表，一一对比取得的元素，把小的元素放入新的链表中如l1=[1,2,4],l2=[1,3,4] 创建一个新的链表ListNode newListNode=null; 使用两个指针分别指向两个链表的第一个元素l1_1=1，l2_1=1; 比较两个元素，如果第一个大于等于第二个，则取第二个链表的元素，否则取第一个链表的元素,这里取到L2_1,放入newListNode； 第二个链表移动到下一个元素l2_2，第一个链表还是第一个元素，重复第三步，直到一个链表取完元素， 这是如果另一个链表还有元素，直接把剩下的元素放到新链表尾部，因为原来的链表本来就是有序的代码如下public ListNode MergeTwoLists(ListNode l1, ListNode l2){ if (l1 == null) { return l2; } if (l2 == null) { return l1; } ListNode newListNode = null; ListNode curListNode = null; var curListNode1 = l1; var curListNode2 = l2; while (curListNode1 != null &amp;amp;&amp;amp; curListNode2 != null) { ListNode curListNodeNext = null; if (curListNode1.val &amp;gt; curListNode2.val) { curListNodeNext = new ListNode(curListNode2.val, null); curListNode2 = curListNode2.next; } else { curListNodeNext = new ListNode(curListNode1.val, null); curListNode1 = curListNode1.next; } if (curListNode == null) { curListNode = curListNodeNext; newListNode = curListNode; } else { curListNode.next = curListNodeNext; } curListNode = curListNodeNext; } if (curListNode1 != null) { curListNode.next = curListNode1; } else if (curListNode2 != null) { curListNode.next = curListNode2; } return newListNode;}递归思想参考答案使用的递归思想，这个做法和汉诺塔的解法差不多，就是先取出小的一个元素，剩下的交给其他方法去排序,只要理解了思想这种方式代码简单得多，比如你们领导分提成的时候说：我拿一半，剩下的你们分。然后第二个领导也说：我拿一半，剩下的你们分。最后到你这里还有一半，要是叫你写算法来计算提成，用递归要简单很多。代码如下public ListNode MergeTwoLists(ListNode l1, ListNode l2){ if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &amp;lt;= l2.val) { l1.next = MergeTwoLists(l1.next, l2); return l1; } else { l2.next = MergeTwoLists(l1, l2.next); return l2; }}参考资料 github-LeetCode" }, { "title": "离线安装Microsoft Store应用商店程序", "url": "/post/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85windows%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E7%A8%8B%E5%BA%8F", "categories": "uwp, windows, dotnet, csharp", "tags": "", "date": "2020-07-21 19:14:08 +0800", "snippet": "不知道什么原因打开Microsoft Store始终提示无法加载页面（代码: 0x80131500），参照网上说的改了很多设置还是无效，所幸能打开Microsoft Store应用的web页面，只能通过下载app手动安装。下载app首先找到你需要下载的app 我需要下载一个rss的订阅管理器Newsflowhttps://www.microsoft.com/zh-cn/p/newsflow/9nblggh58s5r 复制页面链接（浏览器地址栏的链接） 打开这个网站，填入第2步复制的链接，点勾勾:https://store.rg-adguard.net/ 出现了一个列表，因为这个列表会把app的依赖包也显示出来，如果选择的app有很多依赖包的话，这个列表会很长。如果电脑有联网，只需要下载app的安装包就行了，依赖包会自动安装。如果你的电脑没有联网可能需要先安装依赖包（我猜的，没试过，我的电脑有网络只是Microsoft Store连不上） 选择名称和你想下载的app相同的后缀为.appxbundle的文件下载 双击安装，这里需要在设置中开启任意来源的app安装权限应用商店可以直接在微软中国主页搜索你的app名称参考资料 离线下载安装Microsoft Store中的应用 应用商店 代码: 0x80131500：应用商店崩溃了。怎么修复" }, { "title": "数据库sql查询优化", "url": "/post/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96", "categories": "sql, sqlserver", "tags": "", "date": "2020-07-18 19:14:08 +0800", "snippet": "作为非专业数据库开发人员，我们一般优化就是加索引，但是索引总不能把所有的列都加上吧，这里有一条sql可以查询系统在使用中那些查询是因为索引缺失带来开销很大的，你就可以专门针对这些查询优化（加索引），但是如果这个查询出来有几千条以上，就根据你丰富的经（随）验（便）来选择加哪些索引，你也可以去吐槽开发数据库的人，我的sql你都无法自动优化还写什么数据库。sqlSELECTddmid.statement,--索引缺失的表的名称ddmid.equality_columns,--构成相等谓词的列的逗号分隔列表ddmid.inequality_columns,--构成不等谓词的列的逗号分隔列表ddmid.included_columns,--用于查询的涵盖列的逗号分隔列表ddmigs.user_seeks,--由可能使用了组中建议索引的用户查询所导致的查找次数ddmigs.user_scans,--由可能使用了组中建议索引的用户查询所导致的扫描次数ddmigs.avg_total_user_cost,--可通过组中的索引减少的用户查询的平均成本。ddmigs.avg_user_impact --实现此缺失索引组后，用户查询可能获得的平均百分比收益。 该值表示如果实现此缺失索引组，则查询成本将按此百分比平均下降。FROM sys.dm_db_missing_index_details AS ddmidJOIN sys.dm_db_missing_index_groups AS ddmigON ddmid.index_handle=ddmig.index_handleJOIN sys.dm_db_missing_index_group_stats AS ddmigsON ddmig.index_group_handle=ddmigs.group_handle参考资料 sys.dm_db_missing_index_details sys.dm_db_missing_index_group_stats" }, { "title": "Emit克隆和反射克隆性能对比", "url": "/post/Emit%E5%85%8B%E9%9A%86%E5%92%8C%E5%8F%8D%E5%B0%84%E5%85%8B%E9%9A%86%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94", "categories": "dotnet, csharp", "tags": "", "date": "2020-07-07 19:14:08 +0800", "snippet": "如果少量使用(&amp;lt;100次)或对性能不敏感可以直接用反射，否则使用IL方式测试代码 要克隆的类型含有200个属性，100个int，100个stringpublic class Person{ #region Name public int Age0 { get; set; } = 0; public int Age1 { get; set; } = 1; public int Age2 { get; set; } = 2; public int Age3 { get; set; } = 3; public int Age4 { get; set; } = 4; public int Age5 { get; set; } = 5; public int Age6 { get; set; } = 6; public int Age7 { get; set; } = 7; public int Age8 { get; set; } = 8; public int Age9 { get; set; } = 9; public int Age10 { get; set; } = 10; public int Age11 { get; set; } = 11; public int Age12 { get; set; } = 12; public int Age13 { get; set; } = 13; public int Age14 { get; set; } = 14; public int Age15 { get; set; } = 15; public int Age16 { get; set; } = 16; public int Age17 { get; set; } = 17; public int Age18 { get; set; } = 18; public int Age19 { get; set; } = 19; public int Age20 { get; set; } = 20; public int Age21 { get; set; } = 21; public int Age22 { get; set; } = 22; public int Age23 { get; set; } = 23; public int Age24 { get; set; } = 24; public int Age25 { get; set; } = 25; public int Age26 { get; set; } = 26; public int Age27 { get; set; } = 27; public int Age28 { get; set; } = 28; public int Age29 { get; set; } = 29; public int Age30 { get; set; } = 30; public int Age31 { get; set; } = 31; public int Age32 { get; set; } = 32; public int Age33 { get; set; } = 33; public int Age34 { get; set; } = 34; public int Age35 { get; set; } = 35; public int Age36 { get; set; } = 36; public int Age37 { get; set; } = 37; public int Age38 { get; set; } = 38; public int Age39 { get; set; } = 39; public int Age40 { get; set; } = 40; public int Age41 { get; set; } = 41; public int Age42 { get; set; } = 42; public int Age43 { get; set; } = 43; public int Age44 { get; set; } = 44; public int Age45 { get; set; } = 45; public int Age46 { get; set; } = 46; public int Age47 { get; set; } = 47; public int Age48 { get; set; } = 48; public int Age49 { get; set; } = 49; public int Age50 { get; set; } = 50; public int Age51 { get; set; } = 51; public int Age52 { get; set; } = 52; public int Age53 { get; set; } = 53; public int Age54 { get; set; } = 54; public int Age55 { get; set; } = 55; public int Age56 { get; set; } = 56; public int Age57 { get; set; } = 57; public int Age58 { get; set; } = 58; public int Age59 { get; set; } = 59; public int Age60 { get; set; } = 60; public int Age61 { get; set; } = 61; public int Age62 { get; set; } = 62; public int Age63 { get; set; } = 63; public int Age64 { get; set; } = 64; public int Age65 { get; set; } = 65; public int Age66 { get; set; } = 66; public int Age67 { get; set; } = 67; public int Age68 { get; set; } = 68; public int Age69 { get; set; } = 69; public int Age70 { get; set; } = 70; public int Age71 { get; set; } = 71; public int Age72 { get; set; } = 72; public int Age73 { get; set; } = 73; public int Age74 { get; set; } = 74; public int Age75 { get; set; } = 75; public int Age76 { get; set; } = 76; public int Age77 { get; set; } = 77; public int Age78 { get; set; } = 78; public int Age79 { get; set; } = 79; public int Age80 { get; set; } = 80; public int Age81 { get; set; } = 81; public int Age82 { get; set; } = 82; public int Age83 { get; set; } = 83; public int Age84 { get; set; } = 84; public int Age85 { get; set; } = 85; public int Age86 { get; set; } = 86; public int Age87 { get; set; } = 87; public int Age88 { get; set; } = 88; public int Age89 { get; set; } = 89; public int Age90 { get; set; } = 90; public int Age91 { get; set; } = 91; public int Age92 { get; set; } = 92; public int Age93 { get; set; } = 93; public int Age94 { get; set; } = 94; public int Age95 { get; set; } = 95; public int Age96 { get; set; } = 96; public int Age97 { get; set; } = 97; public int Age98 { get; set; } = 98; public int Age99 { get; set; } = 99; public string Name0 { get; set; } = &quot;name0&quot;; public string Name1 { get; set; } = &quot;name1&quot;; public string Name2 { get; set; } = &quot;name2&quot;; public string Name3 { get; set; } = &quot;name3&quot;; public string Name4 { get; set; } = &quot;name4&quot;; public string Name5 { get; set; } = &quot;name5&quot;; public string Name6 { get; set; } = &quot;name6&quot;; public string Name7 { get; set; } = &quot;name7&quot;; public string Name8 { get; set; } = &quot;name8&quot;; public string Name9 { get; set; } = &quot;name9&quot;; public string Name10 { get; set; } = &quot;name10&quot;; public string Name11 { get; set; } = &quot;name11&quot;; public string Name12 { get; set; } = &quot;name12&quot;; public string Name13 { get; set; } = &quot;name13&quot;; public string Name14 { get; set; } = &quot;name14&quot;; public string Name15 { get; set; } = &quot;name15&quot;; public string Name16 { get; set; } = &quot;name16&quot;; public string Name17 { get; set; } = &quot;name17&quot;; public string Name18 { get; set; } = &quot;name18&quot;; public string Name19 { get; set; } = &quot;name19&quot;; public string Name20 { get; set; } = &quot;name20&quot;; public string Name21 { get; set; } = &quot;name21&quot;; public string Name22 { get; set; } = &quot;name22&quot;; public string Name23 { get; set; } = &quot;name23&quot;; public string Name24 { get; set; } = &quot;name24&quot;; public string Name25 { get; set; } = &quot;name25&quot;; public string Name26 { get; set; } = &quot;name26&quot;; public string Name27 { get; set; } = &quot;name27&quot;; public string Name28 { get; set; } = &quot;name28&quot;; public string Name29 { get; set; } = &quot;name29&quot;; public string Name30 { get; set; } = &quot;name30&quot;; public string Name31 { get; set; } = &quot;name31&quot;; public string Name32 { get; set; } = &quot;name32&quot;; public string Name33 { get; set; } = &quot;name33&quot;; public string Name34 { get; set; } = &quot;name34&quot;; public string Name35 { get; set; } = &quot;name35&quot;; public string Name36 { get; set; } = &quot;name36&quot;; public string Name37 { get; set; } = &quot;name37&quot;; public string Name38 { get; set; } = &quot;name38&quot;; public string Name39 { get; set; } = &quot;name39&quot;; public string Name40 { get; set; } = &quot;name40&quot;; public string Name41 { get; set; } = &quot;name41&quot;; public string Name42 { get; set; } = &quot;name42&quot;; public string Name43 { get; set; } = &quot;name43&quot;; public string Name44 { get; set; } = &quot;name44&quot;; public string Name45 { get; set; } = &quot;name45&quot;; public string Name46 { get; set; } = &quot;name46&quot;; public string Name47 { get; set; } = &quot;name47&quot;; public string Name48 { get; set; } = &quot;name48&quot;; public string Name49 { get; set; } = &quot;name49&quot;; public string Name50 { get; set; } = &quot;name50&quot;; public string Name51 { get; set; } = &quot;name51&quot;; public string Name52 { get; set; } = &quot;name52&quot;; public string Name53 { get; set; } = &quot;name53&quot;; public string Name54 { get; set; } = &quot;name54&quot;; public string Name55 { get; set; } = &quot;name55&quot;; public string Name56 { get; set; } = &quot;name56&quot;; public string Name57 { get; set; } = &quot;name57&quot;; public string Name58 { get; set; } = &quot;name58&quot;; public string Name59 { get; set; } = &quot;name59&quot;; public string Name60 { get; set; } = &quot;name60&quot;; public string Name61 { get; set; } = &quot;name61&quot;; public string Name62 { get; set; } = &quot;name62&quot;; public string Name63 { get; set; } = &quot;name63&quot;; public string Name64 { get; set; } = &quot;name64&quot;; public string Name65 { get; set; } = &quot;name65&quot;; public string Name66 { get; set; } = &quot;name66&quot;; public string Name67 { get; set; } = &quot;name67&quot;; public string Name68 { get; set; } = &quot;name68&quot;; public string Name69 { get; set; } = &quot;name69&quot;; public string Name70 { get; set; } = &quot;name70&quot;; public string Name71 { get; set; } = &quot;name71&quot;; public string Name72 { get; set; } = &quot;name72&quot;; public string Name73 { get; set; } = &quot;name73&quot;; public string Name74 { get; set; } = &quot;name74&quot;; public string Name75 { get; set; } = &quot;name75&quot;; public string Name76 { get; set; } = &quot;name76&quot;; public string Name77 { get; set; } = &quot;name77&quot;; public string Name78 { get; set; } = &quot;name78&quot;; public string Name79 { get; set; } = &quot;name79&quot;; public string Name80 { get; set; } = &quot;name80&quot;; public string Name81 { get; set; } = &quot;name81&quot;; public string Name82 { get; set; } = &quot;name82&quot;; public string Name83 { get; set; } = &quot;name83&quot;; public string Name84 { get; set; } = &quot;name84&quot;; public string Name85 { get; set; } = &quot;name85&quot;; public string Name86 { get; set; } = &quot;name86&quot;; public string Name87 { get; set; } = &quot;name87&quot;; public string Name88 { get; set; } = &quot;name88&quot;; public string Name89 { get; set; } = &quot;name89&quot;; public string Name90 { get; set; } = &quot;name90&quot;; public string Name91 { get; set; } = &quot;name91&quot;; public string Name92 { get; set; } = &quot;name92&quot;; public string Name93 { get; set; } = &quot;name93&quot;; public string Name94 { get; set; } = &quot;name94&quot;; public string Name95 { get; set; } = &quot;name95&quot;; public string Name96 { get; set; } = &quot;name96&quot;; public string Name97 { get; set; } = &quot;name97&quot;; public string Name98 { get; set; } = &quot;name98&quot;; public string Name99 { get; set; } = &quot;name99&quot;; #endregion} 测试代码static void Main(string[] args){ var length = 100; var sw = Stopwatch.StartNew(); var person = new Person(); var person2 = new Person(); for (int i = 0; i &amp;lt; length; i++) { Clone.CloneObjectWithIL(person, person2); } sw.Stop(); Console.WriteLine(&quot;IL:&quot; + sw.ElapsedMilliseconds); sw.Restart(); for (int i = 0; i &amp;lt; length; i++) { Clone.CloneWithReflection(person, person2); } sw.Stop(); Console.WriteLine(&quot;Ref:&quot; + sw.ElapsedMilliseconds);}克隆实现/// &amp;lt;summary&amp;gt;/// 提供快速的对象深复制/// &amp;lt;/summary&amp;gt;public static class Clone{ /// &amp;lt;summary&amp;gt; /// 提供使用 IL 的方式快速对象深复制 /// 要求本方法具有T可访问 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;source&quot;&amp;gt;源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;los&quot;&amp;gt;从源复制属性&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&quot;MethodAccessException&quot;&amp;gt;如果输入的T没有本方法可以访问，那么就会出现这个异常&amp;lt;/exception&amp;gt; // ReSharper disable once InconsistentNaming public static void CloneObjectWithIL&amp;lt;T&amp;gt;(T source, T los) { CloneObjectWithIL(source, los, new string[] { }); } public static void CloneObjectWithIL&amp;lt;T&amp;gt;(T source, T los, string[] ignorePropertyNames) { //参见 http://lindexi.oschina.io/lindexi/post/C-%E4%BD%BF%E7%94%A8Emit%E6%B7%B1%E5%85%8B%E9%9A%86/ if (CachedIl.ContainsKey(typeof(T))) { ((Action&amp;lt;T, T&amp;gt;)CachedIl[typeof(T)])(source, los); return; } var dynamicMethod = new DynamicMethod(&quot;Clone&quot;, null, new[] { typeof(T), typeof(T) }); ILGenerator generator = dynamicMethod.GetILGenerator(); foreach (var temp in typeof(T) .GetProperties(BindingFlags.Instance | BindingFlags.Public) .Where(temp =&amp;gt; temp.CanRead &amp;amp;&amp;amp; temp.CanWrite)) { //不复制静态类属性 if (temp.GetAccessors(true)[0].IsStatic || ignorePropertyNames.Contains(temp.Name)) { continue; } generator.Emit(OpCodes.Ldarg_1);// los generator.Emit(OpCodes.Ldarg_0);// s generator.Emit(OpCodes.Callvirt, temp.GetMethod); generator.Emit(OpCodes.Callvirt, temp.SetMethod); } generator.Emit(OpCodes.Ret); var clone = (Action&amp;lt;T, T&amp;gt;)dynamicMethod.CreateDelegate(typeof(Action&amp;lt;T, T&amp;gt;)); CachedIl[typeof(T)] = clone; clone(source, los); } public static T CloneObjectWithIL&amp;lt;T&amp;gt;(T myObject) { Delegate myExec; if (!CachedIl.TryGetValue(typeof(T), out myExec)) { // Create ILGenerator DynamicMethod dymMethod = new DynamicMethod(&quot;DoClone&quot;, typeof(T), new Type[] { typeof(T) }, true); ConstructorInfo cInfo = myObject.GetType().GetConstructor(new Type[] { }); ILGenerator generator = dymMethod.GetILGenerator(); LocalBuilder lbf = generator.DeclareLocal(typeof(T)); //lbf.SetLocalSymInfo(&quot;_temp&quot;); generator.Emit(OpCodes.Newobj, cInfo); generator.Emit(OpCodes.Stloc_0); foreach (FieldInfo field in myObject.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { // Load the new object on the eval stack... (currently 1 item on eval stack) generator.Emit(OpCodes.Ldloc_0); // Load initial object (parameter) (currently 2 items on eval stack) generator.Emit(OpCodes.Ldarg_0); // Replace value by field value (still currently 2 items on eval stack) generator.Emit(OpCodes.Ldfld, field); // Store the value of the top on the eval stack into the object underneath that value on the value stack. // (0 items on eval stack) generator.Emit(OpCodes.Stfld, field); } // Load new constructed obj on eval stack -&amp;gt; 1 item on stack generator.Emit(OpCodes.Ldloc_0); // Return constructed object. --&amp;gt; 0 items on stack generator.Emit(OpCodes.Ret); myExec = dymMethod.CreateDelegate(typeof(Func&amp;lt;T, T&amp;gt;)); CachedIl.Add(typeof(T), myExec); } return ((Func&amp;lt;T, T&amp;gt;)myExec)(myObject); } private static Dictionary&amp;lt;Type, Delegate&amp;gt; CachedIl { set; get; } = new Dictionary&amp;lt;Type, Delegate&amp;gt;(); public static void CloneWithReflection&amp;lt;T, E&amp;gt;(this T source, E los, params string[] methods) { var listMethods = new List&amp;lt;string&amp;gt;(); listMethods.AddRange(methods); if (source == null || los == null) { throw new Exception(&quot; iLIS.Common Clone扩展方法 参数克隆者与被克隆者参数不能为Null类型调用对象&quot; + typeof(T).FullName + &quot;参数对象&quot; + typeof(E).FullName); } var tps = typeof(T).GetProperties(); var eps = typeof(E).GetProperties(); foreach (var tp in tps) { if (listMethods != null &amp;amp;&amp;amp; listMethods.Contains(tp.Name)) { continue; } var ep = eps.FirstOrDefault(a =&amp;gt; a.Name == tp.Name); if (ep != null) { var value = ep.GetValue(los, null); if (TypeHelper.GetTargetType(ep.PropertyType).FullName != TypeHelper.GetTargetType(tp.PropertyType).FullName) { throw new Exception(&quot;需要复制对象&quot; + typeof(T).FullName + &quot;的&quot; + tp.Name + &quot;的属性与数据源对象&quot; + typeof(E).FullName + &quot;的&quot; + ep.Name + &quot;属性的类型不一样&quot;); } if (value != null &amp;amp;&amp;amp; tp.CanWrite) { tp.SetValue(source, value, null); } } } }}public class TypeHelper{ public static object ChangeType(string str, Type basicType) { if (basicType == typeof(string)) return str; if (string.IsNullOrEmpty(str)) return GetBasicTypeDefaultValue(basicType); var targetType = GetTargetType(basicType); if (targetType == typeof(Guid)) { return Guid.Parse(str); } if (targetType.IsEnum) { return Enum.Parse(targetType, str); } return Convert.ChangeType(str, targetType); } public static object GetBasicTypeDefaultValue(Type basicType) { if (IsNullableType(basicType)) return null; if (basicType == typeof(int) || basicType == typeof(uint) || basicType == typeof(byte) || basicType == typeof(sbyte) || basicType == typeof(long) || basicType == typeof(ulong) || basicType == typeof(float) || basicType == typeof(double) || basicType == typeof(decimal) ) { return 0; } else if (basicType == typeof(bool)) { return false; } else if (basicType == typeof(DateTime?)) { return null; } throw new NotSupportedException(string.Format(&quot;无法获取类型{0}的默认值&quot;, basicType.FullName)); } public static Type GetTargetType(Type basicType) { var targetType = basicType; if (IsNullableType(basicType)) { targetType = basicType.GetGenericArguments()[0]; } return targetType; } /// &amp;lt;summary&amp;gt; /// 是否为可空类型。如：int? /// &amp;lt;/summary&amp;gt; public static bool IsNullableType(Type theType) { return (theType.IsGenericType &amp;amp;&amp;amp; theType.GetGenericTypeDefinition() == typeof(Nullable&amp;lt;&amp;gt;)); }}参考资料 C#使用Emit深克隆" }, { "title": "c#引用不同版本dll(转载)", "url": "/post/c-%E5%BC%95%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACdll", "categories": "dotnet, csharp", "tags": "", "date": "2020-07-01 19:14:08 +0800", "snippet": "因为经常会用到不同项目引用了相同dll的不同版本，所以记录一下，免得每次去百度原文地址：引用不同版本dll问题描述一个项目引用不同版本的同一dll，会引发以下报错：未能加载文件或程序集“xxx, Version=x.x.x.x, Culture=neutral, PublicKeyToken=xxxxxxxxxxxx”或它的某一个依赖项。系统找不到指定的文件这里来解决项目中同一dll的多版本问题。解决方式通过配置web.config配置文件（app.config或web.config）增加配置节点不同场景有不同的解决方式，下面说明 场景一 以高版本兼容例如：新旧项目都引用Newtonsoft.Json,但是不同版本。需要以最高版本兼容。&amp;lt;runtime&amp;gt; &amp;lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot; publicKeyToken=&quot;30AD4FE6B2A6AEED&quot; culture=&quot;neutral&quot;/&amp;gt; &amp;lt;bindingRedirect oldVersion=&quot;0.0.0.0-6.0.0.0&quot; newVersion=&quot;6.0.0.0&quot;/&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/assemblyBinding&amp;gt;&amp;lt;/runtime&amp;gt; 场景二 同一dll两种版本共存例如：项目自己引用log4net.dll 版本1.2.13.0 。添加第三方某个dll，第三方依赖log4net.dll版本1.2.9.0，项目中需要两种版本共存。这里还分两种情况，dll的publicKeyToken相同还是不同 （publicKeyToken查询见说明1）publicKeyToken相同，配置方法：&amp;lt;runtime&amp;gt; &amp;lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;log4net&quot; publicKeyToken=&quot;669e0ddf0bb1aa2a&quot; /&amp;gt; &amp;lt;codeBase version=&quot;1.2.13.0&quot; href=&quot;bin\\log4netdll\\1_2_13\\log4net.dll&quot; /&amp;gt; &amp;lt;codeBase version=&quot;1.2.9.0&quot; href=&quot;bin\\log4netdll\\1_2_9\\log4net.dll&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/assemblyBinding&amp;gt;&amp;lt;/runtime&amp;gt;publicKeyToken不同，配置方法：&amp;lt;runtime&amp;gt; &amp;lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;log4net&quot; publicKeyToken=&quot;669e0ddf0bb1aa2a&quot; /&amp;gt; &amp;lt;codeBase version=&quot;1.2.13.0&quot; href=&quot;bin\\log4netdll\\1_2_13\\log4net.dll&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;log4net&quot; publicKeyToken=&quot;b32731d11ce58905&quot; /&amp;gt; &amp;lt;codeBase version=&quot;1.2.9.0&quot; href=&quot;bin\\log4netdll\\1_2_9\\log4net.dll&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/assemblyBinding&amp;gt;&amp;lt;/runtime&amp;gt;说明1.publicKeyToken获取方式：使用vs的Tools Command Prompt命令行工具，输入:SN -T “path”,例如：C:\\Program Files (x86)\\Microsoft Visual Studio 11.0&amp;gt;SN -T &quot;D:\\project\\liberary\\External\\log4net.dll&quot;Microsoft(R) .NET Framework 强名称实用工具 版本 4.0.30319.17929版权所有(C) Microsoft Corporation。保留所有权利。公钥标记为 b32731d11ce58905" }, { "title": "AbpJwt授权码加密方式改为RS256", "url": "/post/AbpJwt%E6%8E%88%E6%9D%83%E7%A0%81%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%94%B9%E4%B8%BARS256", "categories": "Abp, dotnet, csharp", "tags": "", "date": "2020-07-01 19:14:08 +0800", "snippet": "我们自己的内部的几个系统做了单点登录（类似与第三方登录），从一个系统跳转到另一个系统时不需要再次登录，以前是把生成的token的SecurityKey直接复制到另一个系统然后验证token的，但是这样其他系统也可以使用SecurityKey生成token，安全性有一定问题，最近发现jwt加密方式可以改为rs256，这样就验证登录的系统就只需要公钥pubkey，而私钥prikey只会掌握到生成token的系统中。修改SecurityKey类型修改TokenAuthConfiguration类中的SecurityKey的类型为SecurityKeypublic class TokenAuthConfiguration{-- public SymmetricSecurityKey SecurityKey { get; set; }++ public SecurityKey SecurityKey { get; set; } public string Issuer { get; set; } public string Audience { get; set; } public SigningCredentials SigningCredentials { get; set; } public TimeSpan Expiration { get; set; }}修改加密方式示例中我直接把公钥和私钥写在变量中了，应该放在配置文件中，注意公钥和私钥的长度至少为2048否则生成token会报错。System.NotSupportedException HResult=0x80131515 Message=IDX10634: Unable to create the SignatureProvider. Algorithm: &#39;[PII is hidden by default. Set the &#39;ShowPII&#39; flag in IdentityModelEventSource.cs to true to reveal it.]&#39;, SecurityKey: &#39;[PII is hidden by default. Set the &#39;ShowPII&#39; flag in IdentityModelEventSource.cs to true to reveal it.]&#39; is not supported.修改XXXWebCoreModule中的ConfigureTokenAuth方法private void ConfigureTokenAuth(){ IocManager.Register&amp;lt;TokenAuthConfiguration&amp;gt;(); var tokenAuthConfig = IocManager.Resolve&amp;lt;TokenAuthConfiguration&amp;gt;();++ var pubKey = &quot;BgIAAACkAABSU0ExAAgAAAEAAQBtxB/X/mfyaWT+ZTqmfy3yKODczEpPuC+2xP8L98kU+ZRzBzx/ZNTiVbjiD3ypNE2a1KxUGXgBz6yRxUM8xHoWrAV9TrcuHX+vObkClaqTcw93KJH0xYaKjaRvrHfyR/F+vzyZHQqNXOL3hgploaJPvyVGLqwDdPL/XM1u9heBZVLEicMBcT/khJq0cbRjT4sjcV6sCg5JGYwrdjgJ3eXuXJjc/+FwVF/DErLibP5POadZptpg+YlN3zo4DRIj0gou4hUK/lbJ3Pi9OT21izB2ncE0VdDcZpPkqBkdEwxBfkHezquhBLMhwvNkMml1gF4pXVYHeCuY1IYdGK+BTFvW&quot;;++ var priKey = &quot;BwIAAACkAABSU0EyAAgAAAEAAQBtxB/X/mfyaWT+ZTqmfy3yKODczEpPuC+2xP8L98kU+ZRzBzx/ZNTiVbjiD3ypNE2a1KxUGXgBz6yRxUM8xHoWrAV9TrcuHX+vObkClaqTcw93KJH0xYaKjaRvrHfyR/F+vzyZHQqNXOL3hgploaJPvyVGLqwDdPL/XM1u9heBZVLEicMBcT/khJq0cbRjT4sjcV6sCg5JGYwrdjgJ3eXuXJjc/+FwVF/DErLibP5POadZptpg+YlN3zo4DRIj0gou4hUK/lbJ3Pi9OT21izB2ncE0VdDcZpPkqBkdEwxBfkHezquhBLMhwvNkMml1gF4pXVYHeCuY1IYdGK+BTFvW/xoSKQLnwF8DIiHM4waMUUjP+CUA20Xb1KqKsa05KASzK96M0QvBb9wqW0hnvYzkNHegScRNwqRbvVV7+IFKEFYxXgIZ6Mj+tpdk75OinC3RvCxuSbektX1WkyNXar+hqZoQ+ScM4+7Gc6cHCKC1/zgz1yUOiMrwSmuxMNGzN/aTvBmta1y06Kx7KmBfcJY8iP6UoCntiaAMbQryJnmuOupze9JdrVA9abjZ8hDiZf0ndV9WbBXtyUXzkENuKpmLRan3qnlWUApjx2kh8jUecc40W6+NFSbEQ7h/2ZrgYqRF/zSfL9fLBAWhXR1S4ezWQ4d6MAsDyxFroCu5S4nf3hdIawk6rsHOR4TMP/UGrBViyaPGc2T2qPOpgpp/Wk3CtJ3g7C37R+Vl8N40fdK22fuFN79RTn51RmnEK9ZDwXgrduVKyPhua49rawlvR+MqxG9Agmj7huW27DsIWoU1WJ3LiMoT2BkRy8DKDOpSfFJpJfShdwLY12K2RxoBZUeCm3sd8Nn5t8PbeYrtPmh+d1MYKvE/62nljKRJ7UuhrEdtHV+Fk5HKsfEGsShgaNvcZlOZxFlEdKFOQFhInmxDKvx4clGdCU8J0lui5YyfHQbe76JqMlAfqbCJaLcDv73Oe8dHlznLELXe0SVrGdY+Jla7880eoJTWNMj29sxJvix+38FT2ZfYnbBKGnS758UPG6TDQSdvPi9YT8TNczYT1bcI1CJVG+x/m3pGv/gLUjx8yA8jBD+SP8GviJ1c8nfHGTD1oAo9BobSfCqrbfGoyX1tyFXwYRg9OEGRsQ7TQKxyqdDjcONjQeQAcWxtO4z+5DExBwFSmITOpd0laJzy3L2HCDZnnv4KPmMPfG8F72q8pZCu1s5eLA+DIBQz9zSntNvAsH+4PV5w4mhiU1SO6roU57uAuNDX0hwCybrzDREaTpVI/S2DXrFxQ4tBJwlnjgqFFZ4ki0OUiuyIHODChiDd6QVkuTPu3ARtOIrH2oR+4TmYs9f6q+J3daFxYhJSGDiIoAn5XJpxEdUg7oRNmXcDEp6Tq/sv7iS02LAz9uc5fLDsNGHj/N0eECZZgOfyWKVeLMIFvb+ssjrBGuW/LrcidP8PXfD3SixEgd7Uf5QMM6GM+0Qgek62oW5iyTHG/FFKQXdgeXFUIt6Fvv+B/In+nPY2O5ZVuaGeGC6xOUw=&quot;;++ var rsaPri = new System.Security.Cryptography.RSACryptoServiceProvider();++ rsaPri.ImportCspBlob(Convert.FromBase64String(priKey));++ tokenAuthConfig.SecurityKey = new RsaSecurityKey(rsaPri);-- tokenAuthConfig.SecurityKey =-- new SymmetricSecurityKey(-- Encoding.ASCII.GetBytes(_appConfiguration[&quot;Authentication:JwtBearer:SecurityKey&quot;])); tokenAuthConfig.Issuer = _appConfiguration[&quot;Authentication:JwtBearer:Issuer&quot;]; tokenAuthConfig.Audience = _appConfiguration[&quot;Authentication:JwtBearer:Audience&quot;];++ tokenAuthConfig.SigningCredentials =new SigningCredentials(tokenAuthConfig.SecurityKey, SecurityAlgorithms.RsaSha256);-- tokenAuthConfig.SigningCredentials =-- new SigningCredentials(tokenAuthConfig.SecurityKey, SecurityAlgorithms.HmacSha256); tokenAuthConfig.Expiration = TimeSpan.FromDays(1);}修改abp验证token方式修改了生成token的加密方式还必须修改验证token的方式，修改AuthConfigurer文件中的Configure方法--IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(configuration[&quot;Authentication:JwtBearer:SecurityKey&quot;])),++IssuerSigningKey = new RsaSecurityKey(rsaPri),第三方验证这样生成的token就是采用rs256加密的了，验证的时候只需要使用公钥就行了为了简便可以直接使用jwt包验证下install-package JWTRSACryptoServiceProvider rsaPub = new RSACryptoServiceProvider();rsaPub.ImportCspBlob(Convert.FromBase64String(pubKey));var json = new JwtBuilder().WithAlgorithm(new RS256Algorithm(rsaPub)) // symmetric.MustVerifySignature().Decode(token);Console.WriteLine(json);" }, { "title": "WebRequest下载文件", "url": "/post/WebRequest%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6", "categories": "CSharp, Http, Web, WebRequest", "tags": "", "date": "2020-06-29 19:14:08 +0800", "snippet": "WebRequest下载文件上代码private void DownloadFile(string fileUrl, string filename){ try { var request = WebRequest.Create(fileUrl); var response = request.GetResponse(); using (var responseStream = response.GetResponseStream()) { var readedSize = 0L; using (var fs = new FileStream(filename, FileMode.Create)) { var buffer = new byte[1024 * 500]; var readSize = responseStream.Read(buffer, 0, buffer.Length); while (readSize &amp;gt; 0) { fs.Write(buffer, 0, readSize); readSize = responseStream.Read(buffer, 0, buffer.Length); readedSize += readSize; } } } response.Close(); } catch (WebException ex) { var rsp = ex.Response as HttpWebResponse; if (rsp != null &amp;amp;&amp;amp; rsp.StatusCode == HttpStatusCode.NotFound) { throw new FileNotFoundException(fileUrl); } else { throw ex; } }}" }, { "title": "SilverLight类似WinForm弹窗等待结果再继续执行", "url": "/post/SilverLight%E7%B1%BB%E4%BC%BCWinForm%E5%BC%B9%E7%AA%97%E7%AD%89%E5%BE%85%E7%BB%93%E6%9E%9C%E5%86%8D%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C", "categories": "CSharp, Http, Web, SilverLight", "tags": "", "date": "2020-06-29 19:14:08 +0800", "snippet": "在开发SilverLight时，弹窗一直都是用的回调方式，比如需要用户确认才能继续操作的，如果有好几个确认步骤，这时候回调函数就比较深了，代码基本看不懂，可以使用TaskCompletionSource把事件改为异步等待方法，全部改成同步的写法，爽的飞起。关键代码[Flags]public enum MsgBoxButton{ Ok = 1, YesNo = 2, OkCancel = 4, YesNoCancel = 8, //图标 IconInfo = 16, IconWarn = 32, IconQuestion = 64, IconError = 128,}public static Task&amp;lt;System.Windows.MessageBoxResult&amp;gt; ShowAsync(string message, string title, MsgBoxButton buttons){ var taskResult = new TaskCompletionSource&amp;lt;System.Windows.MessageBoxResult&amp;gt;(); MsgBoxWindow messageBox = new MsgBoxWindow();//这是一个ChildWindow，只是自定义了一些样式和加了一些按钮：Yes、no、OK等，仿照winform messageBox.generateButtons(buttons); messageBox.Title = string.IsNullOrEmpty(title) ? &quot;系统提示&quot; : title; messageBox.Message = message; messageBox.MessageTextBlock.Width = twidth; messageBox.Closed += (ss, ee) =&amp;gt; { //异步等待关键代码，只有SetResult后，await才会继续执行 taskResult.SetResult(messageBox._msgBoxResult);//根据点击按钮转换成了System.Windows.MessageBoxResult枚举结果 }; messageBox.Show(); return taskResult.Task;}//创建按钮时在点击按钮事件中设置对应的结果private void createOkButton(){ if (_okButton != null) return; _okButton = new Button { Content = &quot;确定&quot;, Width = 75, Margin = new Thickness(2) }; _okButton.Click += (sender, args) =&amp;gt; { this._msgBoxResult = MessageBoxResult.OK; DialogResult = true; };}这样使用var result = await MsgBoxWindow.ShowAsync(&quot;点吧&quot;, &quot;店不大&quot;, MsgBoxButton.YesNo);MessageBox.Show(result.ToString());var result2 = await MsgBoxWindow.ShowAsync(&quot;点吧2&quot;, &quot;店不大2&quot;, MsgBoxButton.YesNo);MessageBox.Show(result2.ToString());再也不需要这样了MsgBoxWindow.Show(&quot;点吧&quot;, &quot;店不大&quot;, MsgBoxButton.YesNo, rs =&amp;gt; { MessageBox.Show(rs.ToString()); MsgBoxWindow.Show(&quot;点吧2&quot;, &quot;店不大2&quot;, MsgBoxButton.YesNo, rs2 =&amp;gt; { MessageBox.Show(rs2.ToString()); });});参考资料 C# dotnet 使用 TaskCompletionSource 让事件转异步方法" }, { "title": "查询所有数据库及文件", "url": "/post/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E6%96%87%E4%BB%B6", "categories": "Sql", "tags": "", "date": "2020-06-24 19:14:08 +0800", "snippet": "查询所有数据库及文件上代码select * from master.sys.master_filesselect a.name,b.physical_name FROM sys.sysdatabases a,master.sys.master_files b WHERE a.dbid = b.database_id" }, { "title": "收缩数据库日志文件", "url": "/post/%E6%94%B6%E7%BC%A9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6", "categories": "Sql", "tags": "", "date": "2020-06-24 19:14:08 +0800", "snippet": "上代码USE [master]GOALTER DATABASE dbName SET RECOVERY SIMPLE WITH NO_WAITGOALTER DATABASE dbName SET RECOVERY SIMPLE --简单模式GOUSE dbNameGODBCC SHRINKFILE (N&#39;DNName_Log&#39; , 11, TRUNCATEONLY) GO --这里的DNName_Log 如果不知道在sys.database_files里是什么名字的话，可以用以下注释的语句进行查询USE dbNameGOSELECT file_id, name FROM sys.database_files;GOUSE [master]GOALTER DATABASE dbName SET RECOVERY FULL WITH NO_WAITGOALTER DATABASE dbName SET RECOVERY FULL --还原为完全模式GO" }, { "title": "使用Razor引擎模板生成字符串", "url": "/post/%E4%BD%BF%E7%94%A8Razor%E5%BC%95%E6%93%8E%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2", "categories": "html, dotnet, csharp", "tags": "", "date": "2020-06-24 19:14:08 +0800", "snippet": "使用Razor引擎模板生成字符串，类似于T4模板，T4要学语法，Razor就是就用c#了用处：代码生成器安装依赖包Install-Package RazorEngine.NetCore生成代码class Program{ static void Main(string[] args) { //简单使用 string template = &quot;Hello @Model.Name, welcome to RazorEngine!&quot;; var result = Engine.Razor.RunCompile(template, &quot;templateKey&quot;, null, new { Name = &quot;World&quot; }); Console.WriteLine(result); //带html标签 string template1 = &quot;@Raw(Model.Data)&quot;; var model1 = new { Data = &quot;My raw double quotes &amp;lt;p&amp;gt;appears&amp;lt;/p&amp;gt; here \\&quot;hello!\\&quot;&quot; }; string result1 = Engine.Razor.RunCompile(template1, &quot;templateKey1&quot;, null, model1); Console.WriteLine(result1); //使用模板文件 string filePath = &quot;StudentTemplate.cshtml&quot;; var userTemplate= File.ReadAllText(filePath); string result2= Engine.Razor.RunCompile(userTemplate, Guid.NewGuid().ToString(), typeof(User), new User { CreateTime = DateTime.Now, EmailAddress = &quot;&amp;lt;p&amp;gt;125880321@qq.com&amp;lt;/p&amp;gt;&quot;, UserName = &quot;IGeekFan&quot; }); Console.WriteLine(result2); }}public class User{ public string UserName { get; set; } public string EmailAddress { get; set; } public DateTime CreateTime { get; set; }}cshtml模板@{ var gen = Model as RazorTemplate.User;}//=============================================================// 创建人: @gen.UserName// 创建时间: @gen.CreateTime// 邮箱： @gen.EmailAddress//==============================================================&amp;lt;h1&amp;gt;123&amp;lt;/h1&amp;gt;@Raw(&quot;&amp;lt;a&amp;gt;www.baidu.com&amp;lt;a&amp;gt;&quot;)运行截图参考资料 FreeSql.Generator命令行代码生成器是如何实现的 RazorEngine issues with @Html" }, { "title": "httpclient下载文件", "url": "/post/httpclient%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6", "categories": "CSharp, Http, Web, HttpClient", "tags": "", "date": "2020-06-24 19:14:08 +0800", "snippet": "httpclient下载文件上代码private async Task&amp;lt;string&amp;gt; DownLoadFileAsync(string url){ var handler = new HttpClientHandler() { UseCookies = true }; var client = HttpClientFactory.Create(handler); client.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, @&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0&quot;);//添加自主驱动 很重要，没细研究，确实添加上就能下载文件 client.DefaultRequestHeaders.Add(&quot;Accept&quot;, @&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;);//添加数据格式 byte[] bytes = null; bytes = await client.GetByteArrayAsync(url); var tplfile = $&quot;c:/{Guid.NewGuid()}{Path.GetExtension(url)}&quot;; using (var fs = new System.IO.FileStream(tplfile, FileMode.CreateNew)) { fs.Write(bytes, 0, bytes.Length); fs.Close(); } return tplfile;}" }, { "title": "webApi返回文件流", "url": "/post/webApi%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81", "categories": "webApi, dotnet, csharp", "tags": "", "date": "2020-06-19 19:14:08 +0800", "snippet": "webApi返回文件流定义返回结果[DataContract]public class FileStreamResult : IHttpActionResult{ readonly Stream _stream; readonly string _mediaType; readonly string _fileName; public FileStreamResult(Stream stream, string mediaType) : this(stream, mediaType, null) { } public FileStreamResult(Stream stream, string mediaType, string fileName) { _stream = stream; _mediaType = mediaType; _fileName = fileName; } public Task&amp;lt;HttpResponseMessage&amp;gt; ExecuteAsync(CancellationToken cancellationToken) { return Task.FromResult(Execute()); } private HttpResponseMessage Execute() { HttpResponseMessage httpResponseMessage = new HttpResponseMessage(HttpStatusCode.OK); try { httpResponseMessage.Content = new StreamContent(_stream); httpResponseMessage.Content.Headers.ContentType = new MediaTypeHeaderValue(_mediaType); if (!string.IsNullOrEmpty(_fileName)) { httpResponseMessage.Content.Headers.ContentDisposition = new ContentDispositionHeaderValue(&quot;attachment&quot;) { FileName = HttpUtility.UrlEncode(_fileName, Encoding.UTF8), }; } return httpResponseMessage; } catch { httpResponseMessage.Dispose(); throw; } }}使用public async Task&amp;lt;FileStreamResult&amp;gt; GetFile(string path){ var f = new FileInfo(path); //return new FileStreamResult(f.OpenRead(), &quot;application/octet-stream&quot;, &quot;result.docx&quot;); var mediaType = MimeMapping.GetMimeMapping(path); return new FileStreamResult(f.OpenRead(), mediaType, &quot;result&quot;+Path.GetExtension(path));}" }, { "title": "Luhn算法", "url": "/post/Luhn%E7%AE%97%E6%B3%95", "categories": "dotnet, csharp", "tags": "", "date": "2020-06-19 19:14:08 +0800", "snippet": "Luhn算法（Luhn algorithm），也称为“模10”（Mod 10）算法，是一种简单的校验和算法，一般用于验证身份识别码，例如发卡行识别码、国际移动设备辨识码（IMEI），美国国家提供商标识号码，或是加拿大社会保险号码。该算法由IBM科学家Hans Peter Luhn创造，专利于1954年1月6日申请，1960年8月23日颁证，美国专利号2950048。该算法现已属于公有领域并得到了广泛的应用，例如ISO/IEC 7812-1。它不是一种安全的加密哈希函数，设计它的目的只是防止意外出错而不是恶意攻击。 来自百度百科public int CalculateSum(IEnumerable&amp;lt;int&amp;gt; digits, int bitShift = 0){ var sum = digits.Reverse() .Select((digit, i) =&amp;gt; (i + bitShift) % 2 == 0 ? digit * 2 &amp;gt; 9 ? digit * 2 - 9 : digit * 2 : digit) .Sum(); return sum;}public int GenerateCheckDigit(IEnumerable&amp;lt;int&amp;gt; digits){ var sum = CalculateSum(digits); var lastDigit = 10 - sum % 10; return lastDigit;}public static bool IsLuhnValid(int[] digits){ var sum = CalculateSum(digits, 1); return sum % 10 == 0;}public static int[] GetDigitsArrayFromCardNumber(string cardNumber){ var digits = cardNumber.Select(p =&amp;gt; p - &#39;0&#39;).ToArray(); return digits;}void Main(){ var digits1 = &quot;7992739871&quot;.Select(i =&amp;gt; i - &#39;0&#39;).ToList(); GenerateCheckDigit(digits1);//3}参考资料 .NET Core 如何生成信用卡卡号" }, { "title": "使用smtp发送邮件", "url": "/post/%E4%BD%BF%E7%94%A8smtp%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6", "categories": "windows, dotnet, csharp", "tags": "", "date": "2020-06-10 19:14:08 +0800", "snippet": "使用qq邮箱授权码发送邮件，避免密码泄露引用发送邮件包&amp;lt;package id=&quot;MailKit&quot; version=&quot;2.7.0&quot; targetFramework=&quot;net472&quot; /&amp;gt;&amp;lt;package id=&quot;MimeKit&quot; version=&quot;2.8.0&quot; targetFramework=&quot;net472&quot; /&amp;gt;发送邮件static async Task Main(string[] args){ var message = new MimeMessage { Subject = &quot;标题&quot;, Body = new BodyBuilder { HtmlBody = $&quot;测试邮件，时间:{DateTime.Now:yyyy-MM-dd HH:mm:ss}&quot; }.ToMessageBody() }; await SendAsync(message); Console.WriteLine(&quot;发送完成&quot;); Console.ReadKey();}/// &amp;lt;summary&amp;gt;/// 发送Email/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;message&quot;&amp;gt;&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;public static async Task SendAsync(MimeMessage message){ var host = &quot;smtp.qq.com&quot;; int port = 465; bool UseSsl = true; var fromUsername = &quot;125880321@qq.com&quot;; var fromPassword = &quot;tfpcmxwtwaccbhga&quot;; if (!message.From.Any()) { message.From.Add(new MailboxAddress(fromUsername, fromUsername)); } if (!message.To.Any()) { var address = new MailboxAddress(fromUsername, fromUsername); message.To.Add(address); } using (var client = new MailKit.Net.Smtp.SmtpClient { ServerCertificateValidationCallback = (s, c, h, e) =&amp;gt; true }) { client.AuthenticationMechanisms.Remove(&quot;XOAUTH2&quot;); await client.ConnectAsync(host, port, UseSsl); await client.AuthenticateAsync(fromUsername, fromPassword); await client.SendAsync(message); await client.DisconnectAsync(true); }}" }, { "title": "vue本地路由获取不到参数问题", "url": "/post/vue%E6%9C%AC%E5%9C%B0%E8%B7%AF%E7%94%B1%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98", "categories": "vue, typescript", "tags": "", "date": "2020-06-09 19:14:08 +0800", "snippet": "在使用vue开发系统时，有个客户扫码跳转到系统时默认一些信息，这些信息附带在url的参数中，由于vue页面会自动在url加一个#进行本地路由导航，参数就跑到#前面去了，然后使用route.query就获取不到参数了问题在使用vue开发系统时，有个客户扫码跳转到系统时默认一些信息，这些信息附带在url的参数中，由于vue页面会自动在url加一个#进行本地路由导航，参数就跑到#前面去了，然后使用route.query就获取不到参数了解决解决方案一在url中提前添加#，这样vue页面就不会再次添加#了，比如这样：http://www.sex.com/#?name=selang解决方案二不使用query获取参数，使用自定义解析，如下 getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(&quot;&amp;amp;&quot;); for (var i = 0; i &amp;lt; vars.length; i++) { var pair = vars[i].split(&quot;=&quot;); if (pair[0] === variable) { return decodeURI(pair[1]); } } return &quot;&quot;; }这样获取//name=selanglet name=getQueryVariable(&#39;name&#39;);" }, { "title": "Asp.Net WebApi在swagger中添加版本控制", "url": "/post/WebApi%E5%9C%A8swagger%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6", "categories": "Asp.Net, dotnet, csharp", "tags": "", "date": "2020-06-09 19:14:08 +0800", "snippet": "在Asp.Net WebApi中添加版本控制，同时在swagger中按版本显示接口引用版本控制包&amp;lt;package id=&quot;Microsoft.AspNet.WebApi.Versioning&quot; version=&quot;4.0.0&quot; targetFramework=&quot;net46&quot; /&amp;gt;&amp;lt;package id=&quot;Microsoft.AspNet.WebApi.Versioning.ApiExplorer&quot; version=&quot;4.0.0&quot; targetFramework=&quot;net46&quot; /&amp;gt;添加版本控制代码按如下修改App_Start中的WebApiConfig文件public static void Register(HttpConfiguration config){ config.Filters.Add(new ApiExceptionFilter()); config.MessageHandlers.Add(new WrapperHandler()); // Web API 配置和服务 config.AddApiVersioning(o =&amp;gt; { o.AssumeDefaultVersionWhenUnspecified = true;//没有标记版本的action默认未1.0版本 o.ReportApiVersions = true;//返回版本可使用的版本 o.ApiVersionReader = ApiVersionReader.Combine(new HeaderApiVersionReader(&quot;api-version&quot;), new QueryStringApiVersionReader(&quot;api-version&quot;));//通过Header或QueryString进行传值来判断api的版本 o.DefaultApiVersion = new ApiVersion(1, 0);//默认版本号 }); var apiExplorer = config.AddVersionedApiExplorer( options =&amp;gt; { options.GroupNameFormat = &quot;&#39;v&#39;VVV&quot;; // note: this option is only necessary when versioning by url segment. the SubstitutionFormat // can also be used to control the format of the API version in route templates options.SubstituteApiVersionInUrl = true; }); // Web API 路由 config.MapHttpAttributeRoutes(); config.Routes.MapHttpRoute( name: &quot;DefaultApi&quot;, routeTemplate: &quot;api/{controller}/{action}/{id}&quot;, defaults: new { id = RouteParameter.Optional } );//注意启用swagger的代码一定要放到路由之后 SwaggerConfig.Register(config, apiExplorer);}引用swagger包&amp;lt;package id=&quot;Swashbuckle&quot; version=&quot;5.6.0&quot; targetFramework=&quot;net46&quot; /&amp;gt;&amp;lt;package id=&quot;Swashbuckle.Core&quot; version=&quot;5.6.0&quot; targetFramework=&quot;net46&quot; /&amp;gt;修改swagger为多版本api在引用swagger包后，会自动在App_Start添加一个SwaggerConfig文件，需要修改部分代码，如下：//由自动注册改为手动注册swagger，因为版本控制需要Web.Http.Description.VersionedApiExplorer apiExplorer参数//[assembly: PreApplicationStartMethod(typeof(SwaggerConfig), &quot;Register&quot;)]namespace WebApplication1{ public class SwaggerConfig { public static void Register(HttpConfiguration Configuration, Microsoft.Web.Http.Description.VersionedApiExplorer apiExplorer) { var thisAssembly = typeof(SwaggerConfig).Assembly; Configuration .EnableSwagger(c =&amp;gt; { c.ResolveConflictingActions(apiDescriptions =&amp;gt; apiDescriptions.First()); c.MultipleApiVersions( (apiDescription, version) =&amp;gt; apiDescription.GetGroupName() == version, info =&amp;gt; { foreach (var group in apiExplorer.ApiDescriptions) { //如果出现中文乱码问题，可以用vs新建一个SwaggerConfig，把原来SwaggerConfig中的内容拷过去，再删除自动创建的SwaggerConfig文件， var description = &quot;A sample application with Swagger, Swashbuckle, and API versioning.&quot;; if (group.IsDeprecated) { description += &quot; This API version has been deprecated.&quot;; } info.Version(group.Name, $&quot;Create Wordreprot API {group.ApiVersion}&quot;); } }); //获取目录下的XML文件 显示注释等信息 var basePath1 = Path.GetDirectoryName(System.AppDomain.CurrentDomain.BaseDirectory);//获取应用程序所在目录（绝对，不受工作目录(平台)影响，建议采用此方法获取路径） var xmlComments = Directory.GetFiles(basePath1, &quot;*.xml&quot;, SearchOption.AllDirectories).ToList(); foreach (var xmlComment in xmlComments) { c.IncludeXmlComments(xmlComment); } #region MyRegion #endregion // 应用Controller的API文档描述信息 //c.DocumentFilter&amp;lt;SwaggerDocumentFilter&amp;gt;(); }) .EnableSwaggerUi( swagger =&amp;gt; { //显示api版本多个版本选择，选择版本后要切换失去选择焦点然后回车才会触发刷新，不然始终显示默认版本 swagger.EnableDiscoveryUrlSelector(); } ); } }}在controller中标记版本现在可以再controller或者action上添加版本标记来标记版本了，如果没有标记的默认1.0，默认版本设置见代码public class Controller1 : ApiController{ [ApiVersion(&quot;1.0&quot;)] public async Task&amp;lt;string&amp;gt; Get(){ returt &quot;1.0&quot; } public async Task&amp;lt;string&amp;gt; Get2(){ returt &quot;1.0&quot; }}public class Controller2 : ApiController{ [ApiVersion(&quot;2.0&quot;)] public async Task&amp;lt;string&amp;gt; Get(){ returt &quot;2.0&quot; }}发送请求在请求中带上版本号标记，如果没有带版本则默认1.0，请求可以通过query参数或者header方式，名称为api-version，这个名称是在前述代码中配置的可能遇到的问题 swagger描述中的中文乱码，可以用vs新建一个SwaggerConfig，把原来SwaggerConfig中的内容拷过去，再删除自动创建的SwaggerConfig文件 启动报错”This XML file does not appear to have any style information associated with it. The document tree is shown below.”，这是注册swagger的顺序错误，要把SwaggerConfig.Register(config, apiExplorer);放到路由注册之后。 选择api版本后swagger ui页面没有刷新，还是显示上一个版本，选择版本后需要失去焦点再回车，不然会弹出选择框继续选择参考资料 aspnet-api-versioning-SwaggerWebApiSample Swagger UI 中文乱码解决" }, { "title": "CallerMemberName(转载)", "url": "/post/CallerMemberName(%E8%BD%AC%E8%BD%BD)", "categories": "dotnet", "tags": "", "date": "2020-06-03 10:19:00 +0800", "snippet": "原文链接从 .NET Framework 4.5 开始，有了几个快速获取调用方信息的 Attribute。 Attribute 描述 CallerMemberName 允许您打算调用方的方法或属性名称传递给方法。 CallerLineNumber 允许您打算在调用方法的源文件中的行号。 CallerFilePath 允许您获取包含调用方源文件的完整路径。这是文件路径在生成时。 这样，在实现用于 XAML 绑定的类型中，可以更方便更高效地进行属性更改通知。[NotifyPropertyChangedInvocator]protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null){ PropertyChangedEventHandler handler = PropertyChanged; if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));}当使用 OnPropertyChanged() 句子调用以上方法时，参数 propertyName 会被自动赋值。protected bool SetProperty&amp;lt;T&amp;gt;(ref T storage, T value, [CallerMemberName] string propertyName = null){ if (Equals(storage, value)) return false; storage = value; OnPropertyChanged(propertyName); return true;}可在类型中添加以上方法，使得属性更改变得更加简单：private string _notifyMessage;public string Notification{ get { return _notifyMessage; } set { SetProperty(ref _notifyMessage, value); }}详细信息可阅读：Using CallerMemberName for property change notification in XAML apps" }, { "title": "Swagger过滤指定的api显示", "url": "/post/Swagger%E8%BF%87%E6%BB%A4%E6%8C%87%E5%AE%9A%E7%9A%84api%E6%98%BE%E7%A4%BA", "categories": "Swagger过滤指定的api显示", "tags": "", "date": "2020-05-19 19:14:08 +0800", "snippet": "在swagger显示的api文档中，隐藏指定的api实现过滤类Asp.Net版本public class SwaggerDocumentFilter : Swashbuckle.Swagger.IDocumentFilter{ public void Apply(SwaggerDocument swaggerDoc, SchemaRegistry schemaRegistry, IApiExplorer apiExplorer) { // 骚操作之隐藏abp动态生成的api var apis = apiExplorer.ApiDescriptions.Where(x =&amp;gt; x.RelativePath==&quot;xxx&quot;); if (apis.Any()) { foreach (var item in apis) { swaggerDoc.paths.Remove(&quot;/&quot; + item.RelativePath); } } }}Asp.Net Core版本 public class SwaggerDocumentFilter : IDocumentFilter { public void Apply(OpenApiDocument swaggerDoc, DocumentFilterContext context) { var apis = context.ApiDescriptions.Where(x =&amp;gt; x.RelativePath==&quot;xxx&quot;); if (apis.Any()) { foreach (var item in apis) { swaggerDoc.Paths.Remove(&quot;/&quot; + item.RelativePath); } } } }引用过滤器Asp.Net版本GlobalConfiguration.Configuration.EnableSwagger(c =&amp;gt;{ c.DocumentFilter&amp;lt;SwaggerDocumentFilter&amp;gt;();}).EnableSwaggerUi(c =&amp;gt;{});Asp.Net Core版本services.AddSwaggerGen(options =&amp;gt;{ // 应用Controller的API文档描述信息 options.DocumentFilter&amp;lt;SwaggerDocumentFilter&amp;gt;();});" }, { "title": "msbuild生成文件", "url": "/post/msbuild%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6", "categories": "msbuild生成文件", "tags": "", "date": "2020-05-18 14:26:00 +0800", "snippet": "msbuild生成项目使用的命令文件test.msbuild&amp;lt;Project&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;BuildArtifactsDir Include=&quot;BuildArtifacts\\&quot; /&amp;gt; &amp;lt;SolutionFile Include=&quot;\\test.sln&quot; /&amp;gt; &amp;lt;NUnitConsole Include=&quot;\\nunit-console.exe&quot; /&amp;gt; &amp;lt;UnitTestsDLL Include=&quot;BuildArtifacts\\HelloCI.Web.UnitTests.dll&quot; /&amp;gt; &amp;lt;TestResultsPath Include=&quot;BuildArtifacts\\TestResults.xml&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Name=&quot;Init&quot; DependsOnTargets=&quot;Clean&quot;&amp;gt; &amp;lt;MakeDir Directories=&quot;@(BuildArtifactsDir)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;Target Name=&quot;Clean&quot;&amp;gt; &amp;lt;RemoveDir Directories=&quot;@(BuildArtifactsDir)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Configuration Condition=&quot;uj &#39;$(Configuration)&#39; == &#39;&#39; &quot;&amp;gt;Release&amp;lt;/Configuration&amp;gt; &amp;lt;BuildPlatform Condition=&quot; &#39;$(BuildPlatform)&#39; == &#39;&#39; &quot;&amp;gt;Any CPU&amp;lt;/BuildPlatform&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;Compile&quot; DependsOnTargets=&quot;Init&quot;&amp;gt; &amp;lt;MSBuild Projects=&quot;@(SolutionFile)&quot; Targets=&quot;Rebuild&quot; Properties=&quot;OutDir=%(BuildArtifactsDir.FullPath);Configuration=$(Configuration);Platform=$(BuildPlatform)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;Target Name=&quot;RunUnitTests&quot; DependsOnTargets=&quot;Compile&quot;&amp;gt; &amp;lt;Exec Command=&#39;&quot;@(NUnitConsole)&quot; @(UnitTestsDLL) /xml=@(TestResultsPath)&#39; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;参考资料" }, { "title": "vue添加手势操作", "url": "/post/vue%E6%B7%BB%E5%8A%A0%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C", "categories": "vue添加手势操作", "tags": "", "date": "2020-04-22 20:14:08 +0800", "snippet": "在开发手机web页面时希望我的网页也可以像App一样可以左右滑动进行操作。如果你也和我的想法一样，你就可以复制我的代码了，一天的工作量又可以划水7小时。方案一(不推荐了，有坑，表现为：如果页面有滚动条，并且添加了v-hammer:swipe.right，页面无法滚动)使用基于vue封装的vue2-hammer 安装包npm install vue2-hammer 引用包import { VueHammer } from &#39;vue2-hammer&#39;Vue.use(VueHammer) 使用&amp;lt;a v-hammer:tap=&quot;onTap&quot;&amp;gt;Tap me!&amp;lt;/a&amp;gt;&amp;lt;div v-hammer:swipe.left=&quot;onSwipeLeft&quot;&amp;gt;Swipe me!&amp;lt;/div&amp;gt;&amp;lt;div v-hammer:swipe.left=&quot;(event)=&amp;gt; onSwipeLeft(event, item, i)&quot;&amp;gt;Swipe me!&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; onSwipeLeft() { //这里写上你想干的事情。。。 console.log(&quot;huahuahua!&quot;); }&amp;lt;/script&amp;gt;方案二使用原生的hammer 安装包npm install --save hammerjs 引用包import Hammer from &quot;hammerjs&quot;; 使用&amp;lt;div class=&quot;square&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; hammer = null; //vue的updated钩子函数 updated() { /*要把document.querySelector放到updated中，否则可能dom还没渲染，就获取不到，你也可放在monted中使用定时器循环获取*/ let square = document.querySelector(&quot;.square&quot;); if (!square || !!this.hammer) { return; } // Create an instance of Hammer with the reference. this.hammer = new Hammer(square); this.hammer.on(&quot;swiperight&quot;, function(e) { //这里写上你想干的事情。。。 console.log(&quot;huahuahua!&quot;); }); }&amp;lt;/script&amp;gt;参考资料 vue2-hammer hammer" }, { "title": "vant增加全局遮罩层", "url": "/post/vant%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%80%E9%81%AE%E7%BD%A9%E5%B1%82", "categories": "vant增加全局遮罩层", "tags": "", "date": "2020-04-15 20:26:00 +0800", "snippet": "vant默认提供的加载遮罩太水了，也可能是我太水了不会用，所以找大神写了一个，我抄过来了增加遮罩控件在任意位置增加如下两个文件，注意loadingIndex.js引用loading.vue时路径要修改成你的： 模板文件：loading.vue&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;van-overlay :show=&quot;isShow&quot; :custom-style=&quot;{ background: &#39;rgb(255, 255, 255, 0.6)&#39;, display: &#39;flex&#39;, justifyContent: &#39;center&#39;, paddingTop: &#39;100px&#39; }&quot; &amp;gt; &amp;lt;van-loading size=&quot;24px&quot; color=&quot;#4994df&quot;&amp;gt; &amp;lt;span style=&quot;color:#4994df&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/van-loading&amp;gt; &amp;lt;/van-overlay&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt; js文件：loadingIndex.jsimport vue from &#39;vue&#39;import loadingComponent from &#39;./loading.vue&#39;const LoadingConstructor = vue.extend(loadingComponent)let toastDom, el;function showLoading({ title, type, duration = 2000 }) { if (!el &amp;amp;&amp;amp; !toastDom) { el = document.createElement(&#39;div&#39;); toastDom = new LoadingConstructor({ el, data() { return { isShow: true, // 是否显示 title // 文本内容 }; } }); // 添加节点 document.body.appendChild(toastDom.$el); } else { toastDom.isShow = true; }}function cancelLoading() { if (toastDom) { toastDom.isShow = false; }}// 全局注册function registryToast() { vue.prototype.$showLoading = showLoading; vue.prototype.$cancelLoading = cancelLoading;}export default registryToast;在vue中引用控件在你引用vue的地方增加如下代码,注意路径改为你的路径import Vue from &quot;vue&quot;;import loadingIndex from &quot;./loading/loadingIndex&quot;;Vue.use(loadingIndex);使用遮罩然后你就可以像下面一样使用遮罩了：showloading() { var title = &quot;加载中···&quot;; this.$showLoading({ title: title }); } hideloading() { this.$cancelLoading(); }" }, { "title": "vant上传文件到后端", "url": "/post/vant%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6", "categories": "vant上传文件到后端", "tags": "", "date": "2020-04-15 20:26:00 +0800", "snippet": "最近在做手机版页面，采用的vant框架，这个上传控件和以前用iview、element有点不一样，iview、element都是直接提供后端接口文件会自动发送到后端，vant需要自己负责发送文件到后端，对于我这种面向百度编程人员还是有点难度。特意记一下，能帮到其他面向百度编程人员代码很简单，基本是使用文件构建FormData参数，如下：html代码&amp;lt;van-uploader:after-read=&quot;afterRead&quot;:before-delete=&quot;beforeDelete&quot;v-model=&quot;fileList&quot;/&amp;gt;ts代码 fileList=[]; /**文件上传 */ afterRead(file) { // 此时可以自行将文件上传至服务器 // console.log(file); let that = this; let id = 1; if (!/image\\/[a-zA-z]+/.test(file.file.type)) { this.$toast(&quot;请上传图片&quot;); return false; } let params = new FormData(); params.append(&quot;file&quot;, file.file); params.append(&quot;ID&quot;, id); let config = { headers: { //添加请求头 &quot;Content-Type&quot;: &quot;multipart/form-data&quot; } }; return new Promise((resolve, reject) =&amp;gt; { //我的后端还是asp的 //需要其他后端的可以看我以前的博文去复制 Ajax.post(&quot;/***/FileUpload.ashx&quot;, params, config) .then(res =&amp;gt; { if (res.status === 200) { //可以直接再file上附加属性，这样再删除的时候就可以作为标识从服务器删除数据 file.path = res.data[0].Path; //URL是一个后端地址（前后端不在一个地址）常量 file.url = URL + res.data[0].Path; console.log(that.fileList); resolve(); } else reject(); }) .catch(() =&amp;gt; { reject(); }); }); } beforeDelete(file) { console.log(file); return new Promise((resolve, reject) =&amp;gt; { //我的后端删除文件直接使用文件地址，你们的根据自己的修改 Ajax.post( &quot;/***/DeleteFile.ashx?path=&quot; + escape(file.path) + &quot;&amp;amp;ts=&quot; + new Date().getTime() ) .then(res =&amp;gt; { if (res.status === 200) resolve(); else reject(); }) .catch(() =&amp;gt; { reject(); }); }); }这里没有写从后端获取文件列表，你需要自己获取，文件列表只需要包含url或者content（文件的base64编码）两个属性就可以正常绑定列表，上传的时候通常是content，从服务器返回的我用的url，主要是读取文件再转换base64我不会，还要再百度一次，太麻烦了。" }, { "title": "Abp_vue修改客户端地址", "url": "/post/Abp_vue%E4%BF%AE%E6%94%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%B0%E5%9D%80", "categories": "Abp_vue修改客户端地址", "tags": "", "date": "2020-01-17 19:44:08 +0800", "snippet": "客户端地址定义在ts文件src\\lib\\url.ts中，每次发版时都要修改地址，如果不修改成配置的地址signalR就获取不到js文件，连接不上。实现把url地址定义到不打包的js文件中去，这样就可以在发布后也能修改地址，因为abp.js就是原样输出的，我就直接定义到这个abp上了，免得还要再去配置js文件，还有加载顺序问题。 修改src\\lib\\abp.js文件 var abp = abp || {};++ abp.appBaseUrl=&quot;http://localhost:8081&quot;; (function () { 修改src\\lib\\abp.d.ts文件declare namespace abp {++ let appBaseUrl:string; let appPath: string; let pageLoadTime: Date; 修改src\\lib\\appconst.ts文件 import url from &#39;./url&#39; const AppConsts= { userManagement:{ defaultAdminUserName: &#39;admin&#39; }, localization:{ defaultLocalizationSourceName: &#39;HItekLab&#39; }, authorization:{ encrptedAuthTokenName: &#39;enc_auth_token&#39; },-- appBaseUrl: &quot;http://localhost:8081&quot;,++ appBaseUrl: abp.appBaseUrl,//&quot;http://localhost:8081&quot;, remoteServiceBaseUrl:url } export default AppConsts" }, { "title": "Abp_配置跨域为*通配符时报跨域请求错误", "url": "/post/Abp_vue%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E4%B8%BA%E9%80%9A%E9%85%8D%E7%AC%A6%E6%97%B6%E9%94%99%E8%AF%AF-copy", "categories": "Abp_配置跨域为*通配符时报跨域请求错误", "tags": "", "date": "2020-01-17 19:14:08 +0800", "snippet": "当配置跨域域名为*时，signalr链接报错问题像这样配置：然后在浏览器调试窗口中就会看到如下错误：解决解决方式应该有两种：第一种是修改服务端跨域配置为自己判断；第二种是修改前端不使用cookie，但是这样会有新的问题就是无法支持负载均衡。我采用第一种，因为第二种要修改abp源码并自己发布js包。 使用SetIsOriginAllowed代替WithOrigins中间件配置跨域 修改SignalR连接设置，不使用cookie，这种方式我没有试，不知道是否可行 var hubConnectionBuilder = new HubConnectionBuilder();var hubConnection = hubConnectionBuilder.WithUrl(&quot;https://localhost:21021/Hub&quot;,options =&amp;gt; { options.UseDefaultCredentials = false;}).Build();await hubConnection.StartAsync();原因大概是因为在同时使用*配置跨域和AllowCredentials时服务器会返回一个警告信息，这个修改是从2.2版本开始的，操作signalR识别不了，然后就不进行链接请求了。参考资料 Breaking change in AspNetCore 2.2 for SignalR and CORS Setting XMLHttpRequest “withCredentials” attribute #2110 SignalR: Configuring CORS #6078 Setting XHR “withCredentials” attribute in SignalR #14570" }, { "title": "abp集成IdentityServer4和单点登录", "url": "/post/abp%E9%9B%86%E6%88%90IdentityServer4%E5%92%8C%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95", "categories": "abp集成IdentityServer4和单点登录", "tags": "", "date": "2020-01-14 19:04:43 +0800", "snippet": "在abp开发的系统后，需要使用这个系统作单点登录，及其他项目登录账号依靠abp开发的系统。在官方文档上只找到作为登录服务Identity Server Integration，但是host项目却无法使用登录服务生成的Token获取数据。所有的搜索结果包括abp的issue都是说去看identity server4的文档。我比较笨，文档看了还是不会。好在最后还是试出来了。创建登录中心项目 到官网下载一个最新的模板项目，项目类型自选(我们项目用的vue，所以我选择的vue项目，.net core3.x)。保证可以运行起来并正常登录。 右键src目录添加一个asp.net core web 空项目，在项目中添加Startup文件夹，把Startup.cs和Program.cs移动到Startup文件夹，并修改这两个文件的命名空间增加Startup。不然会有命名空间和类名冲突。 在nuget添加Abp.ZeroCore.IdentityServer4、Abp、Abp.Castle.Log4Net等引用，添加Web.Core、EntityFrameworkCore项目引用 在Startup文件加新增xxxModule文件，初始化登录中心项目，因为这个项目要用到abp的模块所以要添加moduleusing Abp.Ids4;using Abp.Ids4.Configuration;using Abp.Modules;using Abp.Reflection.Extensions;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;namespace Abp.Ids4.Server.Startup{ [DependsOn( typeof(Ids4WebCoreModule))] public class AbpIds4ServerModule: AbpModule { private readonly IWebHostEnvironment _env; private readonly IConfigurationRoot _appConfiguration; public AbpIds4ServerModule(IWebHostEnvironment env) { _env = env; _appConfiguration = env.GetAppConfiguration(); } public override void Initialize() { IocManager.RegisterAssemblyByConvention(typeof(AbpIds4ServerModule).GetAssembly()); } }} 在Startup文件加新增AuthConfigurer.cs文件，你也可以直接从IdentityServerDemo项目复制文件过来，但是记得修改命名空间using System;using System.Linq;using System.Text;using System.Threading.Tasks;using Abp.Authorization;using Abp.Ids4;using Abp.Runtime.Security;using IdentityServer4.Models;using Microsoft.AspNetCore.Authentication.JwtBearer;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.IdentityModel.Logging;using Microsoft.IdentityModel.Tokens;namespace Abp.Ids4.Server.Startup{ public static class AuthConfigurer { /// &amp;lt;summary&amp;gt; /// Configures the specified application. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;app&quot;&amp;gt;The application.&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;configuration&quot;&amp;gt;The configuration.&amp;lt;/param&amp;gt; public static void Configure(IServiceCollection services, IConfiguration configuration) { var authenticationBuilder = services.AddAuthentication(); if (bool.Parse(configuration[&quot;Authentication:JwtBearer:IsEnabled&quot;])) { authenticationBuilder.AddJwtBearer(options =&amp;gt; { options.TokenValidationParameters = new TokenValidationParameters { // The signing key must match! ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(configuration[&quot;Authentication:JwtBearer:SecurityKey&quot;])), // Validate the JWT Issuer (iss) claim ValidateIssuer = true, ValidIssuer = configuration[&quot;Authentication:JwtBearer:Issuer&quot;], // Validate the JWT Audience (aud) claim ValidateAudience = true, ValidAudience = configuration[&quot;Authentication:JwtBearer:Audience&quot;], // Validate the token expiry ValidateLifetime = true, // If you want to allow a certain amount of clock drift, set that here ClockSkew = TimeSpan.Zero }; options.Events = new JwtBearerEvents { OnMessageReceived = QueryStringTokenResolver }; }); } IdentityModelEventSource.ShowPII = true; authenticationBuilder.AddIdentityServerAuthentication(&quot;Bearer&quot;, options =&amp;gt; { options.Authority = configuration[&quot;IdentityServer:Authority&quot;]; options.ApiName = configuration[&quot;IdentityServer:ApiName&quot;]; options.ApiSecret = configuration[&quot;IdentityServer:ApiSecret&quot;]; options.RequireHttpsMetadata = false; }); } /* This method is needed to authorize SignalR javascript client. * SignalR can not send authorization header. So, we are getting it from query string as an encrypted text. */ private static Task QueryStringTokenResolver(MessageReceivedContext context) { if (!context.HttpContext.Request.Path.HasValue || !context.HttpContext.Request.Path.Value.StartsWith(&quot;/signalr&quot;)) { //We are just looking for signalr clients return Task.CompletedTask; } var qsAuthToken = context.HttpContext.Request.Query[&quot;enc_auth_token&quot;].FirstOrDefault(); if (qsAuthToken == null) { //Cookie value does not matches to querystring value return Task.CompletedTask; } //Set auth token from cookie context.Token = SimpleStringCipher.Instance.Decrypt(qsAuthToken, AppConsts.DefaultPassPhrase); return Task.CompletedTask; } }} 修改Startup文件,因为有部分文件在Web.Core项目中，但是还没有添加进来，所以现在编译会报错，先忽略using System;using Abp.AspNetCore;using Abp.AspNetCore.Mvc.Antiforgery;using Abp.Castle.Logging.Log4Net;using Abp.Dependency;using Abp.Ids4.Configuration;using Abp.Ids4.Identity;using Abp.Ids4.Web.Core.IdentityServer;using Abp.Json;using Castle.Facilities.Logging;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.AspNetCore.Http;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;using Newtonsoft.Json.Serialization;namespace Abp.Ids4.Server.Startup{ public class Startup { private readonly IConfigurationRoot _appConfiguration; public Startup(IWebHostEnvironment env) { _appConfiguration = env.GetAppConfiguration(); } public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddControllersWithViews( options =&amp;gt; { options.Filters.Add(new AbpAutoValidateAntiforgeryTokenAttribute()); } ).AddNewtonsoftJson(options =&amp;gt; { options.SerializerSettings.ContractResolver = new AbpMvcContractResolver(IocManager.Instance) { NamingStrategy = new CamelCaseNamingStrategy() }; }); IdentityRegistrar.Register(services); IdentityServerRegistrar.Register(services, _appConfiguration); AuthConfigurer.Configure(services, _appConfiguration); // Configure Abp and Dependency Injection return services.AddAbp&amp;lt;AbpIds4ServerModule&amp;gt;( // Configure Log4Net logging options =&amp;gt; options.IocManager.IocContainer.AddFacility&amp;lt;LoggingFacility&amp;gt;( f =&amp;gt; f.UseAbpLog4Net().WithConfig(&quot;log4net.config&quot;) ) ); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.UseAbp(); //Initializes ABP framework. if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } if (bool.Parse(_appConfiguration[&quot;IdentityServer:IsEnabled&quot;])) { app.UseJwtTokenMiddleware(); app.UseIdentityServer(); } app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapDefaultControllerRoute(); }); } }} 从Web.Core项目中复制appsettings.json和log4net.config到IdentityServer项目，在appsettings.json文件中增加IdentityServer4配置{ &quot;Logging&quot;: { &quot;LogLevel&quot;: { &quot;Default&quot;: &quot;Information&quot;, &quot;Microsoft&quot;: &quot;Warning&quot;, &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot; } }, &quot;AllowedHosts&quot;: &quot;*&quot;, &quot;ConnectionStrings&quot;: { &quot;Default&quot;: &quot;Server=localhost\\\\sqlexpress; Database=Ids4Db; Trusted_Connection=True;&quot; }, &quot;Authentication&quot;: { &quot;Facebook&quot;: { &quot;IsEnabled&quot;: &quot;false&quot;, &quot;AppId&quot;: &quot;&quot;, &quot;AppSecret&quot;: &quot;&quot; }, &quot;Google&quot;: { &quot;IsEnabled&quot;: &quot;false&quot;, &quot;ClientId&quot;: &quot;&quot;, &quot;ClientSecret&quot;: &quot;&quot; }, &quot;JwtBearer&quot;: { &quot;IsEnabled&quot;: &quot;false&quot;, &quot;SecurityKey&quot;: &quot;Ids4_C421AAEE0D126E5C&quot;, &quot;Issuer&quot;: &quot;Ids4&quot;, &quot;Audience&quot;: &quot;Ids4&quot; } }, &quot;IdentityServer&quot;: { &quot;IsEnabled&quot;: &quot;true&quot;, &quot;Authority&quot;: &quot;http://localhost:5000&quot;, &quot;ApiName&quot;: &quot;default-api&quot;, &quot;ApiSecret&quot;: &quot;secret&quot;, &quot;Clients&quot;: [ { &quot;ClientId&quot;: &quot;client&quot;, &quot;AllowedGrantTypes&quot;: [ &quot;password&quot;, &quot;client_credentials&quot; ], &quot;ClientSecrets&quot;: [ { &quot;Value&quot;: &quot;def2e777-5d42-4edc-a84a-30136c340e13&quot; } ], &quot;AllowedScopes&quot;: [ &quot;default-api&quot;, &quot;openid&quot;, &quot;profile&quot;, &quot;email&quot; ] }, { &quot;ClientId&quot;: &quot;mvc_implicit&quot;, &quot;ClientName&quot;: &quot;MVC Client&quot;, &quot;AllowedGrantTypes&quot;: [ &quot;implicit&quot; ], &quot;RedirectUris&quot;: [ &quot;http://localhost:5002/signin-oidc&quot; ], &quot;PostLogoutRedirectUris&quot;: [ &quot;http://localhost:5002/signout-callback-oidc&quot; ], &quot;AllowedScopes&quot;: [ &quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;, &quot;default-api&quot; ], &quot;AllowAccessTokensViaBrowser&quot;: true } ] }}最终项目结构如下：修改Web.Core项目从IdentityServerDemo项目复制IdentityServer目录和文件到xxx.Web.Core项目，修改文件中的命名空间和当前项目对应。修改IdentityServerRegistrar文件中的dbcontext，把直接引用dbcontext实例改成引用接口，如下：public static void Register(IServiceCollection services, IConfigurationRoot configuration){ services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryIdentityResources(IdentityServerConfig.GetIdentityResources()) .AddInMemoryApiResources(IdentityServerConfig.GetApiResources()) .AddInMemoryClients(IdentityServerConfig.GetClients(configuration))-- .AddAbpPersistedGrants&amp;lt;IdentityServerDemoDbContext&amp;gt;()++ .AddAbpPersistedGrants&amp;lt;IAbpPersistedGrantDbContext&amp;gt;() .AddAbpIdentityServer&amp;lt;User&amp;gt;();}EntityFrameworkCore项目及其他修改 按照Identity Server Integration文档修改EntityFrameworkCore项目和nuget添加引用，同时把项目因为没有引用包报错的添加引用。现在运行IdentityServer项目从connect/token中获取到token了，但是这个token还不能用。即使按照IdentityServerDemo配置了也用不了，IdentityServerDemo中实际上每个web项目都是登录中心。 修改Web.Host项目的appsettings.json { &quot;ConnectionStrings&quot;: { &quot;Default&quot;: &quot;Server=localhost\\\\sqlexpress; Database=Ids4Db; Trusted_Connection=True;&quot; }, &quot;App&quot;: { &quot;ServerRootAddress&quot;: &quot;http://localhost:21022/&quot;, &quot;ClientRootAddress&quot;: &quot;http://localhost:8080/&quot;, &quot;CorsOrigins&quot;: &quot;http://localhost:4200,http://localhost:8080,http://localhost:8081,http://localhost:3000&quot; }, &quot;Authentication&quot;: { &quot;JwtBearer&quot;: { &quot;IsEnabled&quot;: &quot;true&quot;, &quot;SecurityKey&quot;: &quot;Ids4_C421AAEE0D126E5C&quot;, &quot;Issuer&quot;: &quot;Ids4&quot;, &quot;Audience&quot;: &quot;Ids4&quot; } }, &quot;IdentityServer&quot;: { &quot;IsEnabled&quot;: &quot;true&quot;, &quot;Authority&quot;: &quot;http://localhost:5000&quot;, &quot;ApiName&quot;: &quot;default-api&quot;, &quot;ApiSecret&quot;: &quot;secret&quot;, &quot;ClientId&quot;: &quot;client&quot;, // no interactive user, use the clientid/secret for authentication &quot;AllowedGrantTypes&quot;: &quot;password&quot;, // secret for authentication &quot;ClientSecret&quot;: &quot;def2e777-5d42-4edc-a84a-30136c340e13&quot;, // scopes that client has access to &quot;AllowedScopes&quot;: &quot;default-api&quot; }} Web.Host项目在AuthConfigurer.cs文件的Configure方法中增加如下代码var authenticationBuilder = services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme);IdentityModelEventSource.ShowPII = true;authenticationBuilder// .AddIdentityServerAuthentication(JwtBearerDefaults.AuthenticationScheme, options =&amp;gt;//{// options.Authority = configuration[&quot;IdentityServer:Authority&quot;];// options.ApiName = configuration[&quot;IdentityServer:ApiName&quot;];// options.ApiSecret = configuration[&quot;IdentityServer:ApiSecret&quot;];// //options.Audience = configuration[&quot;IdentityServer:ApiName&quot;];// options.RequireHttpsMetadata = false;//}) .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options =&amp;gt;{ options.Authority = configuration[&quot;IdentityServer:Authority&quot;]; options.RequireHttpsMetadata = false; options.Audience = configuration[&quot;IdentityServer:ApiName&quot;];}); 修改Web.Host项目中的Startup类using System;using System.Linq;using System.Reflection;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;using Castle.Facilities.Logging;using Abp.AspNetCore;using Abp.AspNetCore.Mvc.Antiforgery;using Abp.Castle.Logging.Log4Net;using Abp.Extensions;using Abp.Ids4.Configuration;using Abp.Ids4.Identity;using Abp.AspNetCore.SignalR.Hubs;using Abp.Dependency;using Abp.Json;using Microsoft.OpenApi.Models;using Newtonsoft.Json.Serialization;using Abp.Ids4.Web.Core.IdentityServer;namespace Abp.Ids4.Web.Host.Startup{ public class Startup { private const string _defaultCorsPolicyName = &quot;localhost&quot;; private readonly IConfigurationRoot _appConfiguration; public Startup(IWebHostEnvironment env) { _appConfiguration = env.GetAppConfiguration(); } public IServiceProvider ConfigureServices(IServiceCollection services) { //MVC services.AddControllersWithViews( options =&amp;gt; { options.Filters.Add(new AbpAutoValidateAntiforgeryTokenAttribute()); } ).AddNewtonsoftJson(options =&amp;gt; { options.SerializerSettings.ContractResolver = new AbpMvcContractResolver(IocManager.Instance) { NamingStrategy = new CamelCaseNamingStrategy() }; }); IdentityRegistrar.Register(services); AuthConfigurer.Configure(services, _appConfiguration); //其他代码 //... } public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory) { app.UseAbp(options =&amp;gt; { options.UseAbpRequestLocalization = false; }); // Initializes ABP framework. app.UseCors(_defaultCorsPolicyName); // Enable CORS! app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); //app.UseJwtTokenMiddleware(); if (bool.Parse(_appConfiguration[&quot;IdentityServer:IsEnabled&quot;])) { app.UseJwtTokenMiddleware(); } app.UseAbpRequestLocalization(); //...其他代码 } }} 修改登录方法从授权中心获取token,修改Web.Core项目TokenAuthController.cs的Authenticate方法public async Task&amp;lt;AuthenticateResultModel&amp;gt; Authenticate([FromBody] AuthenticateModel model){ var loginResult = await GetLoginResultAsync( model.UserNameOrEmailAddress, model.Password, GetTenancyNameOrNull() ); if (loginResult.Result != AbpLoginResultType.Success) { throw new UserFriendlyException(&quot;登录失败&quot;); } //var accessToken = CreateAccessToken(CreateJwtClaims(loginResult.Identity)); var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(_appConfiguration[&quot;IdentityServer:Authority&quot;]); if (disco.IsError) { throw new UserFriendlyException(disco.Error); } var tokenResponse = await client.RequestPasswordTokenAsync(new PasswordTokenRequest { Address = disco.TokenEndpoint, ClientId = _appConfiguration[&quot;IdentityServer:ClientId&quot;], ClientSecret = _appConfiguration[&quot;IdentityServer:ClientSecret&quot;], UserName = model.UserNameOrEmailAddress, Password = model.Password, Scope = _appConfiguration[&quot;IdentityServer:AllowedScopes&quot;], }); if (tokenResponse.IsError) { throw new UserFriendlyException(tokenResponse.Error); } var accessToken = tokenResponse.AccessToken; return new AuthenticateResultModel { AccessToken = accessToken, EncryptedAccessToken = GetEncryptedAccessToken(accessToken), ExpireInSeconds = (int)_configuration.Expiration.TotalSeconds, UserId = loginResult.User.Id };}至此host项目的登录获取的token就是从登录中心获取的了，其他客户端的对接按照使用Identity Server 4建立Authorization Server配置就可以了源码：https://gitee.com/XiaoShenXiana/abp_ids4.git原文参考资料 Identity Server Integration IdentityServerDemo 使用Identity Server 4建立Authorization Server" }, { "title": "2020-01-09-RSA加解密", "url": "/post/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86", "categories": "2020-01-09-RSA加解密", "tags": "", "date": "2020-01-09 14:31:50 +0800", "snippet": "RAS加解密帮助类，不记得哪里抄的了IRSAManagerpublic interface IRSAManager{ /// &amp;lt;summary&amp;gt; /// 生成私钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;私钥base64字符串&amp;lt;/returns&amp;gt; string CreatePrivateKey(); /// &amp;lt;summary&amp;gt; /// 生成私钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dwKeySize&quot;&amp;gt;私钥位数&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;私钥base64字符串&amp;lt;/returns&amp;gt; string CreatePrivateKey(int dwKeySize); /// &amp;lt;summary&amp;gt; /// 获取公钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;priKey&quot;&amp;gt;私钥base64字符串&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;公钥base64字符串&amp;lt;/returns&amp;gt; string GetPublicKey(string priKey); /// &amp;lt;summary&amp;gt; /// 签名数据 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;priKey&quot;&amp;gt;私钥字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;data&quot;&amp;gt;待签名内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;签名后字符串&amp;lt;/returns&amp;gt; string SignData(string priKey, string data); /// &amp;lt;summary&amp;gt; /// 验证签名 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;pubKey&quot;&amp;gt;公钥字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;signedData&quot;&amp;gt;签名后字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;data&quot;&amp;gt;待验证签名内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;是否验证通过&amp;lt;/returns&amp;gt; bool VerifySignedData(string pubKey, string signedData, string data);}class RSAManager : IRSAManager{ /// &amp;lt;summary&amp;gt; /// 生成私钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;私钥base64字符串&amp;lt;/returns&amp;gt; public string CreatePrivateKey() { var Rsa = new RSACryptoServiceProvider(); var priKey = Convert.ToBase64String(Rsa.ExportCspBlob(true)); return priKey; } /// &amp;lt;summary&amp;gt; /// 生成私钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dwKeySize&quot;&amp;gt;私钥位数&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;私钥base64字符串&amp;lt;/returns&amp;gt; public string CreatePrivateKey(int dwKeySize) { var Rsa = new RSACryptoServiceProvider(dwKeySize); var priKey = Convert.ToBase64String(Rsa.ExportCspBlob(true)); return priKey; } /// &amp;lt;summary&amp;gt; /// 获取公钥 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;priKey&quot;&amp;gt;私钥base64字符串&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;公钥base64字符串&amp;lt;/returns&amp;gt; public string GetPublicKey(string priKey) { var rsa = new RSACryptoServiceProvider(); rsa.ImportCspBlob(Convert.FromBase64String(priKey)); var pubKey = Convert.ToBase64String(rsa.ExportCspBlob(false)); return pubKey; } /// &amp;lt;summary&amp;gt; /// 签名数据 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;priKey&quot;&amp;gt;私钥字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;data&quot;&amp;gt;待签名内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;签名后字符串&amp;lt;/returns&amp;gt; public string SignData(string priKey, string data) { var rsa = new RSACryptoServiceProvider(); rsa.ImportCspBlob(Convert.FromBase64String(priKey)); var signData = rsa.SignData(Encoding.UTF8.GetBytes(data), new SHA1CryptoServiceProvider()); return Convert.ToBase64String(signData); } /// &amp;lt;summary&amp;gt; /// 验证签名 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;pubKey&quot;&amp;gt;公钥字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;signedData&quot;&amp;gt;签名后字符串&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;data&quot;&amp;gt;待验证签名内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;是否验证通过&amp;lt;/returns&amp;gt; public bool VerifySignedData(string pubKey, string signedData, string data) { var rsa = new RSACryptoServiceProvider(); rsa.ImportCspBlob(Convert.FromBase64String(pubKey)); var verify = rsa.VerifyData(Encoding.UTF8.GetBytes(data), new SHA1CryptoServiceProvider(), Convert.FromBase64String(signedData)); return verify; }}" }, { "title": "Vue+abp增加三级菜单", "url": "/post/Vue+abp%E5%A2%9E%E5%8A%A0%E4%B8%89%E7%BA%A7%E8%8F%9C%E5%8D%95", "categories": "Vue+abp增加三级菜单", "tags": "", "date": "2019-12-26 17:28:38 +0800", "snippet": "原生vue版的abp只支持2级菜单，项目需要增加成3级菜单，一番搜索。成果如下增加3级菜单显示修改components-&amp;gt;shrinkable-menu-&amp;gt;components-&amp;gt;sidebarMenu文件，增加一级菜单,并增加两个方法hasChildren和getChildren,避免html因为没有children属性报错&amp;lt;template&amp;gt; &amp;lt;Menu ref=&quot;sideMenu&quot; :active-name=&quot;$route.name&quot; :open-names=&quot;openNames&quot; :theme=&quot;menuTheme&quot; width=&quot;auto&quot; @on-select=&quot;changeMenu&quot;&amp;gt; &amp;lt;template v-for=&quot;item in menuList&quot;&amp;gt; &amp;lt;MenuItem v-if=&quot;item.children.length&amp;lt;=0&quot; :name=&quot;item.children[0].name&quot; :key=&quot;item.name&quot;&amp;gt; &amp;lt;!-- &amp;lt;Icon :type=&quot;item.icon&quot; :size=&quot;iconSize&quot;&amp;gt;&amp;lt;/Icon&amp;gt; --&amp;gt; &amp;lt;span class=&quot;iconfont&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/MenuItem&amp;gt; &amp;lt;Submenu v-if=&quot;item.children.length &amp;gt; 0&amp;amp;&amp;amp;!item.meta.hidden&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot;&amp;gt; &amp;lt;template slot=&quot;title&quot;&amp;gt; &amp;lt;i class=&quot;iconfont&quot; v-html=&quot;item.icon&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span &amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-for=&quot;child in item.children&quot;&amp;gt; &amp;lt;MenuItem v-if=&quot;!hasChildren(child)&amp;amp;&amp;amp;!child.meta.hidden&quot; :name=&quot;child.name&quot; :key=&quot;child.name&quot;&amp;gt; &amp;lt;i class=&quot;iconfont&quot; v-html=&quot;child.icon&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/MenuItem&amp;gt; &amp;lt;Submenu v-if=&quot;hasChildren(child)&amp;amp;&amp;amp;!child.meta.hidden&quot; :name=&quot;child.name&quot; :key=&quot;child.name&quot;&amp;gt; &amp;lt;template slot=&quot;title&quot;&amp;gt; &amp;lt;i class=&quot;iconfont&quot; v-html=&quot;child.icon&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span &amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-for=&quot;ss in child.children&quot;&amp;gt; &amp;lt;MenuItem v-if=&quot;!hasChildren(ss)&amp;amp;&amp;amp;!ss.meta.hidden&quot; :name=&quot;ss.name&quot; :key=&quot;ss.name&quot;&amp;gt; &amp;lt;i class=&quot;iconfont&quot; v-html=&quot;ss.icon&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/MenuItem&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/Submenu&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/Submenu&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/Menu&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt; hasChildren(item:any){ return !!item.children&amp;amp;&amp;amp;item.children.length&amp;gt;0 } getChildren(item:any){ return item.children; }&amp;lt;/script&amp;gt;修改显示路由方法就是显示图上这个这个方法在lib-&amp;gt;util.ts文件中,我是抄的Vue iview-admin模板二级菜单改为三级菜单，根据abp做了一些调整，修改setCurrentPath方法如下： setCurrentPath(vm: Vue, name?: string) { let title = &quot;&quot;; let isOtherRouter = false; vm.$store.state.app.routers.forEach(item =&amp;gt; { if (item.children.length === 1) { if (item.children[0].name === name) { title = util.handleTitle(vm, item); if (item.name === &quot;otherRouter&quot;) { isOtherRouter = true; } } } else { item.children.forEach(child =&amp;gt; { if (child.name === name) { title = util.handleTitle(vm, child); if (item.name === &quot;otherRouter&quot;) { isOtherRouter = true; } } }); } }); let currentPathArr = []; //去首页 if (name === &quot;home_index&quot;) { currentPathArr = [ { meta: {title: util.handleTitle( vm, util.getRouterObjByName(vm.$store.state.app.routers, &quot;home_index&quot;) )}, path: &quot;&quot;, name: &quot;home_index&quot; } ]; } //去导航菜单一级页面或者OtherRouter路由中的页面 else if ( (name.indexOf(&quot;_index&quot;) &amp;gt;= 0 || isOtherRouter) &amp;amp;&amp;amp; name !== &quot;home_index&quot; ) { currentPathArr = [ { meta: {title: util.handleTitle( vm, util.getRouterObjByName(vm.$store.state.app.routers, &quot;home_index&quot;) )}, path: &quot;/home&quot;, name: &quot;home_index&quot; }, { meta: {title: title}, path: &quot;&quot;, name: name } ]; } //去导航菜单二级页面或三级页面 else { let currentPathObj = vm.$store.state.app.routers.filter(item =&amp;gt; { var hasMenu; if (item.children.length &amp;lt;= 1) { hasMenu = item.children[0].name === name; return hasMenu; } else { let i = 0; let childArr = item.children; let len = childArr.length; while (i &amp;lt; len) { //如果是三级页面按钮，则在二级按钮数组中找不到这个按钮名称 //需要二级页面下可能出现三级子菜单的情况逻辑加入 if (childArr[i].name === name) { hasMenu = true; return hasMenu; } i++; } //如果一级，二级菜单下都没有此按钮名称，则遍历三级菜单 if (!hasMenu) { for (let m = 0; m &amp;lt; childArr.length; m++) { if (!childArr[m].children) continue; let sonArr = childArr[m].children; for (let n = 0; n &amp;lt; sonArr.length; n++) { if (sonArr[n].name === name) { hasMenu = true; return hasMenu; } } } } return false; } })[0]; if ( currentPathObj.children.length &amp;lt;= 1 &amp;amp;&amp;amp; currentPathObj.name === &quot;home&quot; ) { currentPathArr = [ { meta: { title: &quot;HomePage&quot; }, path: &quot;main/home&quot;, name: &quot;home&quot; } ]; } else if ( currentPathObj.children.length &amp;lt;= 1 &amp;amp;&amp;amp; currentPathObj.name !== &quot;home&quot; ) { currentPathArr = [ { meta: { title: &quot;HomePage&quot; }, path: &quot;main/home&quot;, name: &quot;home&quot; }, { meta: {title: currentPathObj.meta.title}, path: &quot;&quot;, name: name } ]; } else { //如果是三级页面按钮，则在二级按钮数组中找不到这个按钮名称 //需要二级页面下可能出现三级子菜单的情况逻辑加入 let childObj = currentPathObj.children.filter(child =&amp;gt; { return child.name === name; })[0]; //二级页面 if (childObj) { currentPathArr = [ { meta: { title: &quot;HomePage&quot; }, path: &quot;main/home&quot;, name: &quot;home&quot; }, { meta: {title: currentPathObj.meta.title}, path: &quot;&quot;, name: &quot;&quot; }, { meta: {title: childObj.meta.title}, path: currentPathObj.path + &quot;/&quot; + childObj.path, name: name } ]; } //childobj为undefined，再从三级页面中遍历 else { let thirdObj; let childObj = currentPathObj.children.filter(child =&amp;gt; { let hasChildren; hasChildren = child.name === name; if (hasChildren) return hasChildren; if (child.children) { let sonArr = child.children; for (let n = 0; n &amp;lt; sonArr.length; n++) { if (sonArr[n].name === name) { thirdObj = sonArr[n]; hasChildren = true; return hasChildren; } } } return hasChildren; })[0]; if (thirdObj &amp;amp;&amp;amp; childObj) { currentPathArr = [ { meta: { title: &quot;HomePage&quot; }, path: &quot;main/home&quot;, name: &quot;home&quot; }, { meta: {title: currentPathObj.meta.title}, path: &quot;&quot;, name: &quot;&quot; }, { meta: {title: childObj.meta.title}, path: &quot;&quot;, //设为空是因为此二级菜单没有实际页面且用于面包屑组件显示，path为空的将不可单击 name: &quot;&quot; }, { meta: {title: thirdObj.meta.title}, path: currentPathObj.path + &quot;/&quot; + childObj.path + &quot;/&quot; + thirdObj.path, name: thirdObj.name } ]; } } } } vm.$store.commit(&quot;app/setCurrentPath&quot;, currentPathArr); return currentPathArr; }修改根据菜单权限加载菜单如果不修改加载权限，则第三级菜单无法用权限控制，第二级菜单也必须定义权限才能显示。如果第二级菜单只是目录，第三级菜单都没有权限，那么第二级目录是不应该显示出来的。在store-&amp;gt;modules-&amp;gt;app.ts中修改updateMenulist方法如下：updateMenulist(state: AppState) { let menuList: Array&amp;lt;Router&amp;gt; = []; [...appRouters,...organizeRouters,...labRouters,...labcheckRouters, ...devRouters,...labreportRouters,...appraiseRouters].forEach((item, index) =&amp;gt; { if (item.permission !== undefined) { Util.addHasPermissionChileMenu(item); if(item.children&amp;amp;&amp;amp;item.children.length&amp;gt;0){ menuList.push(item); } // let hasPermissionMenuArr: Array&amp;lt;Router&amp;gt; = []; // hasPermissionMenuArr = item.children.filter(child =&amp;gt; { // if (child.permission !== undefined) { // if (Util.abp.auth.hasPermission(child.permission)) { // return child; // } // } else { // return child; // } // }); // if (hasPermissionMenuArr.length &amp;gt; 0) { // item.children = hasPermissionMenuArr; // menuList.push(item); // } } else { if (item.children.length === 1) { menuList.push(item); } else { let len = menuList.push(item); let childrenArr = []; childrenArr = item.children.filter(child =&amp;gt; { return child; }); let handledItem = JSON.parse(JSON.stringify(menuList[len - 1])); handledItem.children = childrenArr; menuList.splice(len - 1, 1, handledItem); } } }); state.menuList = menuList;}在lib-&amp;gt;util文件中,增加方法如下：addHasPermissionChileMenu(item:any){ let that=this; let hasPermissionMenuArr: Array&amp;lt;Router&amp;gt; = []; if(!item.children){ return; } hasPermissionMenuArr = item.children.filter(child =&amp;gt; { let isFather=!!child.children; that.addHasPermissionChileMenu(child); let hasChildren=!!child.children if (isFather&amp;amp;&amp;amp;!hasChildren) { return false; } if (child.permission !== undefined) { if (that.abp.auth.hasPermission(child.permission)) { return child; } } else { return child; } }); if (hasPermissionMenuArr.length &amp;gt; 0) { item.children = hasPermissionMenuArr; }else{ item.children=null; }}增加三级菜单路由在component目录中增加一个显示三级菜单内容的容器three-leve-container.vue&amp;lt;template&amp;gt;&amp;lt;div&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { Component, Vue, Inject } from &quot;vue-property-decorator&quot;;import ViewUI from &quot;view-design&quot;;import AbpBase from &quot;../lib/abpbase&quot;;import util from &quot;../lib/util&quot;;@Component({ components: {}})export default class ThreeLeveContainer extends AbpBase { }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;修改打开后的tab做完以上步骤添加路由就能打开页面了，但是，你会发现打开菜单能正常打开一个新的tab页面，但是在打开同一个二级菜单下的两个三级菜单时，并没有打开新的tab，而是替换了前一次打开的tab内容，就需要修改lib-&amp;gt;util中的openNewPage方法如下： openNewPage(vm: Vue, name: string | undefined, argu?: any, query?: any) { // debugger; let pageOpenedList = vm.$store.state.app.pageOpenedList; let openedPageLen = pageOpenedList.length; let i = 0; let tagHasOpened = false; while (i &amp;lt; openedPageLen) { if (name === pageOpenedList[i].name) { // 页面已经打开 vm.$store.commit(&quot;app/pageOpenedList&quot;, { index: i, argu: argu, query: query }); tagHasOpened = true; break; } i++; } if (!tagHasOpened) { let tag = vm.$store.state.app.tagsList.filter((item: any) =&amp;gt; { if (!!item.children) { for (let index = 0; index &amp;lt; item.children.length; index++) { const element = item.children[index]; if (name === element.name) { return true; } } return false; } else { return name === item.name; } }); tag = tag[0]; if (tag) {debugger if (tag.children) { for (let index = 0; index &amp;lt; tag.children.length; index++) { const element = tag.children[index]; if (name === element.name) { tag=element; break; } } } else { tag = tag; } if (argu) { tag.argu = argu; } if (query) { tag.query = query; } vm.$store.commit(&quot;app/increateTag&quot;, tag); } } vm.$store.commit(&quot;app/setCurrentPageName&quot;, name); }现在可以修改你的菜单定义，在二级菜单下像第一级菜单下增加二级菜单一样增加三级菜单了，二级菜单的权限可以是undefined，二级菜单的component要定义成刚才增加的路由组件,这样不需要在后端定义具体的权限，自动根据三级菜单的权限决定是否显示二级菜单。 { path: &quot;/menu1&quot;, name: &quot;menu1&quot;, permission: &quot;&quot;, meta: { title: &quot;menu1&quot; }, icon: &quot;&amp;amp;#xe68a;&quot;, component: main, children: [ { path: &quot;menu2&quot;, permission: undefined, meta: { title: &quot;menu2&quot; }, name: &quot;menu2&quot;, component:() =&amp;gt; import(&quot;../components/three-leve-container.vue&quot;), children: [ { path: &quot;menu3&quot;, permission: &quot;menu3&quot;, meta: { title: &quot;menu3&quot; }, name: &quot;menu3&quot;, component: () =&amp;gt; import(&quot;../views/xxxx.vue&quot;) } ] }] }修改收缩菜单样式以上修改后菜单已经可以正常使用，只是在菜单收缩为图标菜单时，仍然无法显示三级菜单，还要修改components-&amp;gt;shrinkable-menu-&amp;gt;components-&amp;gt;sidebarMenuShrink.vue文件&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;template v-for=&quot;(item, index) in menuList&quot;&amp;gt; &amp;lt;div style=&quot;text-align: center;&quot; :key=&quot;index&quot;&amp;gt; &amp;lt;Dropdown transfer v-if=&quot;item.children.length !== 1&quot; placement=&quot;right-start&quot; :key=&quot;index&quot; @on-click=&quot;changeMenu&quot;&amp;gt; &amp;lt;Button style=&quot;width: 80px;margin-right:5px;padding:10px 0;&quot; type=&quot;text&quot;&amp;gt; &amp;lt;i class=&quot;iconfont&quot; v-html=&quot;item.icon&quot; style=&quot;color:white&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/Button&amp;gt; &amp;lt;DropdownMenu slot=&quot;list&quot;&amp;gt; &amp;lt;template v-for=&quot;(child, i) in item.children&quot;&amp;gt; &amp;lt;DropdownItem transfer v-if=&quot;!hasChildren(child)&quot; :name=&quot;child.name&quot; :key=&quot;i&quot;&amp;gt;&amp;lt;Icon :type=&quot;child.icon&quot;&amp;gt;&amp;lt;/Icon&amp;gt;&amp;lt;span style=&quot;padding-left:10px;&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/DropdownItem&amp;gt; &amp;lt;Dropdown transfer v-else placement=&quot;right-start&quot; :key=&quot;i&quot; @on-click=&quot;changeMenu&quot;&amp;gt; &amp;lt;DropdownItem &amp;gt;&amp;lt;span style=&quot;padding-left:10px;&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;Icon type=&quot;ios-arrow-forward&quot;&amp;gt;&amp;lt;/Icon&amp;gt;&amp;lt;/DropdownItem&amp;gt; &amp;lt;DropdownMenu slot=&quot;list&quot;&amp;gt; &amp;lt;template v-for=&quot;(ss, ii) in child.children&quot;&amp;gt; &amp;lt;DropdownItem :name=&quot;ss.name&quot; :key=&quot;ii&quot;&amp;gt;&amp;lt;Icon :type=&quot;ss.icon&quot;&amp;gt;&amp;lt;/Icon&amp;gt;&amp;lt;span style=&quot;padding-left:10px;&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/DropdownItem&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/DropdownMenu&amp;gt; &amp;lt;/Dropdown&amp;gt;&amp;lt;p v-if=&quot;hasChildren(child)&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/DropdownMenu&amp;gt; &amp;lt;/Dropdown&amp;gt; &amp;lt;Dropdown transfer v-else placement=&quot;right-start&quot; :key=&quot;index&quot; @on-click=&quot;changeMenu&quot; style=&quot;left:100px&quot;&amp;gt; &amp;lt;Button @click=&quot;changeMenu(item.children[0].name)&quot; style=&quot;width: 80px;margin-right:5px;padding:10px 0;&quot; type=&quot;text&quot;&amp;gt; &amp;lt;Icon :size=&quot;20&quot; :color=&quot;iconColor&quot; :type=&quot;item.icon&quot;&amp;gt;&amp;lt;/Icon&amp;gt; &amp;lt;/Button&amp;gt; &amp;lt;DropdownMenu style=&quot;width: 200px;&quot; slot=&quot;list&quot;&amp;gt; &amp;lt;DropdownItem :name=&quot;item.children[0].name&quot; :key=&quot;&#39;d&#39; + index&quot;&amp;gt;&amp;lt;Icon :type=&quot;item.icon&quot;&amp;gt;&amp;lt;/Icon&amp;gt;&amp;lt;span style=&quot;padding-left:10px;&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/DropdownItem&amp;gt; &amp;lt;/DropdownMenu&amp;gt; &amp;lt;/Dropdown&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { Component, Vue,Inject,Prop,Emit } from &#39;vue-property-decorator&#39;;import AbpBase from &#39;../../../lib/abpbase&#39;@Componentexport default class extends AbpBase { name:string=&#39;sidebarMenuShrink&#39;; @Prop({type:Array}) menuList:Array&amp;lt;any&amp;gt;; @Prop({default:&#39;white&#39;}) iconColor:string; @Prop({default:&#39;darck&#39;}) menuTheme:string; @Emit(&#39;on-change&#39;) changeMenu(active:string){ } itemTitle(item:any){ return this.L(item.meta.title); } hasChildren(item:any){ return !!item.children&amp;amp;&amp;amp;item.children.length&amp;gt;0 } getChildren(item:any){ return item.children; }}&amp;lt;/script&amp;gt;参考资料 Vue iview-admin模板二级菜单改为三级菜单" }, { "title": "abp部分接口转换为首字母大写返回", "url": "/post/abp%E9%83%A8%E5%88%86%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99%E8%BF%94%E5%9B%9E", "categories": "abp部分接口转换为首字母大写返回", "tags": "", "date": "2019-12-18 19:04:12 +0800", "snippet": "在对接手机端app接口时，由于手机端需要返回的模型使用首字母大写的形式，abp(asp.net core)接口默认返回的数据是驼峰命名法，就是首字母小写，我们自己的pc网页端又是使用的驼峰法，所以不能直接改mvc的配置，这样pc端所有的接口都要改。有同学是用的给字段指定json序列化名称： [JsonProperty(&quot;Id&quot;)] public Guid Id { get; set; }这样写不知道他累不累解决过程很曲折，不提也罢，直接说方案：我们想要的效果是指定的接口(类型)使用指定的方式返回json格式。微软爸爸给我们提供了IOutputFormatter接口用来格式化返回结果，我们就用这个接口来实现创建自定义的格式化器 public class JsonFormatter : JsonOutputFormatter { public const string FormatterName = &quot;PacalJson&quot;; public JsonFormatter(JsonSerializerSettings serializerSettings, ArrayPool&amp;lt;char&amp;gt; charPool) : base(serializerSettings, charPool) { serializerSettings.ContractResolver = new DefaultContractResolver(); } protected override bool CanWriteType(Type type) { //我的接口有两种返回包装类型XXX和XXX2，所以我直接根据返回类型判断了，拿到了类型，还可以通过特性判断，根据需要自己调整，如果你调试发现type是Abp.Web.Models.AjaxResponse类型，这是因为abp提前进行序列化了，在controller上添加特性[Abp.Web.Models.DontWrapResult],不使用abp默认的序列化 if (type != null &amp;amp;&amp;amp; type.IsGenericType &amp;amp;&amp;amp; (typeof(XXX&amp;lt;&amp;gt;).IsAssignableFrom(type.GetGenericTypeDefinition()) || typeof(XXX2&amp;lt;&amp;gt;).IsAssignableFrom(type.GetGenericTypeDefinition()))) { return true; } return false; } }修改Startup文件的ConfigureServices方法中的AddMvc代码services.AddMvc( options =&amp;gt; { options.Filters.Add(new CorsAuthorizationFilterFactory(_defaultCorsPolicyName)); var JsonSerializerSettings = new Newtonsoft.Json.JsonSerializerSettings { ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore, ContractResolver = new DefaultContractResolver() }; var jsonOutputFormatter = new JsonFormatter(JsonSerializerSettings, ArrayPool&amp;lt;char&amp;gt;.Shared); options.OutputFormatters.Insert(0, jsonOutputFormatter); } );在controller上添加特性,不使用abp默认的序列化 [Abp.Web.Models.DontWrapResult]public class XXXController{}参考资料 IOutputFormatter Interface ASP.NET Core Web API 中的自定义格式化程序 Asp.Net Core Mvc上的首字母大小写的问题" }, { "title": "Vue+abp树形表格", "url": "/post/Vue+abp%E6%A0%91%E5%BD%A2%E8%A1%A8%E6%A0%BC", "categories": "Vue+abp树形表格", "tags": "", "date": "2019-12-14 19:29:52 +0800", "snippet": "项目中需要用到树形表格，其他同学找了一个ZkTable，我也就跟着用了，不太好用，有更好的记得联系我。先说下缺点，如果这些不能满足你，后面也没必要看了。缺点如下（也可能我不会用，如果你会一定记得告诉我）： 第一列不能使用模板数据，必须是简单的属性字段，也就不能使用自定义html标签了，如果你用了，不好意思，整个数据显示不出来 单选没有高亮（根本没有单选？），反正我用的多选框代替单选 模板使用的插槽而不是render函数，模板复选框绑定的数据只能单向绑定，即在界面点选可以修改属性值，但是修改属性值不会更新页面选中状态 没有分页 绑定数据不能直接使用属性套vuex中的数据，更新了数据不会刷新页面使用方法首先安装插件yarn add vue-table-with-tree-grid在页面中引用&amp;lt;template&amp;gt; &amp;lt;zk-table ref=&quot;table&quot; sum-text=&quot;sum&quot; index-text=&quot;#&quot; :data=&quot;listdata&quot; :columns=&quot;columns&quot; :stripe=&quot;props.stripe&quot; :border=&quot;props.border&quot; :show-header=&quot;props.showHeader&quot; :show-summary=&quot;props.showSummary&quot; :show-row-hover=&quot;props.showRowHover&quot; :show-index=&quot;props.showIndex&quot; :tree-type=&quot;props.treeType&quot; :is-fold=&quot;props.isFold&quot; :expand-type=&quot;props.expandType&quot; :selection-type=&quot;props.selectionType&quot; &amp;gt; &amp;lt;template slot=&quot;selectChk&quot; scope=&quot;scope&quot;&amp;gt; &amp;lt;Checkbox v-model=&quot;chkmodel(scope.row).isChecked&quot;&amp;gt;&amp;lt;/Checkbox&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/zk-table&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { Component, Vue, Inject, Prop, Watch } from &quot;vue-property-decorator&quot;;import util from &quot;@/lib/util&quot;;import PageRequest from &quot;@/store/entities/page-request&quot;;import AbpBase from &quot;@/lib/abpbase&quot;;import ZkTable from &quot;vue-table-with-tree-grid&quot;;Vue.use(ZkTable);export default class xxx extends AbpBase{ props: any = { stripe: true, //是否显示间隔斑马纹 border: true, //是否显示纵向边框 showHeader: true, //是否显示表头 showSummary: false, //是否显示表尾合计行 showRowHover: true, //鼠标悬停时，是否高亮当前行 showIndex: false, //是否显示数据索引 treeType: true, //是否为树形表格 isFold: false, //树形表格中父级是否默认折叠 expandType: false, //是否为展开行类型表格（为 True 时，需要添加作用域插槽, 它可以获取到 row, rowIndex) selectionType: false //是否为多选类型表格 }; listdata: any = []; get list() { return this.listdata; //********这里不能直接用vuex的数据做属性，更新了数据界面不会跟新******** //return this.$store.state.xxx.List; } async search() { request={}; console.log(this.request) await this.$store.dispatch({ type: &quot;xxx/getList&quot;, data: request }); this.listdata = this.$store.state.xxx.List; } chkmodel(row) { return this.getChkModel(row.id, this.listdata); } getChkModel(id, ls: Array&amp;lt;any&amp;gt;) { for (let index = 0; index &amp;lt; ls.length; index++) { const element = ls[index]; if (element.id == id) { return element; } if (!!element.children) { let c = this.getChkModel(id, element.children); if (!!c) { return c; } } } }columns = [ // { // label: &quot;名称&quot;, // type: &quot;template&quot;, // width: &quot;100px&quot;, // template: &quot;namede&quot; // }, { label: &quot;名称&quot;, prop: &quot;name&quot;, resizable: true }, { label: &quot;类型&quot;, prop: &quot;typeName&quot; }, { label: &quot;选中&quot;, type: &quot;template&quot;, width: &quot;100px&quot;, template: &quot;selectChk&quot; } ];}&amp;lt;/script&amp;gt;嗯，就这样参考资料 ZkTable" }, { "title": "abp替换IRepository默认注入类型", "url": "/post/abp%E6%9B%BF%E6%8D%A2IRepository%E9%BB%98%E8%AE%A4%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B", "categories": "abp替换IRepository默认注入类型", "tags": "", "date": "2019-12-09 19:01:35 +0800", "snippet": "如果要想重写部分方法，但是又没有实现自定义仓储，就必须从项目的抽象仓储入手，就是继承自EfCoreRepositoryBase的XXXRepositoryBase&amp;lt;TEntity, TPrimaryKey&amp;gt;和XXXRepositoryBase。实现方法 去掉abstract关键字，把XXXRepositoryBase&amp;lt;TEntity, TPrimaryKey&amp;gt;和XXXRepositoryBase改为非抽象类 修改构造函数的访问级别为pulic，否则依赖注入无法实例化对象 在ef上下文类XXXDbContext增加特性 [AutoRepositoryTypes( typeof(IRepository&amp;lt;&amp;gt;), typeof(IRepository&amp;lt;,&amp;gt;), typeof(HItekLabRepositoryBase&amp;lt;&amp;gt;), typeof(HItekLabRepositoryBase&amp;lt;,&amp;gt;))] public class XXXDbContext : AbpZeroDbContext&amp;lt;Tenant, Role, User, XXXDbContext&amp;gt;{ //... }皮卡丘，就决定用你了。参考资料 ABP官方文档翻译 9.2 Entity Framework Core AspnetBoilerplate modular: The entity type XXX is not part of the model for the current context Custom repository exception" }, { "title": "abp_vue导入导出excel", "url": "/post/abp_vue%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAexcel", "categories": "abp_vue导入导出excel", "tags": "", "date": "2019-12-06 19:33:39 +0800", "snippet": "后端abp，前端vue导入excel，开始准备用直接用npoi，觉得要写太多的代码，就算从以前的复制粘贴也麻烦，所以偷懒直接用别人的轮子Magicodes.IE。这样可以节省很多工作，根据实体生成excel模板、支持枚举、导入时自动验证数据是否合法（必填、类型等）Excel模板要导入首先要有录入数据的excel模板，以前都是把模板做好，放到服务器上，给一个下载链接给用户下载，这里可以直接用对象动态生成模板。 //ExcelAppService.cs /// &amp;lt;summary&amp;gt; /// 生成excel模板 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;模板内容实体&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;下载文件名称&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;输出文件流&amp;lt;/returns&amp;gt; internal async Task&amp;lt;FileContentResult&amp;gt; GetTemplate&amp;lt;T&amp;gt;(string fileName = &quot;模板&quot;) where T : class, new() { byte[] fileBytes = await importer.GenerateTemplateBytes&amp;lt;T&amp;gt;(); return new FileContentResult(fileBytes, System.Net.Mime.MediaTypeNames.Application.Octet) { FileDownloadName = $&quot;{fileName}.xlsx&quot; }; }importer是在构造函数中注入的IImporter类型,如果你使用注入需要先在module的Initialize()方法中注册。//module.Initialize()方法IocManager.Register&amp;lt;Magicodes.ExporterAndImporter.Core.IImporter, Magicodes.ExporterAndImporter.Excel.ExcelImporter&amp;gt;(DependencyLifeStyle.Transient);你也可以直接使用IImporter importer=new ExcelImporter()生成模板就做完了，剩下的就是在需要下载的地方调用此方法，公开一个api接口就可以了/// &amp;lt;summary&amp;gt;/// 下载导入模板/// &amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;public async Task&amp;lt;ActionResult&amp;gt; GetTemplate(){ return await excelAppService.GetTemplate&amp;lt;XXXXImportExcelDto&amp;gt;();}XXXXImportExcelDto是导入的实体类型，具体定义方式可以见https://github.com/xin-lai/Magicodes.IE如果你用的abp官方提供的vue项目，使用的axios请求后端，也就是ajax请求，这个文件流是不会弹出保存文件框的，需要在axios请求后拦截文件流弹出下载框。找到src\\lib\\ajax.ts文件,修改ajax.interceptors.response方法，并添加一个downloadUrl方法,如果后端验证了权限（登录），那么这里下载请求会出错”Refused to display in a frame because it set ‘X-Frame-Options’ to ‘sameorigin’“，要么取消后端权限（登录）验证，要么在url中把jwtToken带上，我选择带上token。++ import AppConsts from &#39;./appconst&#39;++ import Util from &#39;./util&#39;ajax.interceptors.response.use((respon)=&amp;gt;{ ++ //拦截文件下载请求++ if (respon.headers &amp;amp;&amp;amp; (respon.headers[&#39;content-type&#39;] === &#39;application/octet-stream&#39;)) {++ downloadUrl(respon.request.responseURL)++ respon.data=&#39;&#39;;++ respon.headers[&#39;content-type&#39;] = &#39;text/json&#39;++ return respon;++ } return respon},(error)=&amp;gt;{ if(!!error.response&amp;amp;&amp;amp;!!error.response.data.error&amp;amp;&amp;amp;!!error.response.data.error.message&amp;amp;&amp;amp;error.response.data.error.details){ vm.$Modal.error({title:error.response.data.error.message,content:error.response.data.error.details}) }else if(!!error.response&amp;amp;&amp;amp;!!error.response.data.error&amp;amp;&amp;amp;!!error.response.data.error.message){ vm.$Modal.error({title:window.abp.localization.localize(&quot;LoginFailed&quot;),content:error.response.data.error.message}) }else if(!error.response){ vm.$Modal.error(window.abp.localization.localize(&#39;UnknownError&#39;)); } setTimeout(()=&amp;gt;{ vm.$Message.destroy(); },1000); return Promise.reject(error);})++const downloadUrl = url =&amp;gt; {++ var encryptedAuthToken = Util.abp.utils.getCookieValue(AppConsts.authorization.encrptedAuthTokenName);++ let iframe = document.createElement(&#39;iframe&#39;)++ iframe.style.display = &#39;none&#39;++ iframe.src = url+&quot;?&quot;+AppConsts.authorization.encrptedAuthTokenName + &quot;=&quot; + encodeURIComponent(encryptedAuthToken)++ iframe.onload = function () {++ document.body.removeChild(iframe)++ }++ document.body.appendChild(iframe)++}后端 Web.Host.Startup.AuthConfigurer类中的QueryStringTokenResolver private static Task QueryStringTokenResolver(MessageReceivedContext context) {-- if (!context.HttpContext.Request.Path.HasValue ||-- !context.HttpContext.Request.Path.Value.StartsWith(&quot;/signalr&quot;))++ if (!context.HttpContext.Request.Path.HasValue++ || !(context.HttpContext.Request.Path.Value.StartsWith(&quot;/signalr&quot;)++ || context.HttpContext.Request.Path.Value.Contains(&quot;/GetTemplate&quot;))++ ) { // We are just looking for signalr clients return Task.CompletedTask; } var qsAuthToken = context.HttpContext.Request.Query[&quot;enc_auth_token&quot;].FirstOrDefault(); if (qsAuthToken == null) { // Cookie value does not matches to querystring value return Task.CompletedTask; } // Set auth token from cookie context.Token = SimpleStringCipher.Instance.Decrypt(qsAuthToken, AppConsts.DefaultPassPhrase); return Task.CompletedTask; }导入excel导入分为两步：上传excel文件和解析数据。由于没有找到一个一次能处理这两步的方法（因为需要指定解析后的类型，这是一个强类型参数），我采用的方式是： 加一个自定义组件，主要用于上传，提供一个上传完成事件,在上传完成后触发事件并传入后台excel文件的名称， 使用的地方绑定事件并把带着文件名请求后台， 后台再调用通用方法的解析数据定义组件&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;Upload :action=&quot;uploadURL&quot; :on-success=&quot;onSuccess&quot; accept=&quot;.xls, .xlsx&quot; :show-upload-list=&quot;false&quot; &amp;gt; &amp;lt;Button icon=&quot;android-add&quot; type=&quot;primary&quot;&amp;gt;&amp;lt;/Button&amp;gt; &amp;lt;/Upload&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { Component, Vue, Inject, Prop, Watch } from &quot;vue-property-decorator&quot;;import Util from &quot;../../lib/util&quot;;import AbpBase from &quot;../../lib/abpbase&quot;;import appconst from &quot;../../lib/appconst&quot;;@Componentexport default class ImportExcel extends AbpBase { uploadURL = appconst.remoteServiceBaseUrl + &quot;/api/services/app/Excel/UploadExcelFile&quot;; async onSuccess(response, file, fileList) { //上传完成触发事件uploadCompleted this.$emit(&quot;uploadCompleted&quot;, response.result); } /**按钮显示内容 */ @Prop({ type: String, default: &quot;&quot; }) btnTitle: String;}&amp;lt;/script&amp;gt;&amp;lt;style lang=&quot;less&quot; scoped&amp;gt;&amp;lt;/style&amp;gt;后端接收文件方法 //ExcelAppService.cs /// &amp;lt;summary&amp;gt; /// 接收上传文件方法 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;file&quot;&amp;gt;文件内容&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;文件名称&amp;lt;/returns&amp;gt; public async Task&amp;lt;string&amp;gt; UploadExcelFile(IFormFile file) { //FileDir是存储临时文件的目录，相对路径 //private const string FileDir = &quot;/File/ExcelTemp&quot;; string url = await WriteFile(file, FileDir); string fullpath = Path.GetFullPath($&quot;{Environment.CurrentDirectory}&quot; + url); return Path.GetFileName(url); } /// &amp;lt;summary&amp;gt; /// 写入文件 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;avatar&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;reDir&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public async Task&amp;lt;string&amp;gt; WriteFile(IFormFile avatar, string reDir) { string reName = Guid.NewGuid() + Path.GetExtension(avatar.FileName); string dir = GetDirPath(reDir); string path = $&quot;{dir}\\\\{reName}&quot;; Stream stream = avatar.OpenReadStream(); using (FileStream fileStream = new FileStream(path, FileMode.Create)) { await avatar.CopyToAsync(fileStream); } return $&quot;{reDir}/{reName}&quot;; } public string GetDirPath(string reDir) { string dir = $&quot;{Environment.CurrentDirectory}/{reDir}&quot;; if (!Directory.Exists(dir)) { Directory.CreateDirectory(dir); } return Path.GetFullPath(dir); }使用组件&amp;lt;template&amp;gt; &amp;lt;ImprotExcel @uploadCompleted=&quot;importExcel&quot; :btnTitle=&quot;&#39;导入excel&#39;&quot; &amp;gt;&amp;lt;/ImprotExcel&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; async importExcel(fileName: string) { //请求后端api await this.$store.dispatch({ type: &quot;xxx/importExcel&quot;, data: { fileName: fileName, labId: this.labId } }); (&amp;lt;any&amp;gt;this.$Message).success({ background: true, content: &quot;导入成功&quot; }); }&amp;lt;/script&amp;gt;后端解析文件方法 /// &amp;lt;summary&amp;gt; /// 导入 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;input&quot;&amp;gt;导入excel参数&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [HttpPost] public async Task ImportExcel(XXXImprotExcelInput input) { var data = await excelAppService.GetData&amp;lt;XXXImportExcelDto&amp;gt;(input.FileName); if (!data.Any()) { return; } //你的逻辑 } //XXXImprotExcelInput.cs /// &amp;lt;summary&amp;gt; /// 导入excel /// &amp;lt;/summary&amp;gt; public class XXXImprotExcelInput { /// &amp;lt;summary&amp;gt; /// 上传的excel文件名称 /// &amp;lt;/summary&amp;gt; public string FileName { get; set; } //你的其他参数 } //ExcelAppService.cs /// &amp;lt;summary&amp;gt; /// 解析excel数据 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;要解析的数据类型&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;excel文件名称，不含路径&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; internal async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetData&amp;lt;T&amp;gt;(string fileName) where T : class, new() { var fullpath = GetFullPath(fileName); var result = await importer.Import&amp;lt;T&amp;gt;(fullpath); if (result.HasError) { var errFile = Path.GetFileNameWithoutExtension(fileName) + &quot;_&quot; + Path.GetExtension(fileName); //如果excel文件内容不符合要求（格式错误、必填数据未填、数据类型错误），则弹出错误提示并给出下载链接 throw new UserFriendlyException(&quot;导入错误&quot;, GetErrorExcelDownLoadUrl(errFile)); } return result.Data; } /// &amp;lt;summary&amp;gt; /// 下载excel文件 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [HttpGet] public async Task&amp;lt;FileContentResult&amp;gt; DownLoadFile(string fileName) { var fullPath = GetFullPath(fileName); byte[] fileBytes = await File.ReadAllBytesAsync(fullPath); return new FileContentResult(fileBytes, System.Net.Mime.MediaTypeNames.Application.Octet) { FileDownloadName = fileName }; } /// &amp;lt;summary&amp;gt; /// 获取文件全路径 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string GetFullPath(string fileName) { fileName = Path.GetFileName(fileName); var fullpath = Path.GetFullPath(Environment.CurrentDirectory.EnsureEndsWith(&#39;/&#39;) + FileDir.EnsureEndsWith(&#39;/&#39;) + fileName); return fullpath; } /// &amp;lt;summary&amp;gt; /// 获取excel下载链接 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string GetErrorExcelDownLoadUrl(string fileName) { return $&quot;请按照excel文件内的错误提示修改后再次导入，&amp;lt;a href=&#39;{GetHost()}/api/services/app/Excel/DownLoadFile?fileName={fileName}&#39; target=&#39;_blank&#39;&amp;gt;点击下载excel&amp;lt;/a&amp;gt;&quot; ; } /// &amp;lt;summary&amp;gt; /// 获取当前域名地址 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string GetHost() { var req = httpContextAccessor.HttpContext.Request; return $&quot;{req.Scheme}://{req.Host}&quot;; }参考资料 Magicodes.IE" }, { "title": "vue(abp)使用自定义指令实现按钮(任意元素)权限过滤", "url": "/post/vue%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90%E8%BF%87%E6%BB%A4", "categories": "vue使用自定义指令实现按钮权限过滤", "tags": "", "date": "2019-11-29 15:55:54 +0800", "snippet": "在使用vue(后端abp)开发中，需要根据权限对按钮进行显示隐藏，问下了公司大神（开发过angular的，可以使用自定义指令），vue应该也有对应的方式，毕竟天下代码差(一)不(大)多(抄);添加自定义指令在main.ts中添加如下自定义指令Vue.directive(&#39;role&#39;, { inserted: function (el,binding) { //支持权限数组[&quot;Permission1&quot;,&quot;Permission2&quot;,true],最后一个boolean类型参数可选，表示是同时满足还是满足任意一个 if (typeof binding.value ===&quot;object&quot;) { let length=binding.value.length-1; if(typeof(binding.value[length])===&quot;boolean&quot;&amp;amp;&amp;amp;binding.value[length]===true){ //必须满足全部权限 if(!binding.value.slice(0,length).every(i=&amp;gt;Util.abp.auth.hasPermission(i))){ el.parentNode.removeChild(el); } }else{ if(typeof(binding.value[length])===&quot;boolean&quot;) { length=length-1; } if(!binding.value.slice(0,length).some(i=&amp;gt;Util.abp.auth.hasPermission(i))){ el.parentNode.removeChild(el); } } } //权限字符串 else{ if (!Util.abp.auth.hasPermission(binding.value)) { el.parentNode.removeChild(el); } } // console.log(el,binding); }})使用方法&amp;lt;Button @click=&quot;create&quot; icon=&quot;android-add&quot; type=&quot;primary&quot; v-role=&quot;&#39;UploadList&#39;&quot;&amp;gt;一个权限&amp;lt;/Button&amp;gt;&amp;lt;Button @click=&quot;create&quot; icon=&quot;android-add&quot; type=&quot;primary&quot; v-role=&quot;[&#39;UploadList&#39;,&#39;UploadList1&#39;]&quot;&amp;gt;满足多个权限中任意一个&amp;lt;/Button&amp;gt;&amp;lt;Button @click=&quot;create&quot; icon=&quot;android-add&quot; type=&quot;primary&quot; v-role=&quot;[&#39;UploadList&#39;,&#39;UploadList1&#39;,true]&quot;&amp;gt;多个权限全部满足&amp;lt;/Button&amp;gt; 参考资料自定义指令" }, { "title": "vue使用watch没有效果", "url": "/post/vue%E4%BD%BF%E7%94%A8watch%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C", "categories": "vue使用watch没有效果", "tags": "", "date": "2019-11-14 15:30:42 +0800", "snippet": "今天使用vue监控属性改变的时候遇到watch没有触发，记一下问题使用watch监控类中变量的属性值(timeSet)或属性(uploadSetInfoList)，timeSet值没有绑定到页面，在代码中改变timeSet值时，都无法触发watch的方法，但是监控其他值(绑定到页面的)，如果在页面改变值触发了watch方法后再在代码中改变值就能触发watch方法了，如果没有在页面改变值二十直接在代码中改变值还是无法触发watch方法；//@Watch(&quot;uploadSetInfoList&quot;,{immediate: true,deep:true})@Watch(&quot;uploadSetInfoList.timeSet&quot;,{immediate: true,deep:true})uploadSetInfoListChange() { console.log(&quot;watch&quot;)}解决正在探索……原因正在探索……" }, { "title": "实现通用IEqualityComparer比较器", "url": "/post/%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8IEqualityComparer%E6%AF%94%E8%BE%83%E5%99%A8", "categories": "实现通用IEqualityComparer比较器", "tags": "", "date": "2019-11-14 15:12:29 +0800", "snippet": "在使用Linq做两个列表的集合运算时(交集、并集、差集)，如果不是使用对象比较而是要用部分属性比较，需要用到比较器(如果没有比较器则会直接比较对象引用)，但是(垃圾)微软没有提供默认的比较器。问题每次比较一个类型都需要对类型实现比较器，有没有可以像写lambda表达式一样直接比较呢解决namespace System.Collections.Generic{ public class GenericCompare&amp;lt;T&amp;gt; : IEqualityComparer&amp;lt;T&amp;gt; where T : class { private Func&amp;lt;T, T, bool&amp;gt; Expr { get; set; } public GenericCompare(Func&amp;lt;T, T, bool&amp;gt; expr) { this.Expr = expr; } public bool Equals(T x, T y) { if (Expr(x, y)) return true; else return false; } public int GetHashCode(T obj) { return 0; } }}使用方法public class Test{ public void T1() { var ls1 = new List&amp;lt;Student&amp;gt; { new Student { Name=&quot;小明&quot;},new Student { Name=&quot;小红&quot;} }; var ls2 = new List&amp;lt;Student&amp;gt; { new Student { Name = &quot;小明&quot; }, new Student { Name = &quot;小钢&quot; } }; ls1.Except(ls2, new GenericCompare&amp;lt;Student&amp;gt;((x, y) =&amp;gt; x.Name == y.Name)); }}public class Student{ public string Name { get; set; }}" }, { "title": "使用Ionic打包网页成App并识别二维码", "url": "/post/%E4%BD%BF%E7%94%A8Ionic%E6%89%93%E5%8C%85%E7%BD%91%E9%A1%B5%E6%88%90App%E5%B9%B6%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81", "categories": "使用Ionic打包网页成App并识别二维码", "tags": "", "date": "2019-10-29 14:27:43 +0800", "snippet": "以前介绍过我们系统需要扫描识别二维码手机浏览器调用摄像头扫码网站搜索框使用微信扫码但是使用手机浏览器调用摄像头扫码的体验实在太差了，需要先拍照，还要拍的很清晰，稍微抖了一下就识别不了，这个坑挖下了，自然的填上。今天就是填坑来了，主要是使用ionic把网页打包成app，通过js使用ionic的插件来调用摄像头扫码。开始吧。开发网页开发手机版网页，没有手机版的可以用web版代替，没有web版现在开始开发。配置ionic安装nodejs到官网下载nodejs并安装安装ionicnpm install -g ionic创建ionic项目ionic start myApp添加Android平台生成环境安装Android studio (避免手动去下载jdk配置java、android环境，没办法习惯了vs的一键安装)生成android安装包ionic cordova build android修改首页指向自己的网页参照下图修改config.xml文件再次生成android安装包ionic cordova build android安装生成的app在目录platforms\\android\\app\\build\\outputs\\apk\\debug中找到生成的app复制到你的手机安装，打开之后应该就能看到你的页面了。二维码扫码安装二维码插件我最终选择使用的barcode-scanner插件barcode-scanner这个插件在浏览器上使用有摄像头关闭后页面被挡住的bug，有能力修改源码的大神可以试试，这个插件在网上介绍比较多qr-scanner还有一个插件网上介绍也比较多zbar,但是我安装后无法编译通过，经过几经挣扎最终选择了barcode-scanner。有其他更好的插件一定要发给我125880321@qq.com。安装比较简单，参照官方文档使用如下命令ionic cordova plugin add phonegap-plugin-barcodescannernpm install @ionic-native/barcode-scanner生成js包和app.apk安装包安装好插件什么也不需要做直接用上面介绍过的打包命令再次打包 到手机安装app 复制platforms\\android\\platform_www目录下的所有文件到你的web项目，并项目需要使用的地方添加cordova.js引用，只需引用这个文件就可以了 &amp;lt;script src=&quot;cordova.js&quot;&amp;gt;&amp;lt;/script&amp;gt;网页中调用二维码扫描复制以下代码到需要触发扫码的地方，如click事件中 cordova.plugins.barcodeScanner.scan( function (result) { /* alert(&quot;We got a barcode\\n&quot; + &quot;Result: &quot; + result.text + &quot;\\n&quot; + &quot;Format: &quot; + result.format + &quot;\\n&quot; + &quot;Cancelled: &quot; + result.cancelled); */ if (result.text != null &amp;amp;&amp;amp; result.text.length &amp;gt; 0) { alert(result.text) } else { //这里要加阻止网页回退，否则没有扫码，点击Android返回按钮时会在关闭相机的同时还会回退到上一页 window.history.pushState(&#39;forward&#39;, null, &#39;#&#39;); window.history.forward(1); //alert(&quot;空的&quot;) //return; } }, function (error) { alert(&quot;Scanning failed: &quot; + error); }, { preferFrontCamera : true, //前置摄像头 iOS and Android showFlipCameraButton : true, // iOS and Android showTorchButton : true, // iOS and Android torchOn: true, //开启闪光灯 Android, launch with the torch switched on (if available) saveHistory: true, // Android, save scan history (default false) prompt : &quot;Place a barcode inside the scan area&quot;, // Android resultDisplayDuration: 500, // Android, display scanned text for X ms. 0 suppresses it entirely, default 1500 formats : &quot;QR_CODE,PDF_417&quot;, // default: all but PDF_417 and RSS_EXPANDED orientation : &quot;landscape&quot;, //屏幕方向随系统 Android only (portrait|landscape), default unset so it rotates with the device disableAnimations : true, // iOS disableSuccessBeep: false // iOS and Android } );部分问题说明 在点击Android返回键返回时关闭相机又回退了一页，如果调用扫描你复制的官方代码，请参照我给的代码修改 在pc浏览器打开网页会出现几个弹出，要是直接点确定，会造成浏览器卡死，如果点取消或者把弹出框内容删除点确定则没事。这个是插件的bug(有人提了issue，ionic团队把锅丢给了插件)，使用了旧版接口，网上有很多答案，但是都无效。你不能奢望用户来点取消，我的解决方案是在浏览器打开页面时不加载cordova.js，具体做法是在app打开页面时会传递一个特殊的参数，页面获取到参数后存入cookie，使用的地方从cookie中读取这个参数，有这个参数表示是app打开页面，动态加载cordova.js，否正不加载仍然用以前的方式扫码。发布app修改图标打包release版app见官方文档参考资料 ionic文档 扫码插件barcodescanner 报错processmessage failed: invalid message 报错processmessage failed: invalid message解决方法" }, { "title": "IDisposable释放资源模板", "url": "/post/IDisposable%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90%E6%A8%A1%E6%9D%BF", "categories": "IDisposable释放资源模板", "tags": "", "date": "2019-10-28 19:46:53 +0800", "snippet": "public class FatherClass : IDisposable{ private bool isDisposed = false; public void Dispose() { Dispose(true); // 通知 GC，这个对象已经完全被清理。 GC.SuppressFinalize(this); } ~FatherClass() { Dispose(false); } protected virtual Dispose(bool isDisposing) { if (isDisposed) return; if (isDisposing) { // 释放托管资源。 } // 释放非托管资源。 isDisposed = true; } public void TestMethod() { if (isDisposed) { throw new ObjectDisposedException(&quot;对象已经被释放。&quot;); } }}public class ChildClass : FatherClass{ private bool isDisposed = false; protected override void Dispose(bool isDisposing) { if (isDisposed) return; if (isDisposing) { // 释放托管资源。 } base.Dispose(isDisposing); isDisposed = true; }}参考资料" }, { "title": "网站搜索框使用微信扫码", "url": "/post/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2%E6%A1%86%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81", "categories": "网站搜索框使用微信扫码", "tags": "", "date": "2019-08-15 14:14:08 +0800", "snippet": "背景客户要求可以直接识别标签二维码对某些仪器设备进行管理，类似于淘宝搜索框可以直接拍照搜索商品一样。前面已经做了一个网页调用摄像头识别二维码的功能，此功能有两个缺陷： 识别需要先拍照，不能直接识别 识别率低，尤其是拍照抖动，二维码内容稍微多一点或二维码小一点就识别不了。以上两点相加就相当不好用了。使用微信扫码鉴于我们的系统已经集成到了微信公众号，所以准备调用微信扫码（只有在微信内打开的页面才能使用微信扫码）。参照官方文档绑定域名打开公众号设置选择功能设置添加JS接口安全域名，注意你添加的域名目录下面上次图中微信指定的文件，如果文件没在根目录，域名需要填写到子目录引入JS文件使用vs2019创建默认的asp.net mvc项目在index.cshtml页面中使用的页面引用js&amp;lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.1.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;前端主要代码$(function () { /** * 判断是否微信内部打开页面 * */ function isWeiXin() { var ua = window.navigator.userAgent.toLowerCase(); console.log(ua);//mozilla/5.0 (iphone; cpu iphone os 9_1 like mac os x) applewebkit/601.1.46 (khtml, like gecko)version/9.0 mobile/13b143 safari/601.1 if (ua.match(/MicroMessenger/i) == &#39;micromessenger&#39;) { return true; } else { return false; } } /** * 只有微信内部页面打开才能用 * */ if (isWeiXin()) { $.ajax({ type: &quot;post&quot;, url: &quot;/Home/GetSingDataAsync&quot;, data: { &quot;url&quot;: location.href.split(&#39;#&#39;)[0] }, dataType: &quot;json&quot;, success: function (data) { alert(JSON.stringify(data)); wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: [ &#39;checkJsApi&#39;, &#39;startRecord&#39;, &#39;stopRecord&#39;, &#39;translateVoice&#39;, &#39;scanQRCode&#39;,// 微信扫一扫接口 &#39;openCard&#39; ] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 }); wx.error(function (res) { alert(&quot;出错了：&quot; + res.errMsg);//这个地方的好处就是wx.config配置错误，会弹出窗口哪里错误，然后根据微信文档查询即可。 }); wx.ready(function () { wx.checkJsApi({ jsApiList: [&#39;scanQRCode&#39;], success: function (res) { //扫描二维码 wx.scanQRCode({ needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， scanType: [&quot;qrCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有 success: function (res) { var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果 alert(result);//因为我这边是扫描后有个链接，然后跳转到该页面 }, error: function () { console.log(&#39;123&#39;); } }); } }); }); }, error: function (url) { alert(&quot;An error occurred!&quot;); } }); } else { alert(&quot;请使用微信打开&quot;); }}) 后端代码public class HomeController : Controller{ //把APPID和APP_SECRET换成你自己的 private const string APPID = &quot;******&quot;; private const string APP_SECRET = &quot;******&quot;; //为了调试方便我这里第一次把Token和Ticket获取到之后就写死了，应该写入缓存（7200s过期） private static string Token = &quot;24_cQsz9scwyXLnPaAes5JlfHTfuQ2e3Iw5L8JyWfUpQiMnTk4IToOTZ7dP0Fv190ZHTy5ST--jeuDzYwoUj_hvhSHDX288YYLYVcrmvMzRPwld8ccTTzWGNTKZz53jYKDy5f8U1E886msDPsrwORGbAJABET&quot;; private static string Ticket = &quot;HoagFKDcsGMVCIY2vOjf9qZA_fkPP3enjnT58qu16hzZN-3kwAP0NK6jgQM0jyAc0sK8cxaGkT9_DSgp6cHCpw&quot;; public ActionResult Index() { return View(); } public ActionResult About() { ViewBag.Message = &quot;Your application description page.&quot;; return View(); } public ActionResult Contact() { ViewBag.Message = &quot;Your contact page.&quot;; return View(); } public async Task GetToken() { await GetTicketAsync(); } //获取token和ticket private async Task&amp;lt;string&amp;gt; GetTicketAsync() { var tokenUrl = $&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid={APPID}&amp;amp;secret={APP_SECRET}&quot;; var client = new System.Net.WebClient(); client.Encoding = Encoding.UTF8; client.Headers.Add(&quot;Content-Type&quot;, &quot;Application/x-www-form-urlencoded&quot;); var responseData = client.UploadData(tokenUrl, &quot;POST&quot;, new byte[0]); var responseText = Encoding.UTF8.GetString(responseData); var token = JsonConvert.DeserializeAnonymousType(responseText, new { access_token = &quot;&quot;, expires_in = &quot;&quot; }); Token = token.access_token; var ticketUrl = $&quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Token}&amp;amp;type=jsapi&quot;; var ticResponseData = client.UploadData(ticketUrl, &quot;POST&quot;, new byte[0]); var ticResponseText = Encoding.UTF8.GetString(ticResponseData); var ticket = JsonConvert.DeserializeAnonymousType(ticResponseText, new { errcode = &quot;&quot;, errmsg = &quot;&quot;, ticket = &quot;&quot;, expires_in = &quot;&quot; }); Ticket = ticket.ticket; return &quot;&quot;; } //获取签名字符串 public async Task&amp;lt;string&amp;gt; GetSingDataAsync(string url) { var sign = new SignData(); sign.appId = APPID; sign.nonceStr = Create_nonce_str(); sign.timestamp = Create_timestamp(); //var url = Request.Url.AbsoluteUri; if (url.IndexOf(&#39;#&#39;) &amp;gt; 0) { url = url.Substring(0, url.IndexOf(&#39;#&#39;)); } sign.url = url; var string1 = &quot;jsapi_ticket=&quot; + Ticket + &quot;&amp;amp;noncestr=&quot; + sign.nonceStr + &quot;&amp;amp;timestamp=&quot; + sign.timestamp + &quot;&amp;amp;url=&quot; + sign.url; //var string1 = GetTestSign(); var sha1 = SHA1.Create(); sign.signature = ByteToHex(sha1.ComputeHash(Encoding.UTF8.GetBytes(string1))); return JsonConvert.SerializeObject(sign); } //测试签名字符串，和微信官方提供的一样，用来测试签名方法是否正确 private string GetTestSign() { var nonceStr = &quot;Wm3WZYTPz0wzccnW&quot;; var ticket = &quot;sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg&quot;; var timestamp = &quot;1414587457&quot;; var url = &quot;http://mp.weixin.qq.com?params=value&quot;; var string1 = &quot;jsapi_ticket=&quot; + ticket + &quot;&amp;amp;noncestr=&quot; + nonceStr + &quot;&amp;amp;timestamp=&quot; + timestamp + &quot;&amp;amp;url=&quot; + url; return string1; } /// &amp;lt;summary&amp;gt; /// 随机字符串 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string Create_nonce_str() { return Guid.NewGuid().ToString().Substring(0, 8); } /// &amp;lt;summary&amp;gt; /// 时间戳 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string Create_timestamp() { return (DateTime.Now.Ticks / 100000000).ToString(); } private string ByteToHex(byte[] hash) { var sb = new StringBuilder(); foreach (var b in hash) { sb.Append(b.ToString(&quot;x2&quot;)); } return sb.ToString(); }}代码已上传github" }, { "title": "手机浏览器调用摄像头扫码", "url": "/post/%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%89%AB%E7%A0%81", "categories": "手机浏览器调用摄像头扫码", "tags": "", "date": "2019-07-05 14:14:08 +0800", "snippet": "基本是按这个做的h5端呼起摄像头扫描二维码并解析，就不重复介绍了。只是重新压缩了下qrcode.lib.min.js文件，因为这个文章附带的原文件总是出现识别不了的情况，所以我从新打包了下jsqrcode下载地址,只是重新压缩了jsqrcode,你们可以自己压缩" }, { "title": "Linq查询连接guid与varchar字段", "url": "/post/Linq%E6%9F%A5%E8%AF%A2%E8%BF%9E%E6%8E%A5guid%E4%B8%8Evarchar%E5%AD%97%E6%AE%B5", "categories": "Linq查询连接guid与varchar字段", "tags": "", "date": "2019-07-02 14:14:08 +0800", "snippet": "使用场景在数据库设计中进场会出现一些通用表，如通用附件表，一般都是通过ForeignTable（关联的表名）和ForeignKey（关联表的主键）与其他表关联。这样的表在数据库中没有外键关系，而且一般ForeignKey的类型是varchar，为了兼容其他表的主键可能不一样。这样在Linq查询的时候就不能直接关联了，如下代码会编译不通过：from a in db.WorkflowInstancejoin b in d.xxx//xxx.ID为guid类型on new { a.ForeignTable, a.ForeignKey } equals new { ForeignTable = nameof(xxx), ForeignKey = b.ID }select a;因为xxx.id是Guid(uniqueidentifier)类型和WorkflowInstance.ForeignKey是string(varchar)类型。就算是强行把xxx.id转成string类型，编译通过了运行也会报错，如下：from a in db.WorkflowInstancejoin b in d.xxx//xxx.ID为guid类型on new { a.ForeignTable, a.ForeignKey } equals new { ForeignTable = nameof(xxx), ForeignKey = b.ID+&quot;&quot; }select a;以为这段代码最终都会转成sql语句，而Guid是不能直接转换成varchar的。解决方案如果xxx.id是数字类型(int,float,double,decimal)是可以使用SqlFunctions.StringConvert(xxx.id)转换成string类型，这样就可以了,SqlFunctions.StringConvert支持double和decimal，基本上数字都可以转换成这两种类型，但是注意下转换时小数点后0的个数，因为string比较时少一个0是不一样的。但是Guid不行，因为没有对应的函数。通过面向百度编程，微软爸爸给我们提供了一个解决方案：自定义函数。相当于我们自己实现一个SqlFunctions.StringConvert()。首先在数据库定义一个转换函数if EXISTS(select * from dbo.sysobjects where id = object_id(N&#39;[dbo].[ConvertGuidToChar]&#39;) and xtype in (N&#39;FN&#39;, N&#39;IF&#39;, N&#39;TF&#39;))drop function [dbo].ConvertGuidToCharGOCREATE FUNCTION ConvertGuidToChar( @id UNIQUEIDENTIFIER)RETURNS VARCHAR(50)ASBEGIN RETURN CONVERT(VARCHAR(50),@id)END把函数添加到db模型可以直接编辑edmx模型文件添加如下代码：&amp;lt;Function Name=&quot;ConvertGuidToChar&quot; ReturnType=&quot;varchar&quot; Schema=&quot;dbo&quot; &amp;gt; &amp;lt;Parameter Name=&quot;id&quot; Mode=&quot;In&quot; Type=&quot;uniqueidentifier&quot; /&amp;gt;&amp;lt;/Function&amp;gt;也可通过从数据库更新模型添加添加自定义函数对应的方法/// &amp;lt;summary&amp;gt;/// sql函数Guid转varchar/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;[EdmFunction(&quot;iLISModel.Store&quot;, &quot;ConvertGuidToChar&quot;)]public static string ConvertGuidToChar(Guid id){ throw new NotSupportedException(&quot;Direct calls are not supported.&quot;);}Linq中使用自定义函数转换类型from a in d.WorkflowInstancejoin b in d.xxx//xxx.ID为guid类型on new { a.ForeignTable, a.ForeignKey } equals new { ForeignTable = nameof(xxx), ForeignKey = SqlFunctionsExtension.ConvertGuidToChar(b.ID) }select a;这样就能正常查询数据了。注：codefirst是没有edmx模型的，但是应该可以通过其他方式添加，我没试，我随便说的，你别信啊。参考资料如何：调用自定义数据库函数" }, { "title": "Vue+abp微信扫码登录", "url": "/post/Vue+abp%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95", "categories": "Vue+abp微信扫码登录", "tags": "", "date": "2019-04-18 14:14:08 +0800", "snippet": "最近系统中要使用微信扫码登录，根据微信官方文档和网络搜索相关文献实现了。分享给需要的人，也作为自己的一个笔记。后端系统是基于ABP的，所以部分代码直接使用了abp的接口，直接拷贝代码编译不通过。注册微信开放平台账号在微信开放平台注册，注意是开放平台不是公众平台，这里需要300元，然后申请网站应用。审核通过后获取到AppID和AppSecret以及登记的网站url。只有此url下的地址微信扫码后才能回调。具体申请条件见官方文档。生成登录二维码在vue登录页面嵌入登录二维码，根据官方文档，在页面中放入一个div元素，二维码就放在此元素中，注意var obj = new WxLogin必须放在mounted方法中执行，此时vue才会把dom元素初始化挂载到dom树，可以参见vue官方文档生命周期介绍。&amp;lt;template&amp;gt; &amp;lt;div id=&quot;login&quot; class=&quot;login&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;WXLogin&quot;, data: function() { return {}; }, mounted() { this.wechatHandleClick(); document.getElementsByTagName(&quot;iframe&quot;)[0].height=&quot;320&quot;; document.getElementsByTagName(&quot;iframe&quot;)[0].style.marginLeft=&quot;30px&quot;; }, methods: { wechatHandleClick() { let ba64Css = &quot;css代码base64编码&quot;;// 微信需要https的样式路径，这里将样式内容加密base64，可以避免使用https，如果你的网站是https的可以直接使用安官方文档使用css文件路径 const appid = &quot;你第一步申请的Appid&quot;; const redirect_uri = encodeURIComponent(&quot;http://*/#/login&quot;); var obj = new WxLogin({ id: &quot;login&quot;, //div的id appid: appid, scope: &quot;snsapi_login&quot;,//固定内容 redirect_uri: redirect_uri, //回调地址 // href: &quot;http://*/static/UserCss/WeChart.css&quot; //自定义样式链接，第三方可根据实际需求覆盖默认样式。 href: &quot;data:text/css;base64,&quot; + ba64Css // state: &quot;&quot;, //参数，可带可不带 // style: &quot;&quot;, //样式 提供&quot;black&quot;、&quot;white&quot;可选，默认为黑色文字描述 }); } }};&amp;lt;/script&amp;gt;注册回调事件用户扫码后微信会回调访问前一步提供的redirect_uri，这里要监控微信回调，并用微信返回的code请求后端，在后端再去访问微信服务器获取token及用户openID在回调页面中监控路由改变事件以监控微信回调（因为我的二维码和回调在同一个路由页面），如果有其他更好的方法请告诉我。 @Watch(&quot;$route&quot;) async RouteChange(newVal, oldVal) { await this.weixinRedirect(); } // 请求微信后台 async weixinRedirect() { let code = this.$route.query.code; let state = this.$route.query.state; if (code) { let wxTo = { code, state }; //请求后台 this.$http(&quot;*/WeixinRedirect&quot;,data:wxTo).then((token)=&amp;gt;{ //登录成功，把token写入cookie //跳转到主页 this.$router.replace({ path: &quot;/&quot;, replace: true }); }).catch(error =&amp;gt; { //保持当前页面 this.$router.replace({ path: &quot;/login&quot;, replace: true }); }); } }}后端接收code请求token在appsettings.json中配置AppId和AppSecret[HttpPost]public async Task&amp;lt;AuthenticateResultModel&amp;gt; WeixinRedirect(string code, string state){ if (code.IsNullOrEmpty()) { throw new UserFriendlyException(&quot;微信授权失败，请重新授权&quot;); } var appid = configuration[&quot;Authentication:Wechat:AppId&quot;]; var secret = configuration[&quot;Authentication:Wechat:AppSecret&quot;]; var url = $&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid={appid}&amp;amp;secret={secret}&amp;amp;code={code}&amp;amp;grant_type=authorization_code&quot;; var httpClient = httpClientFactory.CreateClient(); httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;); httpClient.Timeout = TimeSpan.FromMinutes(3); var resstr = await httpClient.GetStringAsync(url); try{ //如果微信授权返回失败这里序列化不成功 var res = JsonSerializationHelper.DeserializeWithType&amp;lt;WeiXinAccess_tokenResponse&amp;gt;(resstr); }catch (Exception e) { throw new UserFriendlyException(&quot;获取微信access_token失败&quot;); } if (res == null || res.openid.IsNullOrEmpty()) { throw new UserFriendlyException(&quot;获取微信access_token失败&quot;); } var userId = //根据openID获取用户id，我们系统要求用户提前把微信和用户关联绑定，所以这里可以根据微信用户的openID获取到户农户id; //使用用户直接登录 if (!userId.IsNullOrEmpty()&amp;amp;&amp;amp;long.TryParse(userId, out long id)) { var user = await _userManager.GetUserByIdAsync(id); var loginResult = await _logInManager.LoginByUser(user); string accessToken = CreateAccessToken(CreateJwtClaims(loginResult.Identity)); return new AuthenticateResultModel { AccessToken = accessToken, EncryptedAccessToken = GetEncrpyedAccessToken(accessToken), ExpireInSeconds = (int)_tokenConfiguration.Expiration.TotalSeconds, UserId = loginResult.User.Id }; } throw new UserFriendlyException(&quot;微信尚未绑定账号，请使用账号登录后绑定微信。&quot;);}WeiXinAccess_tokenResponse类型public class WeiXinAccess_tokenResponse{ public string access_token { get; set; } public int expires_in { get; set; } public string refresh_token { get; set; } public string openid { get; set; } public string scope { get; set; } public string unionid { get; set; }}" }, { "title": "使用公钥访问码云", "url": "/post/%E4%BD%BF%E7%94%A8%E5%85%AC%E9%92%A5%E8%AE%BF%E9%97%AE%E7%A0%81%E4%BA%91", "categories": "使用公钥访问码云", "tags": "", "date": "2019-03-14 14:14:08 +0800", "snippet": "1.本地进入.ssh查看是否存在密钥对：xxx和xxx.pub命令：cd ~/.ssh2.如果不存在，使用ssh-keygen来创建命令：ssh-keygen -t rsa -C “youremail@youremail.com”例如：ssh-keygen -t rsa -C “wanwan5856@163.com”注解：Enter file in which to save the key 输入保存秘钥的文件 直接enter即可Enter passphrase (empty for no passphrase) 输入密码 直接enter即可此时查看.ssh目录下可看到新增的一对秘钥id_rsa和id_rsa.pub3.把id_rsa.pub中的公钥复制到gitee设置-安全设置-ssh公钥中4.如果以前是使用https下载的代码需要把https切换到sshgit remote set-url origin 仓库ssh地址" }, { "title": "vue学习笔记3", "url": "/post/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03", "categories": "vue学习笔记3", "tags": "", "date": "2019-03-11 14:14:08 +0800", "snippet": "定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法： var login = Vue.extend({template: &#39;&amp;lt;h1&amp;gt;登录&amp;lt;/h1&amp;gt;&#39; }); Vue.component(&#39;login&#39;, login); 直接使用 Vue.component 方法： Vue.component(&#39;register&#39;, {template: &#39;&amp;lt;h1&amp;gt;注册&amp;lt;/h1&amp;gt;&#39; }); 将模板字符串，定义到script标签种： &amp;lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;登录&amp;lt;/a&amp;gt; | &amp;lt;a href=&quot;#&quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/script&amp;gt; 同时，需要使用 Vue.component 来定义组件： Vue.component(&#39;account&#39;, {template: &#39;#tmpl&#39; }); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： Vue.component(&#39;account&#39;, { template: &#39;#tmpl&#39;, data() { return { msg: &#39;大家好！&#39; } }, methods:{ login(){ alert(&#39;点击了登录按钮&#39;); } } }); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问；【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示使用components属性定义局部子组件 组件实例定义方式： &amp;lt;script&amp;gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: {}, methods: {}, components: { // 定义子组件 account: { // account 组件 template: &#39;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;这是Account组件&amp;lt;/h1&amp;gt;&amp;lt;login&amp;gt;&amp;lt;/login&amp;gt;&amp;lt;/div&amp;gt;&#39;, // 在这里使用定义的子组件 components: { // 定义子组件的子组件 login: { // login 组件 template: &quot;&amp;lt;h3&amp;gt;这是登录组件&amp;lt;/h3&amp;gt;&quot; } } } } }); &amp;lt;/script&amp;gt; 引用组件：``` ## 使用`flag`标识符结合`v-if`和`v-else`切换组件1. 页面结构： &amp;lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&amp;gt; 2. Vue实例定义：## 使用`:is`属性来切换不同的子组件,并添加切换动画1. 组件实例定义方式：// 登录组件 const login = Vue.extend({ template: &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;登录组件&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; }); Vue.component(‘login’, login);// 注册组件const register = Vue.extend({ template: `&amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;注册组件&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt;`});Vue.component(&#39;register&#39;, register);// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: &#39;#app&#39;, data: { comName: &#39;login&#39; }, methods: {}}); ``` 2. 使用`component`标签，来引用组件，并通过`:is`属性来指定要加载的组件： ``` &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&#39;login&#39;&quot;&amp;gt;登录&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&#39;register&#39;&quot;&amp;gt;注册&amp;lt;/a&amp;gt; &amp;lt;component :is=&quot;comName&quot;&amp;gt;&amp;lt;/component&amp;gt; 3. 添加切换样式：## 父组件向子组件传值1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据2. 使用`v-bind`或简化指令，将数据传递到子组件中： &amp;lt;son :finfo=&quot;msg&quot;&amp;gt;&amp;lt;/son&amp;gt; ## 子组件向父组件传值1. 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；2. 父组件将方法的引用传递给子组件，其中，`getMsg`是父组件中`methods`中定义的方法名称，`func`是子组件调用传递过来方法时候的方法名称&amp;lt;son @func=”getMsg”&amp;gt;&amp;lt;/son&amp;gt;3. 子组件内部通过`this.$emit(&#39;方法名&#39;, 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用 &amp;lt;son @func=&quot;getMsg&quot;&amp;gt;&amp;lt;/son&amp;gt; ## 评论列表案例目标：主要练习父子组件之间传值## 使用 `this.$refs` 来获取元素和组件 &amp;lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&amp;gt; 这是一个大大的H1 ## 什么是路由1. 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；2. 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；## 在 vue 中使用 vue-router1. 导入 vue-router 组件类库：2. 使用 router-link 组件来导航登录注册3. 使用 router-view 组件来显示匹配到的组件4. 创建使用`Vue.extend`创建组件// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend({ template: &#39;&amp;lt;h1&amp;gt;登录组件&amp;lt;/h1&amp;gt;&#39;});// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend({ template: &#39;&amp;lt;h1&amp;gt;注册组件&amp;lt;/h1&amp;gt;&#39;}); ``` 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 ``` // 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则var router = new VueRouter({ routes: [ { path: &#39;/login&#39;, component: login }, { path: &#39;/register&#39;, component: register } ]}); ``` 6. 使用 router 属性来使用路由规则 ``` // 6. 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: &#39;#app&#39;, router: router // 使用 router 属性来使用路由规则}); ```设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： { path: &#39;/register/:id&#39;, component: register } 通过 this.$route.params来获取路由中的参数： var register = Vue.extend({ template: &#39;&amp;lt;h1&amp;gt;注册组件 --- &amp;lt;/h1&amp;gt;&#39; }); 使用 children 属性实现路由嵌套 &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;router-link to=&quot;/account&quot;&amp;gt;Account&amp;lt;/router-link&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; // 父路由中的组件 const account = Vue.extend({ template: `&amp;lt;div&amp;gt; 这是account组件 &amp;lt;router-link to=&quot;/account/login&quot;&amp;gt;login&amp;lt;/router-link&amp;gt; | &amp;lt;router-link to=&quot;/account/register&quot;&amp;gt;register&amp;lt;/router-link&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt;` }); // 子路由中的 login 组件 const login = Vue.extend({ template: &#39;&amp;lt;div&amp;gt;登录组件&amp;lt;/div&amp;gt;&#39; }); // 子路由中的 register 组件 const register = Vue.extend({ template: &#39;&amp;lt;div&amp;gt;注册组件&amp;lt;/div&amp;gt;&#39; }); // 路由实例 var router = new VueRouter({ routes: [ { path: &#39;/&#39;, redirect: &#39;/account/login&#39; }, // 使用 redirect 实现路由重定向 { path: &#39;/account&#39;, component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 { path: &#39;login&#39;, component: login }, // 注意，子路由的开头位置，不要加 / 路径符 { path: &#39;register&#39;, component: register } ] } ] }); // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: {}, methods: {}, components: { account }, router: router }); &amp;lt;/script&amp;gt;命名视图实现经典布局 标签代码结构：``` 2. JS代码：3. CSS 样式：## `watch`属性的使用考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）1. 监听`data`中属性的改变： + = 2. 监听路由对象的改变： 登录 注册 ## `computed`计算属性的使用1. 默认只有`getter`的计算属性： + = 2. 定义有`getter`和`setter`的计算属性： &amp;lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&amp;gt; ```watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体；nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址；相关文件 URL中的hash（井号）" }, { "title": "vue学习笔记2", "url": "/post/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02", "categories": "vue学习笔记2", "tags": "", "date": "2019-03-11 14:14:08 +0800", "snippet": "品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除：filterBy - 指令&amp;lt;tr v-for=&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&amp;gt;删除&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性：&amp;lt;hr&amp;gt; 输入筛选名称：&amp;lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&amp;gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去：&amp;lt;tbody&amp;gt; &amp;lt;tr v-for=&quot;item in search(searchName)&quot;&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&amp;gt;删除&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; search 过滤方法中，使用 数组的 filter 方法进行过滤：search(name) { return this.list.filter(x =&amp;gt; { return x.name.indexOf(name) != -1; });}Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；私有过滤器 HTML元素：&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; 私有 filters 定义方式：filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;); var d = dt.getDate().toString().padStart(2, &#39;0&#39;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &#39;0&#39;); var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;); var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; } } } 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’‘)来填充字符串；全局过滤器// 定义一个全局过滤器Vue.filter(&#39;dataFormat&#39;, function (input, pattern = &#39;&#39;) { var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;); var d = dt.getDate().toString().padStart(2, &#39;0&#39;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &#39;0&#39;); var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;); var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】Vue.directive(&#39;on&#39;).keyCodes.f2 = 113;2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名：Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符：&amp;lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&amp;gt;自定义指令 自定义全局和局部的 自定义指令： // 自定义全局指令 v-focus，为绑定的元素自动获取焦点： Vue.directive(&#39;focus&#39;, { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); } }); // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, &#39;font-weight&#39;: function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } } 自定义指令的使用方式：&amp;lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&#39;red&#39;&quot; v-font-weight=&quot;900&quot;&amp;gt;Vue 1.x 中 自定义元素指令【已废弃,了解即可】Vue.elementDirective(&#39;red-color&#39;, { bind: function () { this.el.style.color = &#39;red&#39;; }});使用方式：&amp;lt;red-color&amp;gt;1232&amp;lt;/red-color&amp;gt;vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： + beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 + created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 + beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 + mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： + beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 + updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： + beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 + destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： - 先在客户端定义一个回调方法，预定义对数据的操作； - 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； - 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； - 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； ``` const http = require(‘http’); // 导入解析 URL 地址的核心模块 const urlModule = require(‘url’); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on(‘request’, (req, res) =&amp;gt; { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === ‘/getjsonp’) { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: ‘zs’, age: 22, gender: ‘男’, hobby: [‘吃饭’, ‘睡觉’, ‘运动’] } // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = ${cbName}(${JSON.stringify(data)}); // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end(‘404’); } }); server.listen(3000, () =&amp;gt; { console.log(‘server running at http://127.0.0.1:3000’); }); ``` vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： getInfo() { // get 方式获取数据 this.$http.get(&#39;http://127.0.0.1:8899/api/getlunbo&#39;).then(res =&amp;gt; { console.log(res.body); })} 发送post请求： postInfo() { var url = &#39;http://127.0.0.1:8899/api/post&#39;; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, { name: &#39;zs&#39; }, { emulateJSON: true }).then(res =&amp;gt; { console.log(res.body); });} 发送JSONP请求获取数据： jsonpInfo() { // JSONP形式从服务器获取数据 var url = &#39;http://127.0.0.1:8899/api/jsonp&#39;; this.$http.jsonp(url).then(res =&amp;gt; { console.log(res.body); });} 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&amp;gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&amp;gt; src目录 -&amp;gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；使用过渡类名 HTML结构：``` &amp;lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&amp;gt; 动画哦 2. VM 实例：// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: ‘#app’, data: { isshow: false }, methods: { myAnimate() { this.isshow = !this.isshow; } }});3. 定义两组类样式：/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active { transition: all 0.2s ease; position: absolute; }/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */.fade-enter,.fade-leave-to { opacity: 0; transform: translateX(100px);} ```使用第三方 CSS 动画库 导入动画类库：```2. 定义 transition 及属性：&amp;lt;transition enter-active-class=”fadeInRight” leave-active-class=”fadeOutRight” :duration=”{ enter: 500, leave: 800 }”&amp;gt; &amp;lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&amp;gt;动画哦&amp;lt;/div&amp;gt;&amp;lt;/transition&amp;gt;### 使用动画钩子函数1. 定义 transition 组件以及三个钩子函数： &amp;lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&amp;gt; &amp;lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&amp;gt; OK &amp;lt;/transition&amp;gt; 2. 定义三个 methods 钩子方法：methods: { beforeEnter(el) { // 动画进入之前的回调 el.style.transform = ‘translateX(500px)’; }, enter(el, done) { // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = ‘translateX(0px)’; done(); }, afterEnter(el) { // 动画进入完成之后的回调 this.isshow = !this.isshow; } }3. 定义动画过渡时长和样式：.show{ transition: all 0.4s ease; }### [v-for 的列表过渡](https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡)1. 定义过渡样式：2. 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： &amp;lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&amp;gt; &amp;lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&amp;gt;&amp;lt;/li&amp;gt; 3. 定义 VM中的结构：// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({ el: &#39;#app&#39;, data: { txt: &#39;&#39;, list: [1, 2, 3, 4] }, methods: { add() { this.list.push(this.txt); this.txt = &#39;&#39;; } }}); ```列表的排序过渡&amp;lt;transition-group&amp;gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： .v-move{transition: all 0.8s ease;}.v-leave-active{position: absolute;} 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器" }, { "title": "vue学习笔记", "url": "/post/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0", "categories": "vue学习笔记", "tags": "", "date": "2019-03-11 14:14:08 +0800", "snippet": "什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构：&amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&amp;gt; &amp;lt;/div&amp;gt; Vue实例： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { info: &#39;猥琐发育，别浪~！&#39;, intervalId: null }, methods: { go() { // 如果当前有定时器在运行，则直接return if (this.intervalId != null) { return; } // 开始定时器 this.intervalId = setInterval(() =&amp;gt; { this.info = this.info.substring(1) + this.info.substring(0, 1); }, 500); }, stop() { clearInterval(this.intervalId); } } });Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&amp;gt; &amp;lt;select v-model=&quot;opt&quot;&amp;gt; &amp;lt;option value=&quot;0&quot;&amp;gt;+&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;1&quot;&amp;gt;-&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;2&quot;&amp;gt;*&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;3&quot;&amp;gt;÷&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; v-model=&quot;result&quot;&amp;gt; &amp;lt;/div&amp;gt; Vue实例代码： // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { n1: 0, n2: 0, result: 0, opt: &#39;0&#39; }, methods: { getResult() { switch (this.opt) { case &#39;0&#39;: this.result = parseInt(this.n1) + parseInt(this.n2); break; case &#39;1&#39;: this.result = parseInt(this.n1) - parseInt(this.n2); break; case &#39;2&#39;: this.result = parseInt(this.n1) * parseInt(this.n2); break; case &#39;3&#39;: this.result = parseInt(this.n1) / parseInt(this.n2); break; } } } });在Vue中使用样式使用class样式 数组```&amp;lt;h1 :class=”[‘red’, ‘thin’]”&amp;gt;这是一个邪恶的H1&amp;lt;/h1&amp;gt;2. 数组中使用三元表达式&amp;lt;h1 :class=”[‘red’, ‘thin’, isactive?’active’:’’]”&amp;gt;这是一个邪恶的H1&amp;lt;/h1&amp;gt;3. 数组中嵌套对象&amp;lt;h1 :class=”[‘red’, ‘thin’, {‘active’: isactive}]”&amp;gt;这是一个邪恶的H1&amp;lt;/h1&amp;gt;4. 直接使用对象&amp;lt;h1 :class=”{red:true, italic:true, active:true, thin:true}”&amp;gt;这是一个邪恶的H1&amp;lt;/h1&amp;gt;### 使用内联样式1. 直接在元素上通过 `:style` 的形式，书写样式对象&amp;lt;h1 :style=”{color: ‘red’, ‘font-size’: ‘40px’}”&amp;gt;这是一个善良的H1&amp;lt;/h1&amp;gt;2. 将样式对象，定义到 `data` 中，并直接引用到 `:style` 中 + 在data上定义样式：data: { h1StyleObj: { color: ‘red’, ‘font-size’: ‘40px’, ‘font-weight’: ‘200’ }} + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：&amp;lt;h1 :style=”h1StyleObj”&amp;gt;这是一个善良的H1&amp;lt;/h1&amp;gt;3. 在 `:style` 中通过数组，引用多个 `data` 上的样式对象 + 在data上定义样式：data: { h1StyleObj: { color: ‘red’, ‘font-size’: ‘40px’, ‘font-weight’: ‘200’ }, h1StyleObj2: { fontStyle: ‘italic’ }} + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：&amp;lt;h1 :style=”[h1StyleObj, h1StyleObj2]”&amp;gt;这是一个善良的H1&amp;lt;/h1&amp;gt;## Vue指令之`v-for`和`key`属性1. 迭代数组 索引： --- 姓名： --- 年龄：2. 迭代对象中的属性&amp;lt;!-- 循环遍历对象身上的属性 --&amp;gt;&amp;lt;div v-for=&quot;(val, key, i) in userInfo&quot;&amp;gt; --- --- &amp;lt;/div&amp;gt;3. 迭代数字这是第 个P标签&amp;gt; 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。## Vue指令之`v-if`和`v-show`&amp;gt; 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。## 品牌管理案例### 添加新品牌### 删除品牌### 根据条件筛选品牌1. 1.x 版本中的filterBy指令，在2.x中已经被废除：[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy) &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&amp;gt;删除&amp;lt;/a&amp;gt; 2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：+ 筛选框绑定到 VM 实例中的 `searchName` 属性：输入筛选名称：+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去： &amp;lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&amp;gt;删除&amp;lt;/a&amp;gt; + `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：search(name) {return this.list.filter(x =&amp;gt; {return x.name.indexOf(name) != -1;});}## Vue调试工具`vue-devtools`的安装步骤和使用[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)## 过滤器概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；### 私有过滤器1. HTML元素：2. 私有 `filters` 定义方式：filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用dataFormat(input, pattern = &quot;&quot;) { // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;); var d = dt.getDate().toString().padStart(2, &#39;0&#39;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) { return `${y}-${m}-${d}`; } else { // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &#39;0&#39;); var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;); var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;); return `${y}-${m}-${d} ${hh}:${mm}:${ss}`; }}}&amp;gt; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=&#39;&#39;) 或 String.prototype.padEnd(maxLength, fillString=&#39;&#39;)来填充字符串；### 全局过滤器// 定义一个全局过滤器Vue.filter(‘dataFormat’, function (input, pattern = ‘’) {var dt = new Date(input);// 获取年月日var y = dt.getFullYear();var m = (dt.getMonth() + 1).toString().padStart(2, ‘0’);var d = dt.getDate().toString().padStart(2, ‘0’);// 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日// 否则，就返回 年-月-日 时：分：秒if (pattern.toLowerCase() === ‘yyyy-mm-dd’) {return `${y}-${m}-${d}`;} else {// 获取时分秒var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;}});&amp;gt; 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！## 键盘修饰符以及自定义键盘修饰符### 1.x中自定义键盘修饰符【了解即可】Vue.directive(‘on’).keyCodes.f2 = 113;### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：Vue.config.keyCodes.f2 = 113;2. 使用自定义的按键修饰符：&amp;lt;input type=”text” v-model=”name” @keyup.f2=”add”&amp;gt;## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)1. 自定义全局和局部的 自定义指令：// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive(&#39;focus&#39;, { inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用 el.focus(); }});// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: { color: { // 为元素设置指定的字体颜色 bind(el, binding) { el.style.color = binding.value; } }, &#39;font-weight&#39;: function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; } }2. 自定义指令的使用方式：## Vue 1.x 中 自定义元素指令【已废弃,了解即可】Vue.elementDirective(‘red-color’, { bind: function () { this.el.style.color = ‘red’; }});使用方式：1232```相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理" }, { "title": "SignalR使用笔记", "url": "/post/SignalR%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0", "categories": "SignalR使用笔记", "tags": "", "date": "2019-03-11 14:14:08 +0800", "snippet": "最近项目要求添加一个给用户发送消息的功能，就决定使用SignalR。翻到了以前学习SignalR的学习笔记，基本是官方文档的简版整理，便于快速阅览和实现。1. nuget添加signalr引用：a. install-package Microsoft.AspNet.SignalRb. silverlight安装时startup中找不到IAppBuilder接口： Update-Package Owin -Reinstall2. 新建hub集线器类a. 添加调用客户端方法，调用的js方法在运行时解析，signalr将方法名称和参数值发送到客户端。如果客户端有与该名称匹配的方法，则调用该方法，并把参数值传递给该方法。如果没有找到匹配的方法，则不会报错。方法名称匹配不区分大小写。i. js使用驼峰命名方式：第一个字母小写，调用服务端方法时会自动转换成c#命名方式（第一个字母大写）。指定集线器名称时，应该与客户端js调用方法名称一致。######### 1) ######### 2) b. 可以定义多个集线器。与在单个类中定义所有集线器功能相比，多个集线器没有性能差异。c. 强类型集线器i. d. 客户端调用服务端方法与调用本地js方法相同，可以获取复杂类型的json格式返回值。e. 同步/异步方法i. ii. iii. js：############f. 异步调用客户端方法时，不会等待客户端方法执行完成，会继续执行下面的代码：i. g. 重载：如果要定义方法的重载，每个重载中的参数数必须不同。如果您通过指定不同的参数类型来区分重载，则Hub类将编译，但是当客户端尝试调用其中一个重载时，SignalR服务将在运行时抛出异常。h. 从集线器方法调用报告进度（SignalR 2.1版本）。要实现进度报告，IProgress请为客户端可以访问的集线器方法定义一个参数：i. i. 调用客户端方法：i. ii. iii. 不能从客户端方法中获取返回值，以下代码不起作用：######### 1) iv. 字符串变量作为方法名称######### 1) j. 获取连接的客户端：i. 所有连接的客户端######### 1) ii. 只有主叫客户端。######### 1) iii. 所有客户端，除了主叫客户端。######### 1) iv. 由连接ID标识的特定客户端。######### 1) v. 所有连接的客户端，除了指定的客户端，由连接ID标识。######### 1) vi. 指定组中的所有连接的客户端。######### 1) vii. 指定组中的所有连接的客户端，除了指定的客户端，由连接ID标识。######### 1) viii. 指定组中的所有连接的客户端，除了主叫客户端。######### 1) ix. 由userId标识的特定用户。######### 1) ######### 2) 默认情况下，这是IPrincipal.Identity.Name，但是可以通过向全局主机注册IUserIdProvider的实现来更改。x. 连接ID列表中的所有客户端和组。######### 1) ######xi. 组列表。#########1) ######xii. 按用户连接id。#########1) ######xiii. 用户名列表（在SignalR 2.1中引入）。#########1) ###k. 获取有关客户端的信息######i. 主叫客户端的连接ID。连接ID是由SignalR分配的GUID（您不能在自己的代码中指定值）。每个连接都有一个连接ID，如果应用程序中有多个Hub，则所有Hub都使用相同的连接ID。#########1) ######ii. HTTP标头数据。#########1) ######iii. 查询字符串数据。#########1) ######iv. Cookies#########1) ######v. 用户信息###############vi. 请求的HttpContext对象#########1) ##3. 创建owin启动类###a. ###b. 添加路由，如果要将SignalR功能添加到ASP.NET MVC应用程序，请确保在其他路由之前添加SignalR路由。######i. ######ii. 指定URL的服务器代码。默认情况下，客户端用于连接到Hub的路由URL为“/ signalr”，该URL用于自动生成的JavaScript文件。#########1) #########2) ######iii. 指定URL的JavaScript客户端代码（使用生成的代理）#########1) ######iv. 指定URL的JavaScript客户端代码（不带生成的代理）#########1) ######v. 指定URL的.NET客户端代码#########1) ###c. 如何自定义Hubs管道。SignalR使您可以将自己的代码注入Hub管道。以下示例显示了一个自定义集线器管道模块，用于记录从客户端接收的每个传入方法调用和在客户机上调用的传出方法调用：######i. ######ii. 在Startup.cs文件中将模块注册到Hub管道中运行#########1) ##4. 添加html页面###a. 代码：######i. ######ii. ##5. 启用日志记录，在启动之前加上$.connection.hub.logging = true;###a. " }, { "title": "asp.net core导出导入excel", "url": "/post/asp.net-core%E5%AF%BC%E5%85%A5excel", "categories": "asp.net, core导出导入excel", "tags": "", "date": "2019-01-16 14:14:08 +0800", "snippet": "接昨天的##导入excel内容对比昨天导出的内容增加了一行实体属性名称作为标题行，这样到转换为实体的时候才能找到对应的属性。导入代码public IActionResult InportExcel(){ var file = &quot;D:\\\\a.xls&quot;; var excelHeper = new ExcelHelper(); var dt = excelHeper.ExcelImport(file,2); var list = dt.ToList&amp;lt;Student&amp;gt;(); return Content(&quot;&quot;);}excel文件路径可以通过上传控件上传到服务器再读取。注意如果你导入和发现bool类型不能正确读取请修改一下两个文件的两个地方：DataTableExtensions的public static IEnumerable ToList(this DataTable dt) where T : class, new()方法增加一个bool类型判断else if (p.PropertyType == typeof(bool)){ p.SetValue(ob, bool.Parse(row[p.Name].ToString()), null);}ExcelHelper的private DataTable ReadSheetToDataTable(int headerRowNo, ISheet sheet)方法替换为如下代码或增加一个bool类型判断private DataTable ReadSheetToDataTable(int headerRowNo, ISheet sheet){ var dt = new DataTable(); IRow headerRow = sheet.GetRow(headerRowNo); int cellCount = headerRow.LastCellNum; for (int j = 0; j &amp;lt; cellCount; j++) { ICell cell = headerRow.GetCell(j); dt.Columns.Add(cell.ToString()); } for (int i = (headerRowNo + 1); i &amp;lt;= sheet.LastRowNum; i++) { IRow row = sheet.GetRow(i); DataRow dataRow = dt.NewRow(); for (int j = 0; j &amp;lt; cellCount; j++) { if (row.GetCell(j) == null) { continue; } ICell cell = row.GetCell(j); switch (cell.CellType) { case CellType.Unknown: case CellType.Error: throw new Exception($&quot;第{i + 1}行，列【{dt.Columns[j].ColumnName}】,单元格格式错误&quot;); break; case CellType.Numeric: if (DateUtil.IsCellDateFormatted(cell)) { dataRow[j] = cell.DateCellValue; } else { dataRow[j] = cell.NumericCellValue; } break; case CellType.Blank: dataRow[j] = &quot;&quot;; break; case CellType.Boolean: dataRow[j] = cell.BooleanCellValue; break; case CellType.Formula: dataRow[j] = cell.CellFormula ; break; case CellType.String: default: dataRow[j] = cell.StringCellValue; break; } //dataRow[j] = row.GetCell(j).ToString(); } bool existsValue = false; foreach (DataColumn column in dt.Columns) { if (dataRow[column.ColumnName] == null || string.IsNullOrEmpty(dataRow[column.ColumnName].ToString())) { continue; } existsValue = true; break; } if (existsValue) { dt.Rows.Add(dataRow); } } return dt;}" }, { "title": "asp.net core导出导入excel", "url": "/post/asp.net-core%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5excel", "categories": "asp.net, core导出导入excel", "tags": "", "date": "2019-01-16 14:14:08 +0800", "snippet": "使用NPOI导入导出excel,已经封装好Action可以直接调用导出效果图使用方法定义导出实体class Student{ public int Id { get; set; } public string Name { get; set; } public bool IsBanZhang { get; set; } public static IEnumerable&amp;lt;Student&amp;gt; GetStudents() { return new List&amp;lt;Student&amp;gt; { new Student{Name=&quot;小强&quot;,Id=1,IsBanZhang=false}, new Student{Name=&quot;小文&quot;,Id=2,IsBanZhang=true}, new Student{Name=&quot;小黄&quot;,Id=3,IsBanZhang=false}, new Student{Name=&quot;小刚&quot;,Id=3,IsBanZhang=false}, }; }}导出Actionpublic IActionResult DownExcel(){ var list = Student.GetStudents(); var excelHeper = new ExcelHelper(); var config = new List&amp;lt;ExcelGridModel&amp;gt; { new ExcelGridModel{name=&quot;Id&quot;,label=&quot;学号&quot;, align=&quot;left&quot;,}, new ExcelGridModel{name=&quot;Name&quot;,label=&quot;姓名&quot;, align=&quot;left&quot;,}, new ExcelGridModel{name=&quot;IsBanZhang&quot;,label=&quot;是否班长&quot;, align=&quot;left&quot;,}, }; var fileName = &quot;a.excel&quot;; return excelHeper.ExcelDownload(list, config, fileName);}主要代码导入导出代码/// &amp;lt;summary&amp;gt;/// 描 述：NPOI Excel DataTable操作类/// &amp;lt;/summary&amp;gt;public class ExcelHelper{ #region Excel导出方法 ExcelDownload /// &amp;lt;summary&amp;gt; /// Excel导出下载 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;数据类型&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;list&quot;&amp;gt;数据源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;columnJson&quot;&amp;gt;导出列&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;下载文件名称&amp;lt;/param&amp;gt; public ActionResult ExcelDownload&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; list, IEnumerable&amp;lt;ExcelGridModel&amp;gt; columnList, string fileName) { var excelConfig = ConvertExcelGridModelToConfig(columnList, fileName); var rowData = list.ToDataTable(columnList.Select(i =&amp;gt; i.name)); var stream = ExportMemoryStream(rowData, excelConfig); return new FileStreamResult(stream, MIMEType.xls) { FileDownloadName = JointXls(fileName) }; } /// &amp;lt;summary&amp;gt; /// Excel导出下载 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dtSource&quot;&amp;gt;DataTable数据源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;excelConfig&quot;&amp;gt;导出设置包含文件名、标题、列设置&amp;lt;/param&amp;gt; public ActionResult ExcelDownload(DataTable dtSource, IEnumerable&amp;lt;ExcelGridModel&amp;gt; columnList, string fileName) { var excelConfig = ConvertExcelGridModelToConfig(columnList, fileName); var stream = ExportMemoryStream(dtSource, excelConfig); return new FileStreamResult(stream, MIMEType.xls) { FileDownloadName = JointXls(fileName) }; } /// &amp;lt;summary&amp;gt; /// Excel导出下载 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dtSource&quot;&amp;gt;DataTable数据源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;excelConfig&quot;&amp;gt;导出设置包含文件名、标题、列设置&amp;lt;/param&amp;gt; public ActionResult ExcelDownload(DataTable dtSource, ExcelConfig excelConfig, string fileName) { var stream = ExportMemoryStream(dtSource, excelConfig); return new FileStreamResult(stream, MIMEType.xls) { FileDownloadName = JointXls(fileName) }; } #endregion Excel导出方法 ExcelDownload #region DataTable导出到Excel文件excelConfig中FileName设置为全路径 /// &amp;lt;summary&amp;gt; /// DataTable导出到Excel文件 Export() /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dtSource&quot;&amp;gt;DataTable数据源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;excelConfig&quot;&amp;gt;导出设置包含文件名、标题、列设置&amp;lt;/param&amp;gt; public string ExcelExportToFile(DataTable dtSource, ExcelConfig excelConfig, string fileName) { fileName = JointXls(fileName); using (MemoryStream ms = ExportMemoryStream(dtSource, excelConfig)) { using (FileStream fs = new FileStream(fileName, FileMode.Create, FileAccess.Write)) { byte[] data = ms.ToArray(); fs.Write(data, 0, data.Length); fs.Flush(); } } return fileName; } #endregion DataTable导出到Excel文件excelConfig中FileName设置为全路径 #region DataTable导出到Excel的MemoryStream /// &amp;lt;summary&amp;gt; /// DataTable导出到Excel的MemoryStream Export() /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dtSource&quot;&amp;gt;DataTable数据源&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;excelConfig&quot;&amp;gt;导出设置包含文件名、标题、列设置&amp;lt;/param&amp;gt; public MemoryStream ExportMemoryStream(DataTable dtSource, ExcelConfig excelConfig) { var columnEntity = excelConfig.ColumnEntity; if (columnEntity == null || columnEntity.Count == 0) { if (columnEntity == null) { columnEntity = new List&amp;lt;ColumnModel&amp;gt;(); } foreach (DataColumn dc in dtSource.Columns) { columnEntity.Add(new ColumnModel { Alignment = &quot;center&quot;, Column = dc.ColumnName, ExcelColumn = dc.ColumnName }); } } else { int colint = 0; for (int i = 0; i &amp;lt; dtSource.Columns.Count;) { DataColumn column = dtSource.Columns[i]; if (excelConfig.ColumnEntity[colint].Column != column.ColumnName) { dtSource.Columns.Remove(column.ColumnName); } else { i++; if (colint &amp;lt; excelConfig.ColumnEntity.Count - 1) { colint++; } } } } HSSFWorkbook workbook = new HSSFWorkbook(); ISheet sheet = workbook.CreateSheet(); #region 右击文件 属性信息 { DocumentSummaryInformation dsi = PropertySetFactory.CreateDocumentSummaryInformation(); dsi.Company = &quot;NPOI&quot;; workbook.DocumentSummaryInformation = dsi; SummaryInformation si = PropertySetFactory.CreateSummaryInformation(); si.Author = &quot;&quot;; //填加xls文件作者信息 si.ApplicationName = &quot;&quot;; //填加xls文件创建程序信息 si.LastAuthor = &quot;&quot;; //填加xls文件最后保存者信息 si.Comments = &quot;&quot;; //填加xls文件作者信息 si.Title = &quot;&quot;; //填加xls文件标题信息 si.Subject = &quot;&quot;;//填加文件主题信息 si.CreateDateTime = System.DateTime.Now; workbook.SummaryInformation = si; } #endregion 右击文件 属性信息 #region 设置标题样式 ICellStyle headStyle = workbook.CreateCellStyle(); int[] arrColWidth = new int[dtSource.Columns.Count]; string[] arrColName = new string[dtSource.Columns.Count];//列名 ICellStyle[] arryColumStyle = new ICellStyle[dtSource.Columns.Count];//样式表 headStyle.Alignment = HorizontalAlignment.Center; // ------------------ if (excelConfig.Background != new Color()) { if (excelConfig.Background != new Color()) { headStyle.FillPattern = FillPattern.SolidForeground; headStyle.FillForegroundColor = GetXLColour(workbook, excelConfig.Background); } } IFont font = workbook.CreateFont(); font.FontHeightInPoints = excelConfig.TitlePoint; if (excelConfig.ForeColor != new Color()) { font.Color = GetXLColour(workbook, excelConfig.ForeColor); } font.Boldweight = 700; headStyle.SetFont(font); #endregion 设置标题样式 #region 列头及样式 ICellStyle cHeadStyle = workbook.CreateCellStyle(); cHeadStyle.Alignment = HorizontalAlignment.Center; // ------------------ IFont cfont = workbook.CreateFont(); cfont.FontHeightInPoints = excelConfig.HeadPoint; cHeadStyle.SetFont(cfont); #endregion 列头及样式 #region 设置内容单元格样式 foreach (DataColumn item in dtSource.Columns) { ICellStyle columnStyle = workbook.CreateCellStyle(); columnStyle.Alignment = HorizontalAlignment.Center; arrColWidth[item.Ordinal] = Encoding.UTF8.GetBytes(item.ColumnName.ToString()).Length; arrColName[item.Ordinal] = item.ColumnName.ToString(); if (excelConfig.ColumnEntity != null) { ColumnModel columnentity = excelConfig.ColumnEntity.Find(t =&amp;gt; t.Column == item.ColumnName); if (columnentity != null) { arrColName[item.Ordinal] = columnentity.ExcelColumn; if (columnentity.Width != 0) { arrColWidth[item.Ordinal] = columnentity.Width; } if (columnentity.Background != new Color()) { if (columnentity.Background != new Color()) { columnStyle.FillPattern = FillPattern.SolidForeground; columnStyle.FillForegroundColor = GetXLColour(workbook, columnentity.Background); } } if (columnentity.Font != null || columnentity.Point != 0 || columnentity.ForeColor != new Color()) { IFont columnFont = workbook.CreateFont(); columnFont.FontHeightInPoints = 10; if (columnentity.Font != null) { columnFont.FontName = columnentity.Font; } if (columnentity.Point != 0) { columnFont.FontHeightInPoints = columnentity.Point; } if (columnentity.ForeColor != new Color()) { columnFont.Color = GetXLColour(workbook, columnentity.ForeColor); } columnStyle.SetFont(font); } columnStyle.Alignment = getAlignment(columnentity.Alignment); } } arryColumStyle[item.Ordinal] = columnStyle; } if (excelConfig.IsAllSizeColumn) { #region 根据列中最长列的长度取得列宽 for (int i = 0; i &amp;lt; dtSource.Rows.Count; i++) { for (int j = 0; j &amp;lt; dtSource.Columns.Count; j++) { if (arrColWidth[j] != 0) { int intTemp = Encoding.UTF8.GetBytes(dtSource.Rows[i][j].ToString()).Length; if (intTemp &amp;gt; arrColWidth[j]) { arrColWidth[j] = intTemp; } } } } #endregion 根据列中最长列的长度取得列宽 } #endregion 设置内容单元格样式 int rowIndex = 0; #region 表头及样式 if (excelConfig.Title != null) { IRow headerRow = sheet.CreateRow(rowIndex); rowIndex++; if (excelConfig.TitleHeight != 0) { headerRow.Height = (short)(excelConfig.TitleHeight * 20); } headerRow.HeightInPoints = 25; headerRow.CreateCell(0).SetCellValue(excelConfig.Title); headerRow.GetCell(0).CellStyle = headStyle; sheet.AddMergedRegion(new NPOI.SS.Util.CellRangeAddress(0, 0, 0, dtSource.Columns.Count - 1)); // ------------------ } #endregion 表头及样式 #region 列头及样式 { IRow headerRow = sheet.CreateRow(rowIndex); rowIndex++; #region 如果设置了列标题就按列标题定义列头，没定义直接按字段名输出 foreach (DataColumn column in dtSource.Columns) { headerRow.CreateCell(column.Ordinal).SetCellValue(arrColName[column.Ordinal]); headerRow.GetCell(column.Ordinal).CellStyle = cHeadStyle; //设置列宽 sheet.SetColumnWidth(column.Ordinal, (arrColWidth[column.Ordinal] + 1) * 256); } #endregion 如果设置了列标题就按列标题定义列头，没定义直接按字段名输出 } #endregion 列头及样式 ICellStyle dateStyle = workbook.CreateCellStyle(); IDataFormat format = workbook.CreateDataFormat(); dateStyle.DataFormat = format.GetFormat(&quot;yyyy-mm-dd&quot;); foreach (DataRow row in dtSource.Rows) { #region 新建表，填充表头，填充列头，样式 if (rowIndex == 65535) { sheet = workbook.CreateSheet(); rowIndex = 0; #region 表头及样式 { if (excelConfig.Title != null) { IRow headerRow = sheet.CreateRow(rowIndex); rowIndex++; if (excelConfig.TitleHeight != 0) { headerRow.Height = (short)(excelConfig.TitleHeight * 20); } headerRow.HeightInPoints = 25; headerRow.CreateCell(0).SetCellValue(excelConfig.Title); headerRow.GetCell(0).CellStyle = headStyle; sheet.AddMergedRegion(new NPOI.SS.Util.CellRangeAddress(0, 0, 0, dtSource.Columns.Count - 1)); // ------------------ } } #endregion 表头及样式 #region 列头及样式 { IRow headerRow = sheet.CreateRow(rowIndex); rowIndex++; #region 如果设置了列标题就按列标题定义列头，没定义直接按字段名输出 foreach (DataColumn column in dtSource.Columns) { headerRow.CreateCell(column.Ordinal).SetCellValue(arrColName[column.Ordinal]); headerRow.GetCell(column.Ordinal).CellStyle = cHeadStyle; //设置列宽 sheet.SetColumnWidth(column.Ordinal, (arrColWidth[column.Ordinal] + 1) * 256); } #endregion 如果设置了列标题就按列标题定义列头，没定义直接按字段名输出 } #endregion 列头及样式 } #endregion 新建表，填充表头，填充列头，样式 #region 填充内容 IRow dataRow = sheet.CreateRow(rowIndex); foreach (DataColumn column in dtSource.Columns) { ICell newCell = dataRow.CreateCell(column.Ordinal); newCell.CellStyle = arryColumStyle[column.Ordinal]; string drValue = row[column].ToString(); SetCell(newCell, dateStyle, column.DataType, drValue); } #endregion 填充内容 rowIndex++; } //using (MemoryStream ms = new MemoryStream()) { MemoryStream ms = new MemoryStream(); workbook.Write(ms); ms.Flush(); ms.Position = 0; return ms; } } #endregion DataTable导出到Excel的MemoryStream #region 设置表格内容 private void SetCell(ICell newCell, ICellStyle dateStyle, Type dataType, string drValue) { switch (dataType.ToString()) { case &quot;System.String&quot;://字符串类型 newCell.SetCellValue(drValue); break; case &quot;System.DateTime&quot;://日期类型 System.DateTime dateV; if (System.DateTime.TryParse(drValue, out dateV)) { newCell.SetCellValue(dateV); } else { newCell.SetCellValue(&quot;&quot;); } newCell.CellStyle = dateStyle;//格式化显示 break; case &quot;System.Boolean&quot;://布尔型 bool boolV = false; bool.TryParse(drValue, out boolV); newCell.SetCellValue(boolV); break; case &quot;System.Int16&quot;://整型 case &quot;System.Int32&quot;: case &quot;System.Int64&quot;: case &quot;System.Byte&quot;: int intV = 0; int.TryParse(drValue, out intV); newCell.SetCellValue(intV); break; case &quot;System.Decimal&quot;://浮点型 case &quot;System.Double&quot;: double doubV = 0; double.TryParse(drValue, out doubV); newCell.SetCellValue(doubV); break; case &quot;System.DBNull&quot;://空值处理 newCell.SetCellValue(&quot;&quot;); break; default: newCell.SetCellValue(&quot;&quot;); break; } } #endregion 设置表格内容 #region 从Excel导入 /// &amp;lt;summary&amp;gt; /// 读取excel ,默认第一行为标头 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;strFileName&quot;&amp;gt;excel文档路径&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public DataTable ExcelImport(string strFileName) { return ExcelImport(strFileName, 0); } /// &amp;lt;summary&amp;gt; /// 读取excel ,默认第一行为标头 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;strFileName&quot;&amp;gt;excel文档路径&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;headerRowNo&quot;&amp;gt;标题行号，以0开始&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public DataTable ExcelImport(string strFileName, int headerRowNo) { ISheet sheet; using (FileStream file = new FileStream(strFileName, FileMode.Open, FileAccess.Read)) { if (strFileName.IndexOf(&quot;.xlsx&quot;, StringComparison.Ordinal) == -1)//2003 { HSSFWorkbook hssfworkbook = new HSSFWorkbook(file); sheet = hssfworkbook.GetSheetAt(0); } else//2007 { XSSFWorkbook xssfworkbook = new XSSFWorkbook(file); sheet = xssfworkbook.GetSheetAt(0); } } return ReadSheetToDataTable(headerRowNo, sheet); } /// &amp;lt;summary&amp;gt; /// 读取excel ,默认第一行为标头 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileStream&quot;&amp;gt;文件数据流&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public DataTable ExcelImport(Stream fileStream, string flieType) { return ExcelImport(fileStream, flieType, 0); } /// &amp;lt;summary&amp;gt; /// 读取excel ,默认第一行为标头 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileStream&quot;&amp;gt;文件数据流&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;headerRowNo&quot;&amp;gt;标题行号从0开始&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public DataTable ExcelImport(Stream fileStream, string flieType, int headerRowNo) { DataTable dt = new DataTable(); ISheet sheet = null; if (flieType == &quot;.xls&quot;) { HSSFWorkbook hssfworkbook = new HSSFWorkbook(fileStream); sheet = hssfworkbook.GetSheetAt(0); } else { XSSFWorkbook xssfworkbook = new XSSFWorkbook(fileStream); sheet = xssfworkbook.GetSheetAt(0); } return ReadSheetToDataTable(headerRowNo, sheet); } /// &amp;lt;summary&amp;gt; /// 从sheet中读取数据到DataTable /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;headerRowNo&quot;&amp;gt;标题行号（数据行号=标题行号+1）&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;sheet&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private DataTable ReadSheetToDataTable(int headerRowNo, ISheet sheet) { var dt = new DataTable(); IRow headerRow = sheet.GetRow(headerRowNo); int cellCount = headerRow.LastCellNum; for (int j = 0; j &amp;lt; cellCount; j++) { ICell cell = headerRow.GetCell(j); dt.Columns.Add(cell.ToString()); } for (int i = (headerRowNo + 1); i &amp;lt;= sheet.LastRowNum; i++) { IRow row = sheet.GetRow(i); DataRow dataRow = dt.NewRow(); for (int j = 0; j &amp;lt; cellCount; j++) { if (row.GetCell(j) == null) { continue; } ICell cell = row.GetCell(j); if (cell.CellType == CellType.Error) { throw new Exception($&quot;第{i + 1}行，列【{dt.Columns[j].ColumnName}】,单元格格式错误&quot;); } else if (cell.CellType == CellType.Numeric &amp;amp;&amp;amp; DateUtil.IsCellDateFormatted(cell)) { dataRow[j] = cell.DateCellValue; } else if (cell.CellType == CellType.Numeric) { dataRow[j] = cell.NumericCellValue; } else if (cell.CellType == CellType.Blank) { dataRow[j] = &quot;&quot;; } else { dataRow[j] = cell.StringCellValue; } //dataRow[j] = row.GetCell(j).ToString(); } bool existsValue = false; foreach (DataColumn column in dt.Columns) { if (dataRow[column.ColumnName] == null || string.IsNullOrEmpty(dataRow[column.ColumnName].ToString())) { continue; } existsValue = true; break; } if (existsValue) { dt.Rows.Add(dataRow); } } return dt; } #endregion 从Excel导入 #region RGB颜色转NPOI颜色 private short GetXLColour(HSSFWorkbook workbook, Color SystemColour) { short s = 0; HSSFPalette XlPalette = workbook.GetCustomPalette(); NPOI.HSSF.Util.HSSFColor XlColour = XlPalette.FindColor(SystemColour.R, SystemColour.G, SystemColour.B); if (XlColour == null) { if (NPOI.HSSF.Record.PaletteRecord.STANDARD_PALETTE_SIZE &amp;lt; 255) { XlColour = XlPalette.FindSimilarColor(SystemColour.R, SystemColour.G, SystemColour.B); s = XlColour.Indexed; } } else { s = XlColour.Indexed; } return s; } #endregion RGB颜色转NPOI颜色 #region 设置列的对齐方式 /// &amp;lt;summary&amp;gt; /// 设置对齐方式 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;style&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private HorizontalAlignment getAlignment(string style) { switch (style) { case &quot;center&quot;: return HorizontalAlignment.Center; case &quot;left&quot;: return HorizontalAlignment.Left; case &quot;right&quot;: return HorizontalAlignment.Right; case &quot;fill&quot;: return HorizontalAlignment.Fill; case &quot;justify&quot;: return HorizontalAlignment.Justify; case &quot;centerselection&quot;: return HorizontalAlignment.CenterSelection; case &quot;distributed&quot;: return HorizontalAlignment.Distributed; } return NPOI.SS.UserModel.HorizontalAlignment.General; } #endregion 设置列的对齐方式 #region 辅助方法 /// &amp;lt;summary&amp;gt; /// 如果文件名中没有后缀名，增加文件后缀名 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string JointXls(string fileName) { if (!fileName.EndsWith(&quot;.xls&quot;)) { fileName += &quot;.xls&quot;; } return fileName; } private ExcelConfig ConvertExcelGridModelToConfig(IEnumerable&amp;lt;ExcelGridModel&amp;gt; columnList, string fileName) { ExcelConfig excelconfig = new ExcelConfig(); excelconfig.Title = fileName; excelconfig.TitleFont = &quot;微软雅黑&quot;; excelconfig.TitlePoint = 15; excelconfig.IsAllSizeColumn = true; excelconfig.ColumnEntity = new List&amp;lt;ColumnModel&amp;gt;(); foreach (ExcelGridModel columnModel in columnList) { excelconfig.ColumnEntity.Add(new ColumnModel() { Column = columnModel.name, ExcelColumn = columnModel.label, Alignment = columnModel.align, }); } return excelconfig; } /// &amp;lt;summary&amp;gt; /// MIME文件类型 /// &amp;lt;/summary&amp;gt; class MIMEType { public const string xls = &quot;application/ms-excel&quot;; } #endregion}配置类型ExcelConfig/// &amp;lt;summary&amp;gt;/// 描 述：Excel导入导出设置/// &amp;lt;/summary&amp;gt;public class ExcelConfig{ /// &amp;lt;summary&amp;gt; /// 标题 /// &amp;lt;/summary&amp;gt; public string Title { get; set; } /// &amp;lt;summary&amp;gt; /// 前景色 /// &amp;lt;/summary&amp;gt; public Color ForeColor { get; set; } /// &amp;lt;summary&amp;gt; /// 背景色 /// &amp;lt;/summary&amp;gt; public Color Background { get; set; } private short _titlepoint; /// &amp;lt;summary&amp;gt; /// 标题字号 /// &amp;lt;/summary&amp;gt; public short TitlePoint { get { if (_titlepoint == 0) { return 20; } else { return _titlepoint; } } set { _titlepoint = value; } } private short _headpoint; /// &amp;lt;summary&amp;gt; /// 列头字号 /// &amp;lt;/summary&amp;gt; public short HeadPoint { get { if (_headpoint == 0) { return 10; } else { return _headpoint; } } set { _headpoint = value; } } /// &amp;lt;summary&amp;gt; /// 标题高度 /// &amp;lt;/summary&amp;gt; public short TitleHeight { get; set; } /// &amp;lt;summary&amp;gt; /// 列标题高度 /// &amp;lt;/summary&amp;gt; public short HeadHeight { get; set; } private string _titlefont; /// &amp;lt;summary&amp;gt; /// 标题字体 /// &amp;lt;/summary&amp;gt; public string TitleFont { get { if (_titlefont == null) { return &quot;微软雅黑&quot;; } else { return _titlefont; } } set { _titlefont = value; } } private string _headfont; /// &amp;lt;summary&amp;gt; /// 列头字体 /// &amp;lt;/summary&amp;gt; public string HeadFont { get { if (_headfont == null) { return &quot;微软雅黑&quot;; } else { return _headfont; } } set { _headfont = value; } } /// &amp;lt;summary&amp;gt; /// 是否按内容长度来适应表格宽度 /// &amp;lt;/summary&amp;gt; public bool IsAllSizeColumn { get; set; } /// &amp;lt;summary&amp;gt; /// 列设置 /// &amp;lt;/summary&amp;gt; public List&amp;lt;ColumnModel&amp;gt; ColumnEntity { get; set; }}ColumnModel/// &amp;lt;summary&amp;gt;/// 描 述：Excel导入导出列设置模型/// &amp;lt;/summary&amp;gt;public class ColumnModel{ /// &amp;lt;summary&amp;gt; /// 列名 /// &amp;lt;/summary&amp;gt; public string Column { get; set; } /// &amp;lt;summary&amp;gt; /// Excel列名 /// &amp;lt;/summary&amp;gt; public string ExcelColumn { get; set; } /// &amp;lt;summary&amp;gt; /// 宽度 /// &amp;lt;/summary&amp;gt; public int Width { get; set; } /// &amp;lt;summary&amp;gt; /// 前景色 /// &amp;lt;/summary&amp;gt; public Color ForeColor { get; set; } /// &amp;lt;summary&amp;gt; /// 背景色 /// &amp;lt;/summary&amp;gt; public Color Background { get; set; } /// &amp;lt;summary&amp;gt; /// 字体 /// &amp;lt;/summary&amp;gt; public string Font { get; set; } /// &amp;lt;summary&amp;gt; /// 字号 /// &amp;lt;/summary&amp;gt; public short Point { get; set; } /// &amp;lt;summary&amp;gt; ///对齐方式 ///left 左 ///center 中间 ///right 右 ///fill 填充 ///justify 两端对齐 ///centerselection 跨行居中 ///distributed /// &amp;lt;/summary&amp;gt; public string Alignment { get; set; }}ExcelGridModelpublic class ExcelGridModel{ /// &amp;lt;summary&amp;gt; /// 属性名称 /// &amp;lt;/summary&amp;gt; public string name { get; set; } /// &amp;lt;summary&amp;gt; /// excel列名 /// &amp;lt;/summary&amp;gt; public string label { get; set; } /// &amp;lt;summary&amp;gt; /// 宽度 /// &amp;lt;/summary&amp;gt; public string width { get; set; } /// &amp;lt;summary&amp;gt; /// 对其方式 /// &amp;lt;/summary&amp;gt; public string align { get; set; } /// &amp;lt;summary&amp;gt; /// 高度 /// &amp;lt;/summary&amp;gt; public string height { get; set; } /// &amp;lt;summary&amp;gt; /// 是否隐藏 /// &amp;lt;/summary&amp;gt; public string hidden { get; set; }}示例下载地址：代码打包下载" }, { "title": "layui动态设置checkbox选中状态", "url": "/post/layui%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEcheckbox%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81", "categories": "layui动态设置checkbox选中状态", "tags": "", "date": "2018-12-04 14:14:08 +0800", "snippet": "今天在使用jquery动态设置layui的checkbox元素的选中状态时始终只能取消选中，却不能重新勾选，点击勾选则没有问题，代码如下if (value == &quot;true&quot;) { $(&quot;#select1&quot;).attr(&quot;checked&quot;, &quot;checked&quot;);} else { $(&quot;#select1&quot;).removeAttr(&quot;checked&quot;);}百度很久终于找到一个可用的解决方案,使用prop代替attr，如下：if (value == &quot;true&quot;) { //$id.attr(&quot;checked&quot;, &quot;checked&quot;); $id.prop(&quot;checked&quot;, true);} else { $id.prop(&quot;checked&quot;, false); //$id.removeAttr(&quot;checked&quot;);}" }, { "title": "MiniProfiler监控Asp.Net MVC5和EF性能", "url": "/post/MiniProfiler%E7%9B%91%E6%8E%A7Asp.Net-MVC5%E5%92%8CEF%E6%80%A7%E8%83%BD", "categories": "MiniProfiler监控Asp.Net, MVC5和EF性能", "tags": "", "date": "2018-11-27 14:14:08 +0800", "snippet": "1. 安装依赖包在web项目打开nuget包管理器搜索 MiniProfiler.Mvc5和MiniProfiler.EF6安装。2. 在Global.asax中添加配置代码protected void Application_Start(){ MiniProfiler.Configure(new MiniProfilerOptions { // Sets up the route to use for MiniProfiler resources: // Here, ~/profiler is used for things like /profiler/mini-profiler-includes.js RouteBasePath = &quot;~/profiler&quot;, // Example of using SQLite storage instead Storage = new SqliteMiniProfilerStorage(ConnectionString), // Different RDBMS have different ways of declaring sql parameters - SQLite can understand inline sql parameters just fine. // By default, sql parameters will be displayed. //SqlFormatter = new StackExchange.Profiling.SqlFormatters.InlineFormatter(), // These settings are optional and all have defaults, any matching setting specified in .RenderIncludes() will // override the application-wide defaults specified here, for example if you had both: // PopupRenderPosition = RenderPosition.Right; // and in the page: // @MiniProfiler.Current.RenderIncludes(position: RenderPosition.Left) // ...then the position would be on the left on that page, and on the right (the application default) for anywhere that doesn&#39;t // specified position in the .RenderIncludes() call. PopupRenderPosition = RenderPosition.Right, // defaults to left PopupMaxTracesToShow = 10, // defaults to 15 // ResultsAuthorize (optional - open to all by default): // because profiler results can contain sensitive data (e.g. sql queries with parameter values displayed), we // can define a function that will authorize clients to see the JSON or full page results. // we use it on http://stackoverflow.com to check that the request cookies belong to a valid developer. ResultsAuthorize = request =&amp;gt; request.IsLocal, // ResultsListAuthorize (optional - open to all by default) // the list of all sessions in the store is restricted by default, you must return true to allow it ResultsListAuthorize = request =&amp;gt; { // you may implement this if you need to restrict visibility of profiling lists on a per request basis return true; // all requests are legit in this example }, // Stack trace settings StackMaxLength = 256, // default is 120 characters // (Optional) You can disable &quot;Connection Open()&quot;, &quot;Connection Close()&quot; (and async variant) tracking. // (defaults to true, and connection opening/closing is tracked) TrackConnectionOpenClose = true } // Optional settings to control the stack trace output in the details pane, examples: .ExcludeType(&quot;SessionFactory&quot;) // Ignore any class with the name of SessionFactory) .ExcludeAssembly(&quot;NHibernate&quot;) // Ignore any assembly named NHibernate .ExcludeMethod(&quot;Flush&quot;) // Ignore any method with the name of Flush .AddViewProfiling() // Add MVC view profiling (you want this) // If using EntityFrameworkCore, here&#39;s where it&#39;d go. // .AddEntityFramework() // Extension method in the MiniProfiler.EntityFrameworkCore package ); // If we&#39;re using EntityFramework 6, here&#39;s where it&#39;d go. // This is in the MiniProfiler.EF6 NuGet package. // MiniProfilerEF6.Initialize();}protected void Application_BeginRequest(){ // You can decide whether to profile here, or it can be done in ActionFilters, etc. // We&#39;re doing it here so profiling happens ASAP to account for as much time as possible. if (Request.IsLocal) // Example of conditional profiling, you could just call MiniProfiler.StartNew(); { MiniProfiler.StartNew(); }}protected void Application_EndRequest(){ MiniProfiler.Current?.Stop(); // Be sure to stop the profiler!} 3. 在web.config中添加js配置&amp;lt;add name=&quot;MiniProfiler&quot; path=&quot;profiler/*&quot; verb=&quot;*&quot; type=&quot;System.Web.Routing.UrlRoutingModule&quot; resourceType=&quot;Unspecified&quot; preCondition=&quot;integratedMode&quot; /&amp;gt;4. 在需要的页面添加显示监控代码（所有页面可以在layout.cshtml中添加）4.1 添加命名空间@using StackExchange.Profiling;4.2 在body块最后添加显示代码@MiniProfiler.Current.RenderIncludes(position: RenderPosition.Right, showTrivial: false, showTimeWithChildren: true)" }, { "title": "抽象工厂模式", "url": "/post/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F", "categories": "抽象工厂模式", "tags": "", "date": "2018-11-21 14:14:08 +0800", "snippet": "适用场景适合一系列相关联(依赖)的对象创建。不能解决的问题世界上没有万能的模式，每个设计模式都有适用的场景，也有不能解决的问题。抽象工厂模式也有不能解决的问题，就是不能应对创建系列对象增加系列对象的变化。" }, { "title": "随机数_随机字符串", "url": "/post/RadomString", "categories": "随机数_随机字符串", "tags": "", "date": "2018-11-05 14:14:08 +0800", "snippet": " /// &amp;lt;summary&amp;gt; /// 获取随机字符串 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;Length&quot;&amp;gt;长度&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static string GenerateRandom(int Length) { long tick = DateTime.Now.Ticks; var seed = (int)(tick &amp;amp; 0xffffffffL) | (int)(tick &amp;gt;&amp;gt; 32); //var seed = GetRandomSeed(); Random rd = new Random(seed); return GenerateRandom(rd, Length); } /// &amp;lt;summary&amp;gt; /// 获取随机字符串 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;Length&quot;&amp;gt;长度&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static string GenerateRandom(Random rd, int Length) { string strSep = &quot;,&quot;; char[] chrSep = strSep.ToCharArray(); string strChar = &quot;0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z&quot; + &quot;,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot;; string[] aryChar = strChar.Split(chrSep, strChar.Length); StringBuilder newRandom = new StringBuilder(52); for (int i = 0; i &amp;lt; Length; i++) { newRandom.Append(aryChar[rd.Next(aryChar.Length)]); } return newRandom.ToString(); } /// &amp;lt;summary&amp;gt; /// 产生随机种子 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int GetRandomSeed() { byte[] bytes = new byte[4]; System.Security.Cryptography.RNGCryptoServiceProvider rng = new System.Security.Cryptography.RNGCryptoServiceProvider(); rng.GetBytes(bytes); return BitConverter.ToInt32(bytes, 0); }" }, { "title": "解决 WPF 嵌套的子窗口在改变窗口大小的时候闪烁的问题", "url": "/post/window-flickers", "categories": "wpf, windows, dotnet, csharp", "tags": "", "date": "0000-10-22 19:21:17 +0805", "snippet": "因为 Win32 的窗口句柄是可以跨进程传递的，所以可以用来实现跨进程 UI。不过，本文不会谈论跨进程 UI 的具体实现，只会提及其实现中的一个重要缓解，使用子窗口的方式。你有可能在使用子窗口之后，发现拖拽改变窗口大小的时候，子窗口中的内容不断闪烁。如果你也遇到了这样的问题，那么正好可以阅读本文来解决。问题你可以看一下下面的这张动图，感受一下窗口的闪烁：实际上在拖动窗口的时候，是一直都在闪的，只是每次闪烁都非常快，截取 gif 的时候截不到。如果你希望实际跑一跑项目看看，可以使用下面的代码： walterlv.demo/Walterlv.Demo.HwndWrapping/Walterlv.Demo.HwndWrapping at a88f81477756af2913349970ba2f0bbab01aaf88 · walterlv/walterlv.demo我特地提取了一个提交下的代码，如果你要尝试，不能使用 master 分支，因为 master 分支修复了闪烁的问题。后来使用 CreateWindowEx 创建了一个纯 Win32 窗口，这种闪烁现象更容易被截图：解决 public class HwndWrapper : HwndHost { protected override HandleRef BuildWindowCore(HandleRef hwndParent) { const int WS_CHILD = 0x40000000;++ const int WS_CLIPCHILDREN = 0x02000000; var owner = ((HwndSource)PresentationSource.FromVisual(this)).Handle; var parameters = new HwndSourceParameters(&quot;demo&quot;) { ParentWindow = owner,-- WindowStyle = (int)(WS_CHILD),++ WindowStyle = (int)(WS_CHILD | WS_CLIPCHILDREN), }; var source = new HwndSource(parameters); source.RootVisual = new ChildPage(); return new HandleRef(this, source.Handle); } protected override void DestroyWindowCore(HandleRef hwnd) { } }原因正在探索……参考资料 wpf - Custom dwm drawn window frame flickers on resizing if the window contains a HwndHost element - Stack Overflow WPF多进程UI探索（Like Chrome） - 简书 关于WS_CLIPCHILDREN和WS_CLIPSIBLINGS的理解（个人认为还是相当全面的） - helloj2ee - 博客园" }, { "title": "uos安装nodejs和npm", "url": "/post/uos%E5%AE%89%E8%A3%85nodejs%E5%92%8Cnpm", "categories": "wpf, windows, dotnet, csharp", "tags": "", "date": "0000-10-22 19:21:17 +0805", "snippet": "如果你在网上搜uos安装npm，大概率按照那一套下来，最终安装的是5.8版本，不管你怎么更新就是5.8，虽然官网最新版已经是7.8（2021-04-02），如果你遇到了这种情况，请继续看下文，否则这篇文章对你无意义。下载nodejs去官网https://nodejs.org/en/下载nodejs，如果是用uos系统打开的网站会自动定位到linux版本，否则请手动选择linux版本解压解压到任意目录，目录中不要含中文，定位到解压的目录，复制目录路径备用增加环境变量打开终端，在终端中输入如下命令：sudo vim /etc/profile编辑环境变量文件，在末尾增加如下内容：export NODE_HOME=/data/home/tool/node-v14.16.0-linux-x64 #这是上一步复制的路径，去掉前面的file://export PATH=$PATH:$NODE_HOME/bin输入命令:wq保存退出把环境变量更新到系统输入命令source /etc/profile /etc/bash.bashrc 结束现在再查看nodejs和npm的版本应该就是刚才下载的版本了参考资料 deepin v20 安装nodejs 和 npm" } ]
